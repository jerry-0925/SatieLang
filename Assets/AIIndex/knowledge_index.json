{
  "Chunks": [
    {
      "Source": "Assets/API_KEY_SETUP.md",
      "Content": "# \ud83d\udd10 Satie API Key Management\n\nSatie now includes a modern, centralized API key management system that securely handles all your API credentials in one place.\n\n## Features\n\n\u2705 **Multiple Providers**: OpenAI, ElevenLabs, Anthropic, Google, Azure\n\u2705 **Secure Storage**: Encrypted keys stored in Unity's persistent data path\n\u2705 **Environment Variables**: Support for CI/CD and development workflows\n\u2705 **Legacy Migration**: Automatically migrates from old api_key.txt files\n\u2705 **Visual Management**: Clean Unity editor interface\n\n## Quick Setup\n\n### 1. Open the API Key Manager\n- In Unity: `Satie > API Key Manager`\n\n### 2. Set Your Keys\n- Click on a provider (e.g., OpenAI)\n- Paste your API key\n- Click \"Save\"\n\n### 3. Get API Keys\n- Click the \"?\" button next to any provider to open their console\n- Or visit directly:\n  - **OpenAI**: https://platform.openai.com/api-keys\n  - **ElevenLabs**: https://elevenlabs.io/api\n  - **Anthropic**: https://console.anthropic.com/settings/keys\n  - **Google**: https://makersuite.google.com/app/apikey\n\n## Storage Locations\n\nAPI keys are stored securely in:\n- **Windows**: `%APPDATA%/../LocalLow/[Company]/[Game]/satie_api_keys.json`"
    },
    {
      "Source": "Assets/API_KEY_SETUP.md",
      "Content": "tings/keys\n  - **Google**: https://makersuite.google.com/app/apikey\n\n## Storage Locations\n\nAPI keys are stored securely in:\n- **Windows**: `%APPDATA%/../LocalLow/[Company]/[Game]/satie_api_keys.json`\n- **macOS**: `~/Library/Application Support/[Company]/[Game]/satie_api_keys.json`\n- **Linux**: `~/.config/unity3d/[Company]/[Game]/satie_api_keys.json`\n\n## Environment Variables (Optional)\n\nFor CI/CD or development teams, you can use environment variables:\n\n```bash\n# OpenAI\nexport SATIE_API_KEY_OPENAI=\"sk-...\"\n\n# ElevenLabs\nexport SATIE_API_KEY_ELEVENLABS=\"...\"\n\n# Anthropic\nexport SATIE_API_KEY_ANTHROPIC=\"sk-ant-...\"\n\n# Google\nexport SATIE_API_KEY_GOOGLE=\"...\"\n```\n\nEnvironment variables take priority over saved keys.\n\n## Legacy Migration\n\nThe system automatically migrates from old setups:\n\n### From api_key.txt\n- Your existing `Assets/api_key.txt` will be automatically imported\n- No action needed - just open the API Key Manager\n\n### From .env files\n- Environment variables in `Assets/.env` are detected\n- Format: `OPENAI_API_KEY=sk-...`\n\n## Security\n\n- **Encryption**: Keys are encrypted using Windows DPAPI or equivalent\n- **Local Storage**: Keys never leave your machine"
    },
    {
      "Source": "Assets/API_KEY_SETUP.md",
      "Content": "in `Assets/.env` are detected\n- Format: `OPENAI_API_KEY=sk-...`\n\n## Security\n\n- **Encryption**: Keys are encrypted using Windows DPAPI or equivalent\n- **Local Storage**: Keys never leave your machine\n- **Access Control**: Only your user account can decrypt the keys\n- **Fallback**: Cross-platform base64 encoding if encryption unavailable\n\n## Troubleshooting\n\n### \"No API key configured\"\n1. Open `Satie > API Key Manager`\n2. Set your API key for the required provider\n3. Click \"Save\"\n\n### \"Failed to decrypt key\"\n- This can happen if you moved projects between machines\n- Simply re-enter your API key in the manager\n\n### Legacy files not migrating\n- Click \"Migrate Legacy\" in the API Key Manager\n- Or manually copy keys from old files\n\n## API\n\nThe system can be used programmatically:\n\n```csharp\nusing Satie;\n\n// Get a key\nstring openaiKey = SatieAPIKeyManager.GetKey(SatieAPIKeyManager.Provider.OpenAI);\n\n// Set a key\nSatieAPIKeyManager.SetKey(SatieAPIKeyManager.Provider.OpenAI, \"sk-...\");\n\n// Check if configured\nbool hasKey = SatieAPIKeyManager.HasKey(SatieAPIKeyManager.Provider.OpenAI);\n\n// Get endpoint\nstring endpoint = SatieAPIKeyManager.GetEndpoint(SatieAPIKeyManager.Provider.OpenAI);\n```"
    },
    {
      "Source": "Assets/API_KEY_SETUP.md",
      "Content": "k if configured\nbool hasKey = SatieAPIKeyManager.HasKey(SatieAPIKeyManager.Provider.OpenAI);\n\n// Get endpoint\nstring endpoint = SatieAPIKeyManager.GetEndpoint(SatieAPIKeyManager.Provider.OpenAI);\n```\n\n## Best Practices\n\n1. **Don't commit API keys** to version control\n2. **Use environment variables** for team development\n3. **Regular key rotation** for security\n4. **Check key permissions** on provider consoles\n5. **Monitor usage** on provider dashboards\n\n## Migration from Old System\n\nIf you were using the old `api_key.txt` system:\n\n1. Your keys will be automatically migrated\n2. You can safely delete old `api_key.txt` files after migration\n3. Update any scripts that were reading files directly\n\nThe new system is backward compatible - existing Satie components will automatically use the centralized manager."
    },
    {
      "Source": "Assets/Tutorial.md",
      "Content": "# Satie Language Tutorial\n\nWelcome to the **Satie** scripting language for sound-based behavior in Unity. This tutorial introduces the syntax and capabilities of SatieLang through progressively more complex examples located in `Assets/Tutorial`.\n\n---\n\n## Section 0: Syntax Overview\n\nEach **statement** in Satie is either a `loop` or a `oneshot`, optionally nested inside a `group`.\n\n### Top-Level Forms\n- `loop \"clip/path\":`: continuously playing sound\n- `oneshot \"clip/path\" every X..Y:`: discrete event triggered periodically\n- `group name:`: defines a set of shared defaults for child statements\n\n### Core Parameters\n| Name        | Type               | Description                                                                 |\n|-------------|--------------------|-----------------------------------------------------------------------------|\n| `clip`      | `string`           | Path to an audio clip under `Resources/Audio/`                             |\n| `volume`    | `RangeOrValue`     | Amplitude (0.0 to 1.0); can be randomized                                   |\n| `pitch`     | `RangeOrValue`     | Playback speed multiplier (1.0 = normal)                                   |"
    },
    {
      "Source": "Assets/Tutorial.md",
      "Content": "`     | Amplitude (0.0 to 1.0); can be randomized                                   |\n| `pitch`     | `RangeOrValue`     | Playback speed multiplier (1.0 = normal)                                   |\n| `starts_at` | `RangeOrValue`     | When the sound starts (in seconds)                                         |\n| `duration`  | `RangeOrValue`     | Lifespan of the sound (in seconds); it stops after this                    |\n| `fade_in`   | `RangeOrValue`     | Time to fade in                                                            |\n| `fade_out`  | `RangeOrValue`     | Time to fade out                                                           |\n| `every`     | `RangeOrValue`     | Interval for repeating a `oneshot`                                         |\n| `overlap`   | `bool`             | If true, allows overlapping instances                                      |\n| `visualize` | `bool`             | Shows a Trail Renderer for moving sounds                                   |\n\n### Movement (`move`)\nSyntax:\n```\nmove = [type], xRange, yRange, zRange, speed\n```\n- `pos`: static position\n- `walk`: movement in X and Z only\n- `fly`: movement in full 3D space"
    },
    {
      "Source": "Assets/Tutorial.md",
      "Content": "|\n\n### Movement (`move`)\nSyntax:\n```\nmove = [type], xRange, yRange, zRange, speed\n```\n- `pos`: static position\n- `walk`: movement in X and Z only\n- `fly`: movement in full 3D space\n- Last parameter is always speed (units per second)\n\n### Randomization\n- Use `5..10` for ranges (any numeric parameter)\n- Use `\"clip/1..3\"` to randomly choose one of multiple files\n\n---\n\n## Section 1: Hello World (1. hello world)\n```satie\n# 'oneshot' defines a single, non-looping sound event\n# Triggers every 3\u20135 seconds, with full volume\noneshot \"conversation/hello\" every 3..5:\n    volume = 1\n```\n- Clip must be located at `Assets/Resources/Audio/conversation/hello.wav`\n\n---\n\n## Section 2: Loops (2. loops)\n```satie\nloop \"ambience/forest\":\n    volume = 0.1\n    fade_in = 5\n\nloop \"ambience/water\":\n    volume = 0.08\n    pitch = 0.8..1.2\n    fade_in = 10\n```\n- You can spawn multiple simultaneous loops by prefixing with a number and `*`.\n  This example layers three copies of the same ambience:\n```satie\n3 * loop \"ambience/forest\":\n    volume = 0.05\n    pitch = 0.9..1.1\n```\n- Loops are great for ambience\n- Fade-ins help avoid abrupt starts\n\n---\n\n## Section 3: Randomization (3. randomization)"
    },
    {
      "Source": "Assets/Tutorial.md",
      "Content": "```satie\n3 * loop \"ambience/forest\":\n    volume = 0.05\n    pitch = 0.9..1.1\n```\n- Loops are great for ambience\n- Fade-ins help avoid abrupt starts\n\n---\n\n## Section 3: Randomization (3. randomization)\n```satie\noneshot \"bicycle/1..30\" every 0.5..1:\n    volume = 0.5..1\n    pitch = 0.5..1.5\n    move = fly, -5..5, 0..5, -5..5, 0.06\n```\n- File and parameter randomization create natural variety\n\n---\n\n## Section 4: Spatialization (4. spatialization)\n```satie\ngroup birds:\nvolume = 0.4\npitch = 0.35\n    oneshot \"bird/1..3\" every 1..10:\n        volume = 0.8..1\n        fade_in = 1..5\n        move = fly, -15..15, 0..15, -15..15, 0.1\n        visualize = true\n\n    oneshot \"bird/1..3\" every 1..5:\n        volume = 0.8..1\n        fade_in = 1..5\n        move = fly, -20..20, 0..15, -20..20, 0.03..0.1\n        visualize = true\n\ngroup conversation:\nvolume = 0.8\n    oneshot \"conversation/hello\" every 1..4:\n        volume = 0.8..1\n        pitch = 0.1..1.5\n        fade_in = 1..5\n        move = walk, -5..5, -5..5, 0.08\n        visualize = true\n\ngroup forest:\nvolume = 0.2\n    loop \"ambience/forest\":\n        volume = 0.4\n        fade_in = 10\n        move = pos, 2, 0, 3\n    loop \"ambience/water\":"
    },
    {
      "Source": "Assets/Tutorial.md",
      "Content": "k, -5..5, -5..5, 0.08\n        visualize = true\n\ngroup forest:\nvolume = 0.2\n    loop \"ambience/forest\":\n        volume = 0.4\n        fade_in = 10\n        move = pos, 2, 0, 3\n    loop \"ambience/water\":\n        volume = 0.8\n        fade_in = 10\n        move = walk, -10..10, -10..10, 0.01\n```\n- `move` types define spatial behavior\n- `visualize` adds a Trail Renderer for debugging\n\n---\n\n## Section 5: Groups (5. groups)\n```satie\ngroup music:\npitch = 0.5\nvolume = 1\nfade_in = 0.5\n\n    loop \"music/drone\":\n        volume = 0.07\n        fade_in = 35\n\n    loop \"music/drone\":\n        volume = 0.02\n        pitch = 2\n        fade_in = 30..40\n\n    oneshot \"music/1..3\" every 20..40:\n        volume = 0.5\n        move = pos, -10..10, 0..10, -10..10\n\n    loop \"sacred/1\":\n        volume = 0.3\n        move = walk, -10..10, -10..10, 0.01\n        visualize = true\n        fade_in = 50\n```\n- Group-level parameters apply to all child tracks unless overridden\n- `fade_in = 0.5` multiplies children's fade_in time (e.g., halves it)\n\n---\n\n## Section 6: Sequencing (6. sequencing)\n```satie\nloop \"music/drone\":\n    volume = 0.2\n    starts_at = 1\n    fade_in = 35\n    duration = 60\n\nloop \"music/drone\":"
    },
    {
      "Source": "Assets/Tutorial.md",
      "Content": "s fade_in time (e.g., halves it)\n\n---\n\n## Section 6: Sequencing (6. sequencing)\n```satie\nloop \"music/drone\":\n    volume = 0.2\n    starts_at = 1\n    fade_in = 35\n    duration = 60\n\nloop \"music/drone\":\n    volume = 0.08\n    pitch = 2\n    starts_at = 10\n    fade_in = 30..40\n    duration = 50\n\nloop \"music/drone\":\n    volume = 0.04\n    pitch = 2.5\n    starts_at = 15\n    fade_in = 35\n    duration = 35\n```\n- `starts_at` defines the delay (in seconds) before a track starts\n- `duration` defines how long a track exists before being removed\n- This enables layering and timed evolution of ambient textures"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "# Steam Audio Third-Party Licenses\n\n## Intel Integrated Performance Primitives (IPP)\n\nIntel Simplified Software License (Version October 2022)\n\nUse and Redistribution.  You may use and redistribute the software, which is provided in binary form only, (the \u201cSoftware\u201d), without modification, provided the following conditions are met:\n\nRedistributions must reproduce the above copyright notice and these terms of use in the Software and in the documentation and/or other materials provided with the distribution.\nNeither the name of Intel nor the names of its suppliers may be used to endorse or promote products derived from this Software without specific prior written permission.\nNo reverse engineering, decompilation, or disassembly of the Software is permitted, nor any modification or alteration of the Software or its operation at any time, including during execution.\nNo other licenses.  Except as provided in the preceding section, Intel grants no licenses or other rights by implication, estoppel or otherwise to, patent, copyright, trademark, trade name, service mark or other intellectual property licenses or rights of Intel."
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "Intel grants no licenses or other rights by implication, estoppel or otherwise to, patent, copyright, trademark, trade name, service mark or other intellectual property licenses or rights of Intel.\n\nThird party software.  \u201cThird Party Software\u201d means the files (if any) listed in the \u201cthird-party-software.txt\u201d or other similarly-named text file that may be included with the Software. Third Party Software, even if included with the distribution of the Software, may be governed by separate license terms, including without limitation, third party license terms, open source software notices and terms, and/or other Intel software license terms. These separate license terms solely govern Your use of the Third Party Software."
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "tation, third party license terms, open source software notices and terms, and/or other Intel software license terms. These separate license terms solely govern Your use of the Third Party Software.\n\nDISCLAIMER.  THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT ARE DISCLAIMED. THIS SOFTWARE IS NOT INTENDED FOR USE IN SYSTEMS OR APPLICATIONS WHERE FAILURE OF THE SOFTWARE MAY CAUSE PERSONAL INJURY OR DEATH AND YOU AGREE THAT YOU ARE FULLY RESPONSIBLE FOR ANY CLAIMS, COSTS, DAMAGES, EXPENSES, AND ATTORNEYS\u2019 FEES ARISING OUT OF ANY SUCH USE, EVEN IF ANY CLAIM ALLEGES THAT INTEL WAS NEGLIGENT REGARDING THE DESIGN OR MANUFACTURE OF THE SOFTWARE."
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "BLE FOR ANY CLAIMS, COSTS, DAMAGES, EXPENSES, AND ATTORNEYS\u2019 FEES ARISING OUT OF ANY SUCH USE, EVEN IF ANY CLAIM ALLEGES THAT INTEL WAS NEGLIGENT REGARDING THE DESIGN OR MANUFACTURE OF THE SOFTWARE.\n\nLIMITATION OF LIABILITY. IN NO EVENT WILL INTEL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nNo support.  Intel may make changes to the Software, at any time without notice, and is not obligated to support, update or provide training for the Software.\n\nTermination. Your right to use the Software is terminated in the event of your breach of this license."
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "without notice, and is not obligated to support, update or provide training for the Software.\n\nTermination. Your right to use the Software is terminated in the event of your breach of this license.\n\nFeedback.  Should you provide Intel with comments, modifications, corrections, enhancements or other input (\u201cFeedback\u201d) related to the Software, Intel will be free to use, disclose, reproduce, license or otherwise distribute or exploit the Feedback in its sole discretion without any obligations or restrictions of any kind, including without limitation, intellectual property rights or licensing obligations.\n\nCompliance with laws.  You agree to comply with all relevant laws and regulations governing your use, transfer, import or export (or prohibition thereof) of the Software."
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "or licensing obligations.\n\nCompliance with laws.  You agree to comply with all relevant laws and regulations governing your use, transfer, import or export (or prohibition thereof) of the Software.\n\nGoverning law.  All disputes will be governed by the laws of the United States of America and the State of Delaware without reference to conflict of law principles and subject to the exclusive jurisdiction of the state or federal courts sitting in the State of Delaware, and each party agrees that it submits to the personal jurisdiction and venue of those courts and waives any objections. THE UNITED NATIONS CONVENTION ON CONTRACTS FOR THE INTERNATIONAL SALE OF GOODS (1980) IS SPECIFICALLY EXCLUDED AND WILL NOT APPLY TO THE SOFTWARE.\n\n## FFTS\n\nThis file is part of FFTS -- The Fastest Fourier Transform in the South\n\nCopyright (c) 2012, 2013 Anthony M. Blake <amb@anthonix.com>\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer."
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "tion, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n* Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution.\n* Neither the name of the organization nor the\n    names of its contributors may be used to endorse or promote products\n    derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL ANTHONY M. BLAKE BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": ", SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n## PFFFT\n\nCopyright (c) 2020  Dario Mambro ( dario.mambro@gmail.com )\nCopyright (c) 2019  Hayati Ayguen ( h_ayguen@web.de )\nCopyright (c) 2013  Julien Pommier ( pommier@modartt.com )\n\nCopyright (c) 2004 the University Corporation for Atmospheric\nResearch (\"UCAR\"). All rights reserved. Developed by NCAR's\nComputational and Information Systems Laboratory, UCAR,\nwww.cisl.ucar.edu.\n\nRedistribution and use of the Software in source and binary forms,\nwith or without modification, is permitted provided that the\nfollowing conditions are met:\n\n- Neither the names of NCAR's Computational and Information Systems\nLaboratory, the University Corporation for Atmospheric Research,\nnor the names of its sponsors or contributors may be used to"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "met:\n\n- Neither the names of NCAR's Computational and Information Systems\nLaboratory, the University Corporation for Atmospheric Research,\nnor the names of its sponsors or contributors may be used to\nendorse or promote products derived from this Software without\nspecific prior written permission.\n\n- Redistributions of source code must retain the above copyright\nnotices, this list of conditions, and the disclaimer below.\n\n- Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions, and the disclaimer below in the\ndocumentation and/or other materials provided with the\ndistribution.\n\nTHIS SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, INDIRECT, INCIDENTAL, SPECIAL,\nEXEMPLARY, OR CONSEQUENTIAL DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE\nSOFTWARE.\n\n## MySOFA"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "AL DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE\nSOFTWARE.\n\n## MySOFA\n\nCopyright (c) 2016-2017, Symonics GmbH, Christian Hoene\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    (1) Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n\n    (2) Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in\n    the documentation and/or other materials provided with the\n    distribution.\n\n    (3)The name of the author may not be used to\n    endorse or promote products derived from this software without\n    specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\nIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "S SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\nIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\nINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\nHOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\nSTRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n\n## Intel Embree\n\n\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "an the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "ource code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "hat remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "ation that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "ed in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "d in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "tain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "se, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "s) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "icense, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n## AMD RadeonRays\n\nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software."
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "e Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n## AMD TrueAudio Next\n\nMIT license\n\nCopyright (c) 2019 Advanced Micro Devices, Inc. All rights reserved.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "ut restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n## CIPIC HRTF Database\n\nSponsorship\n\n  This work was supported by the National Science Foundation under Grants\n  IRI-9619339 and ITR-0086075. Any opinions, findings and conclusions or\n  recommendations expressed in this material are those of the authors, and\n  do not necessarily reflect the views of the National Science Foundation.\n\nCopyright"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "opinions, findings and conclusions or\n  recommendations expressed in this material are those of the authors, and\n  do not necessarily reflect the views of the National Science Foundation.\n\nCopyright\n\nCopyright (c) 2001 The Regents of the University of California. All Rights Reserved\n\nDisclaimer\n\nTHE REGENTS OF THE UNIVERSITY OF CALIFORNIA MAKE NO REPRESENTATION OR\nWARRANTIES WITH RESPECT TO THE CONTENTS HEREOF AND SPECIFICALLY DISCLAIM ANY\nIMPLIED WARRANTIES OR MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE.\n\nFurther, the Regents of the University of California reserve the right to\nrevise this software and/or documentation and to make changes from time to\ntime in the content hereof without obligation of the Regents of the University\nof California to notify any person of such revision or change.\n\nUse of Materials\n\nThe Regents of the University of California hereby grant users permission to\nreproduce and/or use materials available therein for any purpose- educational,\nresearch or commercial. However, each reproduction of any part of the\nmaterials must include the copyright notice, if it is present."
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "/or use materials available therein for any purpose- educational,\nresearch or commercial. However, each reproduction of any part of the\nmaterials must include the copyright notice, if it is present.\n\nIn addition, as a courtesy, if these materials are used in published research,\nthis use should be acknowledged in the publication. If these materials are\nused in the development of commercial products, the Regents of the University\nof California request that written acknowledgment of such use be sent to:\n\n     CIPIC- Center for Image Processing and Integrated Computing\n     University of California\n     1 Shields Avenue\n     Davis, CA 95616-8553\n\n## Google Spherical Harmonics Library\n\n\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "an the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "ource code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "hat remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "ation that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "ed in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "tain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "se, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "s) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0"
    },
    {
      "Source": "Assets/steamaudio_unity/THIRDPARTY.md",
      "Content": "icense, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License."
    },
    {
      "Source": "Assets/Tutorial/1. hello world.sat",
      "Content": "# Hello World!\n\n# 'oneshot' defines a single, non-looping sound event \u2014 great for short samples like voice lines, hits, or UI sounds.\n# This event plays the clip \"conversation/hello\", which should be located at:\n# Assets/Resources/Audio/conversation/hello.wav (or .mp3, .ogg, etc.)\n# Unity will load this using the Resources system, so the path is relative to Resources/Audio (without the extension).\n# The sound will randomly trigger once every 3 to 5 seconds \u2014 useful for ambient chatter or occasional voice lines.\n\n\noneshot \"conversation/hello\" every 5to6:\n    volume = 1"
    },
    {
      "Source": "Assets/Tutorial/2. loops.sat",
      "Content": "# Loops\n# loops are useful for continuous or ambient sounds that should stay active in the background\n\nloop \"ambience/forest\":\n    volume = 0.1        # subtle, steady presence\n    fade_in = 5\n\nloop \"ambience/water\":\n    volume = 0.08        # quieter, more subtle\n    pitch = 0.8to1.2    # pitch varies slightly on each loop, adding natural variation\n    fade_in = 10\n\n# prefix with a number to create multiple layers\n3 * loop \"ambience/forest\":\n    volume = 0.05\n    pitch = 0.9to1.1"
    },
    {
      "Source": "Assets/Tutorial/3. randomization.sat",
      "Content": "loop \"ambience/rain\":\n    volume = 0.05\n    fade_in = 3\n\n\n3 * oneshot \"animals/cow2\" every 5to10:\n    volume = 0.1to0.2\n    pitch = 0.5to1.2\n    fade_in = 5to10\n    move = fly, -20to20, 0to10, -15to10, 0.01\n    visual = trail\n\noneshot \"animals/cicada\" every 5to10:\n    volume = 0.1to0.2\n    pitch = 0.5to1.2\n    fade_in = 5to10\n    visual = trail\n\n\n\noneshot \"bird/1to3\" every 4to10:\n    pitch = 0.6to1\n    volume = 0.01to0.1\n    move = fly, -20to20, 0to10, -15to10, 0.01"
    },
    {
      "Source": "Assets/Tutorial/4. spatialization.sat",
      "Content": "# Spatialization\n# Use 'move' to animate sound sources in 3D space.\n# Format: move = [type], xRange, yRange, zRange, speed\n# - pos: static position (no movement)\n# - walk: moves only along X and Z axes (Y is ignored)\n# - fly: moves in full 3D space (X, Y, Z)\n# The last value is always the speed (units per second)\n# 'visual = trail' adds a Trail Renderer to show movement over time\n# You can use other primitives like 'visual = sphere' or 'visual = cube'\n# For custom prefabs: 'visual = object \"prefabName\"' (stored in Resources/Prefabs)\n# Multiple visuals: 'visual = trail and sphere'\n\ngroup birds:\nvolume = 0.4\npitch = 0.35\n    oneshot \"bird/1to3\" every 1to10:\n        volume = 0.8to1\n        fade_in = 1to5\n        move = fly, -15to15, 0to15, -15to15, 0.1\n        visual = trail\n\n    oneshot \"bird/1to3\" every 1to5:\n        volume = 0.8to1\n        fade_in = 1to5\n        move = fly, -20to20, 0to15, -20to20, 0.03to0.1\n        visual = trail\n\ngroup conversation:\nvolume = 0.8\n    oneshot \"conversation/hello\" every 1to4:\n        volume = 0.8to1\n        pitch = 0.1to1.5\n        fade_in = 1to5\n        move = walk, -5to5, -5to5, 0.08\n        visual = trail\n\ngroup forest:\nvolume = 0.2"
    },
    {
      "Source": "Assets/Tutorial/4. spatialization.sat",
      "Content": "hot \"conversation/hello\" every 1to4:\n        volume = 0.8to1\n        pitch = 0.1to1.5\n        fade_in = 1to5\n        move = walk, -5to5, -5to5, 0.08\n        visual = trail\n\ngroup forest:\nvolume = 0.2\n    loop \"ambience/forest\":\n        volume = 0.4\n        fade_in = 10\n        move = pos, 2, 0, 3\n    loop \"ambience/water\":\n        volume = 0.8\n        fade_in = 10\n        move = walk, -10to10, -10to10, 0.01"
    },
    {
      "Source": "Assets/Tutorial/5. groups.sat",
      "Content": "# groups.sat \u2014 defines a named group of sounds that share common defaults\n\ngroup music:\npitch = 0.5  # pitch multiplier (0.5 lowers pitch one octave)\nvolume = 1   # global volume multiplier (0 to 1)\nfade_in = 0.5 # multiplies the fade_in time of all child events (e.g., 0.5 halves it, 2 doubles it)\n\n    loop \"music/drone\":\n        volume = 0.07\n        fade_in = 35\n\n    loop \"music/drone\":\n        volume = 0.02\n        pitch = 2\n        fade_in = 30to40\n\n    oneshot \"music/1to3\" every 20to40:\n        volume = 0.5\n        move = pos, -10to10, 0to10, -10to10\n\n    loop \"sacred/1\":\n        volume = 0.3\n        move = walk, -10to10, -10to10, 0.01\n        visual = trail\n        fade_in = 50"
    },
    {
      "Source": "Assets/Tutorial/6. sequencing.sat",
      "Content": "# Sequencing\n# You can layer multiple loops of the same clip with different start times, durations, and parameters.\n# This creates evolving, non-repetitive textures \u2014 useful for ambient music or generative soundscapes.\n#\n# - 'starts_at' means when (in seconds) the track begins after the group is triggered.\n# - 'duration' defines how long the track exists before stopping completely \u2014 it does not restart or loop again.\n\nloop \"music/drone\":\n    volume = 0.2           # base layer with strong presence\n    starts_at = 1          # starts 1 second after group begins\n    fade_in = 35           # slow fade-in\n    duration = 60          # removed after 60 seconds\n\nloop \"music/drone\":\n    volume = 0.08\n    pitch = 2              # two octaves up for tonal variation\n    starts_at = 10         # starts 10 seconds into the group\n    fade_in = 30to40       # randomized fade-in duration\n    duration = 50          # removed after 50 seconds\n\nloop \"music/drone\":\n    volume = 0.04\n    pitch = 2.5            # even higher pitch, very subtle layer\n    starts_at = 15         # starts after 15 seconds\n    fade_in = 35\n    duration = 35"
    },
    {
      "Source": "Assets/Scripts/AI_README.md",
      "Content": "# Satie AI Code Generation\n\n## Setup Instructions\n\n1. **Get an OpenAI API Key**\n   - Go to https://platform.openai.com/api-keys\n   - Create a new API key\n   - Copy the key (starts with `sk-`)\n\n2. **Add API Key to Unity**\n   - Create a new file: `Assets/api_key.txt`\n   - Paste your API key into this file\n   - Save the file\n   - \u26a0\ufe0f IMPORTANT: This file is already in .gitignore - never commit API keys!\n\n3. **Using the AI Generator**\n   - Select any GameObject with a `SatieRuntime` component\n   - In the Inspector, find the \"AI Code Generation\" section\n   - Enter a natural language prompt describing the audio experience you want\n   - Click \"Generate Satie Code\"\n   - Review the generated code\n   - Click \"Apply to Current Script\" or \"Save as New Script\"\n\n## Example Prompts\n\n- \"Create a peaceful forest ambience with birds chirping randomly\"\n- \"Make a busy street scene with cars passing by and footsteps\"\n- \"Generate spooky atmosphere with random voices and ambient sounds\"\n- \"Create rhythmic beat with multiple synchronized loops\"\n- \"Design a 3D audio experience with sounds moving around the listener\"\n\n## Features\n\n- Uses OpenAI's o1-preview model for advanced reasoning"
    },
    {
      "Source": "Assets/Scripts/AI_README.md",
      "Content": "- \"Create rhythmic beat with multiple synchronized loops\"\n- \"Design a 3D audio experience with sounds moving around the listener\"\n\n## Features\n\n- Uses OpenAI's o1-preview model for advanced reasoning\n- Understands all Satie language syntax\n- Knows about available audio resources in your project\n- Generates clean, commented code\n- Can create complex multi-layered soundscapes\n- Supports spatial audio with movement patterns\n\n## Troubleshooting\n\n- **API Key Not Found**: Make sure `Assets/api_key.txt` exists and contains your key\n- **API Request Failed**: Check your internet connection and API key validity\n- **No Response**: Try a simpler prompt or check Unity console for errors\n\n## Configuration\n\nYou can modify the AI settings in the `SatieAICodeGen.cs` file:\n- `model`: Change to \"gpt-4\" or \"gpt-3.5-turbo\" for different models\n- `temperature`: Adjust creativity (0.0 = deterministic, 1.0 = creative)\n- `maxTokens`: Maximum length of generated code\n\n## Security Note\n\nNever share or commit your API key! The `.gitignore` file is configured to exclude:\n- `/Assets/api_key.txt`\n- `/Assets/*.key`\n- Any file with `.key` extension in Assets folder"
    },
    {
      "Source": "Assets/Scripts/SSpatial.cs",
      "Content": "using UnityEngine;\n\nnamespace Satie\n{\n    public class SSpatial : MonoBehaviour\n    {\n        public Statement.WanderType type = Statement.WanderType.None;\n        public Vector3 minPos, maxPos;\n        public float hz = 0.3f; \n        private Vector3 seed;\n\n        void Start()\n        {\n            seed = new Vector3(\n                Random.value * 1000f,\n                Random.value * 1000f,\n                Random.value * 1000f);\n        }\n\n        void Update()\n        {\n            if (type == Statement.WanderType.None) return;\n\n            float scaledHz = hz * 0.01f;\n            float t = Time.time * scaledHz * 2f * Mathf.PI;\n\n            Vector3 noise = new Vector3(\n                Mathf.PerlinNoise(seed.x, t)       - 0.5f,\n                Mathf.PerlinNoise(seed.y, t * 0.8f) - 0.5f,\n                Mathf.PerlinNoise(seed.z, t * 1.3f) - 0.5f);\n\n            Vector3 half = (maxPos - minPos) * 0.5f;\n            Vector3 cen  = (maxPos + minPos) * 0.5f;\n            Vector3 off  = Vector3.Scale(noise * 2f, half);\n\n            if (type == Statement.WanderType.Walk) off.y = 0f;\n\n            transform.position = cen + off;\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Scripts/SatAssetCreator.cs",
      "Content": "// Assets/Editor/SatAssetCreator.cs\nusing System.IO;\nusing UnityEditor;\nusing UnityEditor.ProjectWindowCallback;\nusing UnityEngine;\n\nstatic class SatAssetCreator\n{\n    private const string kDefaultContent =\n        @\"# Satie Script - Hello World!\nloop \"\"hello\"\":\n    volume = 0.8\n    pitch = 0.8to1.2\n\";\n\n    [MenuItem(\"Assets/Create/Satie Script (.sat)\", false, 82)]\n    private static void CreateSatMenu()\n    {\n        // Ask the Project window to start a \u201cnew asset\u201d rename operation.\n        ProjectWindowUtil.StartNameEditingIfProjectWindowExists(\n            0,\n            ScriptableObject.CreateInstance<CreateSatAction>(),\n            \"NewSatieScript.sat\",\n            EditorGUIUtility.IconContent(\"TextAsset Icon\").image as Texture2D,\n            null);\n    }\n    \n\n    private class CreateSatAction : EndNameEditAction\n    {\n        public override void Action(int instanceId, string pathName, string resourceFile)\n        {\n            File.WriteAllText(pathName, kDefaultContent);\n            AssetDatabase.ImportAsset(pathName, ImportAssetOptions.ForceUpdate);\n            var asset = AssetDatabase.LoadAssetAtPath<TextAsset>(pathName);"
    },
    {
      "Source": "Assets/Scripts/SatAssetCreator.cs",
      "Content": "e.WriteAllText(pathName, kDefaultContent);\n            AssetDatabase.ImportAsset(pathName, ImportAssetOptions.ForceUpdate);\n            var asset = AssetDatabase.LoadAssetAtPath<TextAsset>(pathName);\n            ProjectWindowUtil.ShowCreatedAsset(asset);\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Scripts/SatImporter.cs",
      "Content": "using System.IO;\nusing UnityEditor;\nusing UnityEditor.AssetImporters;\nusing UnityEngine;\n\n// Turns every .sat file into a TextAsset.\n[ScriptedImporter(1, \"sat\")]\npublic class SatImporter : ScriptedImporter\n{\n    public override void OnImportAsset(AssetImportContext ctx)\n    {\n        var txt = File.ReadAllText(ctx.assetPath);\n        var asset = new TextAsset(txt)\n        {\n            name = Path.GetFileNameWithoutExtension(ctx.assetPath)\n        };\n\n        ctx.AddObjectToAsset(\"text\", asset);\n        ctx.SetMainObject(asset);\n    }\n}"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing UnityEngine;\n\nnamespace Satie\n{\n    /// <summary>\n    /// Modern implementation using OpenAI Assistants API v2 with File Search\n    /// Replaces the old TF-IDF based knowledge indexing system\n    /// </summary>\n    public class SatieAIAssistant : MonoBehaviour\n    {\n        private static SatieAIAssistant instance;\n        public static SatieAIAssistant Instance\n        {\n            get\n            {\n                if (instance == null)\n                {\n                    var go = new GameObject(\"SatieAIAssistant\");\n                    instance = go.AddComponent<SatieAIAssistant>();\n                    DontDestroyOnLoad(go);\n                }\n                return instance;\n            }\n        }\n\n        [Header(\"Assistant Configuration\")]\n        [SerializeField] private string assistantId;\n        [SerializeField] private string vectorStoreId;\n        [SerializeField] private string assistantName = \"Satie Code Generator\";"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "guration\")]\n        [SerializeField] private string assistantId;\n        [SerializeField] private string vectorStoreId;\n        [SerializeField] private string assistantName = \"Satie Code Generator\";\n        [SerializeField] private string model = \"gpt-4-turbo-preview\";\n\n        private HttpClient httpClient;\n        private string apiKey;\n        private string currentThreadId;\n        private HashSet<string> uploadedFiles = new HashSet<string>();\n        private Dictionary<string, string> fileIdMap = new Dictionary<string, string>();\n\n        private const string BASE_URL = \"https://api.openai.com/v1\";\n\n        #region Data Models\n        [System.Serializable]\n        public class AssistantRequest\n        {\n            public string model;\n            public string name;\n            public string instructions;\n            public Tool[] tools;\n            public ToolResources tool_resources;\n        }\n\n        [System.Serializable]\n        public class Tool\n        {\n            public string type;\n        }\n\n        [System.Serializable]\n        public class ToolResources\n        {\n            public FileSearchResource file_search;\n        }\n\n        [System.Serializable]"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "public string type;\n        }\n\n        [System.Serializable]\n        public class ToolResources\n        {\n            public FileSearchResource file_search;\n        }\n\n        [System.Serializable]\n        public class FileSearchResource\n        {\n            public string[] vector_store_ids;\n        }\n\n        [System.Serializable]\n        public class AssistantResponse\n        {\n            public string id;\n            public string @object;\n            public long created_at;\n            public string name;\n            public string model;\n            public string instructions;\n            public Tool[] tools;\n            public ToolResources tool_resources;\n        }\n\n        [System.Serializable]\n        public class VectorStoreRequest\n        {\n            public string name;\n            public FileChunkingStrategy chunking_strategy;\n        }\n\n        [System.Serializable]\n        public class FileChunkingStrategy\n        {\n            public string type = \"auto\";\n        }\n\n        [System.Serializable]\n        public class VectorStoreResponse\n        {\n            public string id;\n            public string @object;\n            public long created_at;"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "auto\";\n        }\n\n        [System.Serializable]\n        public class VectorStoreResponse\n        {\n            public string id;\n            public string @object;\n            public long created_at;\n            public string name;\n            public int usage_bytes;\n            public FileCounts file_counts;\n            public string status;\n        }\n\n        [System.Serializable]\n        public class FileCounts\n        {\n            public int in_progress;\n            public int completed;\n            public int failed;\n            public int cancelled;\n            public int total;\n        }\n\n        [System.Serializable]\n        public class ThreadRequest\n        {\n            public Message[] messages;\n            public ToolResources tool_resources;\n        }\n\n        [System.Serializable]\n        public class Message\n        {\n            public string role;\n            public string content;\n        }\n\n        [System.Serializable]\n        public class ThreadResponse\n        {\n            public string id;\n            public string @object;\n            public long created_at;\n        }\n\n        [System.Serializable]\n        public class RunRequest\n        {"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "ponse\n        {\n            public string id;\n            public string @object;\n            public long created_at;\n        }\n\n        [System.Serializable]\n        public class RunRequest\n        {\n            public string assistant_id;\n            public string instructions;\n            public string[] tools;\n            public float temperature;\n            public int max_completion_tokens;\n        }\n\n        [System.Serializable]\n        public class RunResponse\n        {\n            public string id;\n            public string @object;\n            public long created_at;\n            public string thread_id;\n            public string assistant_id;\n            public string status;\n            public Usage usage;\n        }\n\n        [System.Serializable]\n        public class Usage\n        {\n            public int prompt_tokens;\n            public int completion_tokens;\n            public int total_tokens;\n        }\n\n        [System.Serializable]\n        public class MessageListResponse\n        {\n            public MessageResponse[] data;\n        }\n\n        [System.Serializable]\n        public class MessageResponse\n        {\n            public string id;"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "ic class MessageListResponse\n        {\n            public MessageResponse[] data;\n        }\n\n        [System.Serializable]\n        public class MessageResponse\n        {\n            public string id;\n            public string @object;\n            public long created_at;\n            public string thread_id;\n            public string role;\n            public ContentItem[] content;\n        }\n\n        [System.Serializable]\n        public class ContentItem\n        {\n            public string type;\n            public TextContent text;\n        }\n\n        [System.Serializable]\n        public class TextContent\n        {\n            public string value;\n        }\n\n        [System.Serializable]\n        public class FileUploadResponse\n        {\n            public string id;\n            public string @object;\n            public int bytes;\n            public long created_at;\n            public string filename;\n            public string purpose;\n        }\n\n        [System.Serializable]\n        public class FileAttachRequest\n        {\n            public string file_id;\n        }\n\n        [System.Serializable]\n        public class AssistantUpdateRequest\n        {"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "System.Serializable]\n        public class FileAttachRequest\n        {\n            public string file_id;\n        }\n\n        [System.Serializable]\n        public class AssistantUpdateRequest\n        {\n            public ToolResources tool_resources;\n        }\n        #endregion\n\n        private async void Start()\n        {\n            await Initialize();\n        }\n\n        public async Task<bool> Initialize()\n        {\n            try\n            {\n                // Load API key\n                if (!await LoadApiKey())\n                {\n                    Debug.LogError(\"[AI Assistant] Failed to load API key\");\n                    return false;\n                }\n\n                // Initialize HTTP client\n                httpClient = new HttpClient();\n                httpClient.DefaultRequestHeaders.Authorization =\n                    new AuthenticationHeaderValue(\"Bearer\", apiKey);\n                httpClient.DefaultRequestHeaders.Add(\"OpenAI-Beta\", \"assistants=v2\");\n\n                // Create or retrieve assistant\n                if (string.IsNullOrEmpty(assistantId))\n                {\n                    await CreateAssistant();\n                }\n                else"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "// Create or retrieve assistant\n                if (string.IsNullOrEmpty(assistantId))\n                {\n                    await CreateAssistant();\n                }\n                else\n                {\n                    await RetrieveAssistant();\n                }\n\n                // Create or retrieve vector store\n                if (string.IsNullOrEmpty(vectorStoreId))\n                {\n                    await CreateVectorStore();\n                }\n\n                // Upload project files to vector store\n                await UploadProjectFiles();\n\n                Debug.Log($\"[AI Assistant] Initialized successfully. Assistant: {assistantId}, Vector Store: {vectorStoreId}\");\n                return true;\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"[AI Assistant] Initialization failed: {e.Message}\");\n                return false;\n            }\n        }\n\n        private async Task<bool> LoadApiKey()\n        {\n            try\n            {\n                apiKey = SatieAPIKeyManager.GetKey(SatieAPIKeyManager.Provider.OpenAI);\n\n                if (string.IsNullOrWhiteSpace(apiKey))\n                {"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "{\n            try\n            {\n                apiKey = SatieAPIKeyManager.GetKey(SatieAPIKeyManager.Provider.OpenAI);\n\n                if (string.IsNullOrWhiteSpace(apiKey))\n                {\n                    Debug.LogError(\"[AI Assistant] No OpenAI API key configured. Please use Satie > API Key Manager to set it up.\");\n                    return false;\n                }\n\n                Debug.Log($\"[AI Assistant] API key loaded successfully from centralized manager\");\n                return true;\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"[AI Assistant] Failed to load API key: {e.Message}\");\n                return false;\n            }\n        }\n\n        private async Task CreateAssistant()\n        {\n            try\n            {\n                var instructions = @\"You are a Satie code generator assistant.\nYou have access to the entire project's codebase through file search.\nGenerate valid Satie code following the project's patterns and conventions.\nOutput ONLY valid Satie code without markdown or explanations unless specifically asked.\";\n\n                var request = new AssistantRequest\n                {"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "he project's patterns and conventions.\nOutput ONLY valid Satie code without markdown or explanations unless specifically asked.\";\n\n                var request = new AssistantRequest\n                {\n                    model = model,\n                    name = assistantName,\n                    instructions = instructions,\n                    tools = new[] { new Tool { type = \"file_search\" } },\n                    tool_resources = new ToolResources\n                    {\n                        file_search = new FileSearchResource\n                        {\n                            vector_store_ids = string.IsNullOrEmpty(vectorStoreId)\n                                ? new string[0]\n                                : new[] { vectorStoreId }\n                        }\n                    }\n                };\n\n                string json = JsonUtility.ToJson(request);\n                var content = new StringContent(json, Encoding.UTF8, \"application/json\");\n\n                var response = await httpClient.PostAsync($\"{BASE_URL}/assistants\", content);\n                string responseJson = await response.Content.ReadAsStringAsync();\n\n                if (!response.IsSuccessStatusCode)"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "= await httpClient.PostAsync($\"{BASE_URL}/assistants\", content);\n                string responseJson = await response.Content.ReadAsStringAsync();\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    Debug.LogError($\"[AI Assistant] Failed to create assistant: {responseJson}\");\n                    return;\n                }\n\n                var assistantResponse = JsonUtility.FromJson<AssistantResponse>(responseJson);\n                assistantId = assistantResponse.id;\n\n                Debug.Log($\"[AI Assistant] Created assistant: {assistantId}\");\n                SaveConfiguration();\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"[AI Assistant] Failed to create assistant: {e.Message}\");\n            }\n        }\n\n        private async Task RetrieveAssistant()\n        {\n            try\n            {\n                var response = await httpClient.GetAsync($\"{BASE_URL}/assistants/{assistantId}\");\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    Debug.LogWarning($\"[AI Assistant] Assistant {assistantId} not found, creating new one\");"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "nts/{assistantId}\");\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    Debug.LogWarning($\"[AI Assistant] Assistant {assistantId} not found, creating new one\");\n                    assistantId = null;\n                    await CreateAssistant();\n                }\n                else\n                {\n                    Debug.Log($\"[AI Assistant] Retrieved existing assistant: {assistantId}\");\n                }\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"[AI Assistant] Failed to retrieve assistant: {e.Message}\");\n            }\n        }\n\n        private async Task CreateVectorStore()\n        {\n            try\n            {\n                var request = new VectorStoreRequest\n                {\n                    name = \"Satie Project Knowledge\",\n                    chunking_strategy = new FileChunkingStrategy { type = \"auto\" }\n                };\n\n                string json = JsonUtility.ToJson(request);\n                var content = new StringContent(json, Encoding.UTF8, \"application/json\");\n\n                var response = await httpClient.PostAsync($\"{BASE_URL}/vector_stores\", content);"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "n(request);\n                var content = new StringContent(json, Encoding.UTF8, \"application/json\");\n\n                var response = await httpClient.PostAsync($\"{BASE_URL}/vector_stores\", content);\n                string responseJson = await response.Content.ReadAsStringAsync();\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    Debug.LogError($\"[AI Assistant] Failed to create vector store: {responseJson}\");\n                    return;\n                }\n\n                var vectorStoreResponse = JsonUtility.FromJson<VectorStoreResponse>(responseJson);\n                vectorStoreId = vectorStoreResponse.id;\n\n                Debug.Log($\"[AI Assistant] Created vector store: {vectorStoreId}\");\n                SaveConfiguration();\n\n                // Attach vector store to assistant\n                await AttachVectorStoreToAssistant();\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"[AI Assistant] Failed to create vector store: {e.Message}\");\n            }\n        }\n\n        private async Task AttachVectorStoreToAssistant()\n        {\n            try\n            {"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "ebug.LogError($\"[AI Assistant] Failed to create vector store: {e.Message}\");\n            }\n        }\n\n        private async Task AttachVectorStoreToAssistant()\n        {\n            try\n            {\n                var request = new AssistantUpdateRequest\n                {\n                    tool_resources = new ToolResources\n                    {\n                        file_search = new FileSearchResource\n                        {\n                            vector_store_ids = new[] { vectorStoreId }\n                        }\n                    }\n                };\n\n                string json = JsonUtility.ToJson(request);\n                var content = new StringContent(json, Encoding.UTF8, \"application/json\");\n\n                var response = await httpClient.PostAsync($\"{BASE_URL}/assistants/{assistantId}\", content);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    string error = await response.Content.ReadAsStringAsync();\n                    Debug.LogError($\"[AI Assistant] Failed to attach vector store: {error}\");\n                }\n                else\n                {"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "or = await response.Content.ReadAsStringAsync();\n                    Debug.LogError($\"[AI Assistant] Failed to attach vector store: {error}\");\n                }\n                else\n                {\n                    Debug.Log($\"[AI Assistant] Attached vector store to assistant\");\n                }\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"[AI Assistant] Failed to attach vector store: {e.Message}\");\n            }\n        }\n\n        public async Task UploadProjectFiles()\n        {\n            try\n            {\n                // Find all .sat files and relevant scripts\n                string[] patterns = new[] { \"*.sat\", \"*.cs\" };\n                List<string> filesToUpload = new List<string>();\n\n                foreach (var pattern in patterns)\n                {\n                    var files = Directory.GetFiles(Application.dataPath, pattern, SearchOption.AllDirectories)\n                        .Where(f => !f.Contains(\"/Editor/\") && !f.Contains(\"/Plugins/\"))\n                        .Take(100); // Limit to avoid overwhelming the API\n\n                    filesToUpload.AddRange(files);\n                }"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "!f.Contains(\"/Editor/\") && !f.Contains(\"/Plugins/\"))\n                        .Take(100); // Limit to avoid overwhelming the API\n\n                    filesToUpload.AddRange(files);\n                }\n\n                Debug.Log($\"[AI Assistant] Found {filesToUpload.Count} files to upload\");\n\n                foreach (var filePath in filesToUpload)\n                {\n                    if (uploadedFiles.Contains(filePath))\n                        continue;\n\n                    await UploadFileToVectorStore(filePath);\n                    uploadedFiles.Add(filePath);\n\n                    // Small delay to avoid rate limiting\n                    await Task.Delay(100);\n                }\n\n                // Wait for vector store processing\n                await WaitForVectorStoreProcessing();\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"[AI Assistant] Failed to upload files: {e.Message}\");\n            }\n        }\n\n        private async Task UploadFileToVectorStore(string filePath)\n        {\n            try\n            {\n                var fileName = Path.GetFileName(filePath);"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "age}\");\n            }\n        }\n\n        private async Task UploadFileToVectorStore(string filePath)\n        {\n            try\n            {\n                var fileName = Path.GetFileName(filePath);\n                var fileBytes = await File.ReadAllBytesAsync(filePath);\n\n                using var formData = new MultipartFormDataContent();\n                formData.Add(new ByteArrayContent(fileBytes), \"file\", fileName);\n                formData.Add(new StringContent(\"assistants\"), \"purpose\");\n\n                var response = await httpClient.PostAsync($\"{BASE_URL}/files\", formData);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    string error = await response.Content.ReadAsStringAsync();\n                    Debug.LogWarning($\"[AI Assistant] Failed to upload {fileName}: {error}\");\n                    return;\n                }\n\n                string responseJson = await response.Content.ReadAsStringAsync();\n                var fileResponse = JsonUtility.FromJson<FileUploadResponse>(responseJson);\n                string fileId = fileResponse.id;\n\n                // Add file to vector store"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "StringAsync();\n                var fileResponse = JsonUtility.FromJson<FileUploadResponse>(responseJson);\n                string fileId = fileResponse.id;\n\n                // Add file to vector store\n                var attachRequestData = new FileAttachRequest { file_id = fileId };\n                var attachRequest = new StringContent(\n                    JsonUtility.ToJson(attachRequestData),\n                    Encoding.UTF8,\n                    \"application/json\"\n                );\n\n                var attachResponse = await httpClient.PostAsync(\n                    $\"{BASE_URL}/vector_stores/{vectorStoreId}/files\",\n                    attachRequest\n                );\n\n                if (attachResponse.IsSuccessStatusCode)\n                {\n                    fileIdMap[filePath] = fileId;\n                    Debug.Log($\"[AI Assistant] Uploaded {fileName} to vector store\");\n                }\n            }\n            catch (Exception e)\n            {\n                Debug.LogWarning($\"[AI Assistant] Failed to upload file {filePath}: {e.Message}\");\n            }\n        }\n\n        private async Task WaitForVectorStoreProcessing()\n        {\n            try\n            {"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "LogWarning($\"[AI Assistant] Failed to upload file {filePath}: {e.Message}\");\n            }\n        }\n\n        private async Task WaitForVectorStoreProcessing()\n        {\n            try\n            {\n                int maxAttempts = 30;\n                int attempt = 0;\n\n                while (attempt < maxAttempts)\n                {\n                    var response = await httpClient.GetAsync($\"{BASE_URL}/vector_stores/{vectorStoreId}\");\n\n                    if (response.IsSuccessStatusCode)\n                    {\n                        string json = await response.Content.ReadAsStringAsync();\n                        var vectorStore = JsonUtility.FromJson<VectorStoreResponse>(json);\n\n                        if (vectorStore.status == \"completed\" &&\n                            vectorStore.file_counts.in_progress == 0)\n                        {\n                            Debug.Log($\"[AI Assistant] Vector store ready: {vectorStore.file_counts.completed} files processed\");\n                            break;\n                        }"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "{\n                            Debug.Log($\"[AI Assistant] Vector store ready: {vectorStore.file_counts.completed} files processed\");\n                            break;\n                        }\n\n                        Debug.Log($\"[AI Assistant] Processing files: {vectorStore.file_counts.in_progress} in progress, {vectorStore.file_counts.completed} completed\");\n                    }\n\n                    await Task.Delay(2000);\n                    attempt++;\n                }\n            }\n            catch (Exception e)\n            {\n                Debug.LogWarning($\"[AI Assistant] Error checking vector store status: {e.Message}\");\n            }\n        }\n\n        public async Task<string> GenerateCode(string prompt, string currentScript = null)\n        {\n            try\n            {\n                // Create a new thread for this conversation\n                currentThreadId = await CreateThread(prompt, currentScript);\n\n                if (string.IsNullOrEmpty(currentThreadId))\n                {\n                    Debug.LogError(\"[AI Assistant] Failed to create thread\");\n                    return null;\n                }\n\n                // Run the assistant"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "rentThreadId))\n                {\n                    Debug.LogError(\"[AI Assistant] Failed to create thread\");\n                    return null;\n                }\n\n                // Run the assistant\n                string runId = await CreateRun(currentThreadId, prompt);\n\n                if (string.IsNullOrEmpty(runId))\n                {\n                    Debug.LogError(\"[AI Assistant] Failed to create run\");\n                    return null;\n                }\n\n                // Wait for completion\n                await WaitForRunCompletion(currentThreadId, runId);\n\n                // Get the response\n                string response = await GetAssistantResponse(currentThreadId);\n\n                return response;\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"[AI Assistant] Failed to generate code: {e.Message}\");\n                return null;\n            }\n        }\n\n        private async Task<string> CreateThread(string userPrompt, string currentScript)\n        {\n            try\n            {\n                var messages = new List<Message>();\n\n                if (!string.IsNullOrEmpty(currentScript))\n                {"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "rPrompt, string currentScript)\n        {\n            try\n            {\n                var messages = new List<Message>();\n\n                if (!string.IsNullOrEmpty(currentScript))\n                {\n                    messages.Add(new Message\n                    {\n                        role = \"user\",\n                        content = $\"Current script:\\n```satie\\n{currentScript}\\n```\\n\\n{userPrompt}\"\n                    });\n                }\n                else\n                {\n                    messages.Add(new Message { role = \"user\", content = userPrompt });\n                }\n\n                var request = new ThreadRequest\n                {\n                    messages = messages.ToArray(),\n                    tool_resources = new ToolResources\n                    {\n                        file_search = new FileSearchResource\n                        {\n                            vector_store_ids = new[] { vectorStoreId }\n                        }\n                    }\n                };\n\n                string json = JsonUtility.ToJson(request);\n                var content = new StringContent(json, Encoding.UTF8, \"application/json\");"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "}\n                    }\n                };\n\n                string json = JsonUtility.ToJson(request);\n                var content = new StringContent(json, Encoding.UTF8, \"application/json\");\n\n                var response = await httpClient.PostAsync($\"{BASE_URL}/threads\", content);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    string error = await response.Content.ReadAsStringAsync();\n                    Debug.LogError($\"[AI Assistant] Failed to create thread: {error}\");\n                    return null;\n                }\n\n                string responseJson = await response.Content.ReadAsStringAsync();\n                var threadResponse = JsonUtility.FromJson<ThreadResponse>(responseJson);\n\n                Debug.Log($\"[AI Assistant] Created thread: {threadResponse.id}\");\n                return threadResponse.id;\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"[AI Assistant] Failed to create thread: {e.Message}\");\n                return null;\n            }\n        }\n\n        private async Task<string> CreateRun(string threadId, string additionalInstructions = null)\n        {"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "ed to create thread: {e.Message}\");\n                return null;\n            }\n        }\n\n        private async Task<string> CreateRun(string threadId, string additionalInstructions = null)\n        {\n            try\n            {\n                var request = new RunRequest\n                {\n                    assistant_id = assistantId,\n                    instructions = additionalInstructions,\n                    tools = new[] { \"file_search\" },\n                    temperature = 0.7f,\n                    max_completion_tokens = 4000\n                };\n\n                string json = JsonUtility.ToJson(request);\n                var content = new StringContent(json, Encoding.UTF8, \"application/json\");\n\n                var response = await httpClient.PostAsync($\"{BASE_URL}/threads/{threadId}/runs\", content);\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    string error = await response.Content.ReadAsStringAsync();\n                    Debug.LogError($\"[AI Assistant] Failed to create run: {error}\");\n                    return null;\n                }\n\n                string responseJson = await response.Content.ReadAsStringAsync();"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "Debug.LogError($\"[AI Assistant] Failed to create run: {error}\");\n                    return null;\n                }\n\n                string responseJson = await response.Content.ReadAsStringAsync();\n                var runResponse = JsonUtility.FromJson<RunResponse>(responseJson);\n\n                Debug.Log($\"[AI Assistant] Created run: {runResponse.id}\");\n                return runResponse.id;\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"[AI Assistant] Failed to create run: {e.Message}\");\n                return null;\n            }\n        }\n\n        private async Task WaitForRunCompletion(string threadId, string runId)\n        {\n            try\n            {\n                int maxAttempts = 60;\n                int attempt = 0;\n\n                while (attempt < maxAttempts)\n                {\n                    var response = await httpClient.GetAsync($\"{BASE_URL}/threads/{threadId}/runs/{runId}\");\n\n                    if (response.IsSuccessStatusCode)\n                    {\n                        string json = await response.Content.ReadAsStringAsync();"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "_URL}/threads/{threadId}/runs/{runId}\");\n\n                    if (response.IsSuccessStatusCode)\n                    {\n                        string json = await response.Content.ReadAsStringAsync();\n                        var runResponse = JsonUtility.FromJson<RunResponse>(json);\n\n                        Debug.Log($\"[AI Assistant] Run status: {runResponse.status}\");\n\n                        if (runResponse.status == \"completed\")\n                        {\n                            Debug.Log($\"[AI Assistant] Run completed. Tokens used: {runResponse.usage?.total_tokens ?? 0}\");\n                            return;\n                        }\n                        else if (runResponse.status == \"failed\" || runResponse.status == \"cancelled\" || runResponse.status == \"expired\")\n                        {\n                            Debug.LogError($\"[AI Assistant] Run failed with status: {runResponse.status}\");\n                            return;\n                        }\n                    }\n\n                    await Task.Delay(1000);\n                    attempt++;\n                }\n\n                Debug.LogError(\"[AI Assistant] Run timed out\");\n            }"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "}\n                    }\n\n                    await Task.Delay(1000);\n                    attempt++;\n                }\n\n                Debug.LogError(\"[AI Assistant] Run timed out\");\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"[AI Assistant] Error waiting for run completion: {e.Message}\");\n            }\n        }\n\n        private async Task<string> GetAssistantResponse(string threadId)\n        {\n            try\n            {\n                var response = await httpClient.GetAsync($\"{BASE_URL}/threads/{threadId}/messages\");\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    string error = await response.Content.ReadAsStringAsync();\n                    Debug.LogError($\"[AI Assistant] Failed to get messages: {error}\");\n                    return null;\n                }\n\n                string json = await response.Content.ReadAsStringAsync();\n                var messages = JsonUtility.FromJson<MessageListResponse>(json);\n\n                // Find the latest assistant message\n                var assistantMessage = messages.data\n                    .Where(m => m.role == \"assistant\")"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": ".FromJson<MessageListResponse>(json);\n\n                // Find the latest assistant message\n                var assistantMessage = messages.data\n                    .Where(m => m.role == \"assistant\")\n                    .OrderByDescending(m => m.created_at)\n                    .FirstOrDefault();\n\n                if (assistantMessage?.content?.Length > 0 &&\n                    assistantMessage.content[0].type == \"text\")\n                {\n                    return assistantMessage.content[0].text.value;\n                }\n\n                return null;\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"[AI Assistant] Failed to get response: {e.Message}\");\n                return null;\n            }\n        }\n\n        private void SaveConfiguration()\n        {\n            // Save assistant and vector store IDs to PlayerPrefs or a config file\n            PlayerPrefs.SetString(\"SatieAI_AssistantId\", assistantId);\n            PlayerPrefs.SetString(\"SatieAI_VectorStoreId\", vectorStoreId);\n            PlayerPrefs.Save();\n        }\n\n        private void LoadConfiguration()\n        {"
    },
    {
      "Source": "Assets/Scripts/SatieAIAssistant.cs",
      "Content": "AI_AssistantId\", assistantId);\n            PlayerPrefs.SetString(\"SatieAI_VectorStoreId\", vectorStoreId);\n            PlayerPrefs.Save();\n        }\n\n        private void LoadConfiguration()\n        {\n            assistantId = PlayerPrefs.GetString(\"SatieAI_AssistantId\", \"\");\n            vectorStoreId = PlayerPrefs.GetString(\"SatieAI_VectorStoreId\", \"\");\n        }\n\n        public string GetAssistantId() => assistantId;\n        public string GetVectorStoreId() => vectorStoreId;\n\n        private void OnApplicationQuit()\n        {\n            httpClient?.Dispose();\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Text;\n// Unity uses its built-in JsonUtility instead of System.Text.Json\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing UnityEngine;\n\nnamespace Satie\n{\n    [System.Serializable]\n    public class SatieAIConfig\n    {\n        [Header(\"Authentication\")]\n        public string apiKeyPath = \"api_key.txt\";\n        public bool sendAuthorizationHeader = true;\n        public string authorizationHeaderName = \"Authorization\";\n        [TextArea(1, 3)]\n        public string authorizationHeaderValueTemplate = \"Bearer {API_KEY}\";\n\n        [Header(\"Endpoint\")] \n        public string apiBaseUrl = \"https://api.openai.com\";\n        public string chatCompletionsPath = \"/v1/chat/completions\";\n        public string providerId = \"openai\";\n\n        [Header(\"Model\")] \n        public string model = \"gpt-5\"; // Options: gpt-5, gpt-4-turbo-preview, gpt-4, gpt-3.5-turbo\n        public float temperature = 1.0f;\n        public int maxTokens = 4000;\n\n        [Header(\"Custom Headers\")]"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "string model = \"gpt-5\"; // Options: gpt-5, gpt-4-turbo-preview, gpt-4, gpt-3.5-turbo\n        public float temperature = 1.0f;\n        public int maxTokens = 4000;\n\n        [Header(\"Custom Headers\")]\n        public List<SatieAIRequestHeader> additionalHeaders = new List<SatieAIRequestHeader>();\n\n        [Header(\"RLHF Settings\")]\n        public bool enableRLHF = true;\n        public string rlhfDataPath = \"rlhf_feedback.json\";\n    }\n\n    [System.Serializable]\n    public class SatieAIRequestHeader\n    {\n        public string name;\n        [TextArea(1, 3)]\n        public string value;\n    }\n\n    [System.Serializable]\n    public class RLHFFeedback\n    {\n        public string prompt;\n        public string generatedCode;\n        public bool wasCorrect;\n        public string timestamp;\n        public string feedbackNotes;\n    }\n    \n    [System.Serializable]\n    public class RLHFFeedbackWrapper\n    {\n        public RLHFFeedback[] items;\n    }\n\n    [System.Serializable]\n    public class ConversationMessage\n    {\n        public string role; // \"user\" or \"assistant\"\n        public string content;\n        public string timestamp;\n    }\n\n    [System.Serializable]"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "zable]\n    public class ConversationMessage\n    {\n        public string role; // \"user\" or \"assistant\"\n        public string content;\n        public string timestamp;\n    }\n\n    [System.Serializable]\n    public class ConversationHistory\n    {\n        public ConversationMessage[] messages;\n        public string currentScript;\n    }\n\n    public class SatieAICodeGen : MonoBehaviour\n    {\n        private static SatieAICodeGen instance;\n        public static SatieAICodeGen Instance\n        {\n            get\n            {\n                if (instance == null)\n                {\n                    var go = new GameObject(\"SatieAICodeGen\");\n                    instance = go.AddComponent<SatieAICodeGen>();\n                    DontDestroyOnLoad(go);\n                }\n                return instance;\n            }\n        }\n\n        [SerializeField] public SatieAIConfig config = new SatieAIConfig();\n        private string apiKey;\n        private HttpClient httpClient;\n        private string cachedResourcePrompt;\n        private AudioResourceSnapshot cachedResourceSnapshot;\n        private readonly object resourceCacheLock = new object();\n        private float lastResourceScanTime = -1f;"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "cachedResourcePrompt;\n        private AudioResourceSnapshot cachedResourceSnapshot;\n        private readonly object resourceCacheLock = new object();\n        private float lastResourceScanTime = -1f;\n        private const float RESOURCE_CACHE_DURATION = 30f; // 30 seconds for faster updates after generation\n        private string lastKnownScriptSnapshot = string.Empty;\n\n#if !UNITY_WEBGL\n        private FileSystemWatcher audioWatcher;\n        private volatile bool pendingAudioCacheInvalidation;\n        private readonly List<FileSystemWatcher> knowledgeWatchers = new List<FileSystemWatcher>();\n        private volatile bool pendingKnowledgeCacheInvalidation;\n#endif\n\n        // Unity's JsonUtility is used for JSON serialization\n\n        private static readonly Regex KnowledgeTokenRegex = new Regex(\"[A-Za-z0-9_]+\", RegexOptions.Compiled);\n\n        private const int MAX_SCRIPT_CONTEXT_CHARS = 6000;\n        private const int MAX_SUMMARY_LINES = 12;\n        private const int MAX_CONVERSATION_MESSAGES = 6;\n        private const int MAX_CONVERSATION_MESSAGE_CHARS = 1200;\n\n        private const string KNOWLEDGE_INDEX_DIRECTORY_NAME = \"AIIndex\";"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "12;\n        private const int MAX_CONVERSATION_MESSAGES = 6;\n        private const int MAX_CONVERSATION_MESSAGE_CHARS = 1200;\n\n        private const string KNOWLEDGE_INDEX_DIRECTORY_NAME = \"AIIndex\";\n        private const string KNOWLEDGE_INDEX_FILE_NAME = \"knowledge_index.json\";\n        private const int KNOWLEDGE_MAX_SNIPPETS = 4;\n        private const int KNOWLEDGE_SNIPPET_MAX_CHARS = 800;\n        private const int KNOWLEDGE_CHUNK_SIZE = 1200;\n        private const int KNOWLEDGE_CHUNK_OVERLAP = 200;\n        private const int KNOWLEDGE_QUERY_SCRIPT_CHARS = 1500;\n\n        // Conversation context for follow-up editing\n        private ConversationHistory currentConversation;\n        private bool isEditMode = false;\n\n        private const string SYSTEM_PROMPT_BASE = \"Output ONLY valid Satie code. No markdown or explanations.\\n\\n\" +\n            \"SYNTAX RULES:\\n\" +\n            \"- ALWAYS add colon: loop \\\"clip\\\": or oneshot \\\"clip\\\":\\n\" +\n            \"- Birds/footsteps/bicycles: oneshot with \\\"every\\\"\\n\" +\n            \"- Ambience/music: loop\\n\" +\n            \"- Move: walk,x,z,speed OR fly,x,y,z,speed OR pos,x,y,z\\n\" +"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "t \\\"clip\\\":\\n\" +\n            \"- Birds/footsteps/bicycles: oneshot with \\\"every\\\"\\n\" +\n            \"- Ambience/music: loop\\n\" +\n            \"- Move: walk,x,z,speed OR fly,x,y,z,speed OR pos,x,y,z\\n\" +\n            \"- Visual: sphere OR trail OR \\\"sphere and trail\\\" (NOT true/false)\\n\" +\n            \"- NO 'overlap' with multiplied oneshots\\n\\n\";\n\n        private string projectRootPath;\n        private string knowledgeIndexDirectory;\n        private string knowledgeIndexFilePath;\n        private RagIndexCache cachedKnowledgeIndex;\n        private Task<RagIndexCache> knowledgeIndexBuildTask;\n        private readonly object knowledgeIndexLock = new object();\n        private bool knowledgeIndexDirty = true;\n\n        private sealed class AudioResourceSnapshot\n        {\n            public readonly List<AudioCategorySummary> Categories = new List<AudioCategorySummary>();\n\n            public int TotalSamples\n            {\n                get\n                {\n                    int total = 0;\n                    foreach (var category in Categories)\n                    {\n                        total += category.TotalSampleCount;\n                    }\n                    return total;"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "= 0;\n                    foreach (var category in Categories)\n                    {\n                        total += category.TotalSampleCount;\n                    }\n                    return total;\n                }\n            }\n\n            public string ToPromptString()\n            {\n                var builder = new StringBuilder();\n                builder.AppendLine(\"AUDIO LIBRARY SNAPSHOT:\");\n\n                if (Categories.Count == 0)\n                {\n                    builder.AppendLine(\"  (no audio files found)\");\n                    return builder.ToString();\n                }\n\n                foreach (var category in Categories\n                    .OrderByDescending(c => c.TotalSampleCount)\n                    .ThenBy(c => c.Name, StringComparer.OrdinalIgnoreCase))\n                {\n                    builder.Append(\"- \");\n                    builder.Append(category.Name);\n                    builder.Append(\" (\");\n                    builder.Append(category.TotalSampleCount);\n                    builder.Append(category.TotalSampleCount == 1 ? \" sample\" : \" samples\");\n\n                    if (!string.IsNullOrEmpty(category.SuggestedUsage))\n                    {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "mpleCount);\n                    builder.Append(category.TotalSampleCount == 1 ? \" sample\" : \" samples\");\n\n                    if (!string.IsNullOrEmpty(category.SuggestedUsage))\n                    {\n                        builder.Append(\", suggest \");\n                        builder.Append(category.SuggestedUsage);\n                    }\n\n                    builder.AppendLine(\")\");\n\n                    if (category.SequentialRanges.Count > 0)\n                    {\n                        builder.Append(\"    sequential: \");\n                        builder.AppendLine(string.Join(\", \", category.SequentialRanges.Select(r =>\n                            FormatSampleRange(category.Name, r))));\n                    }\n\n                    if (category.NamedSamples.Count > 0)\n                    {\n                        var trimmed = category.NamedSamples\n                            .Distinct()\n                            .OrderBy(n => n, StringComparer.OrdinalIgnoreCase)\n                            .Take(8)\n                            .Select(n => $\"{category.Name}/{n}\");\n                        builder.Append(\"    named: \");"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "n => n, StringComparer.OrdinalIgnoreCase)\n                            .Take(8)\n                            .Select(n => $\"{category.Name}/{n}\");\n                        builder.Append(\"    named: \");\n                        builder.AppendLine(string.Join(\", \", trimmed));\n\n                        if (category.NamedSamples.Count > 8)\n                        {\n                            builder.AppendLine($\"    ... (+{category.NamedSamples.Count - 8} more)\");\n                        }\n                    }\n                }\n\n                builder.AppendLine(\"Use folder/sample notation e.g., oneshot \\\"birds/1-4\\\" or loop \\\"ambience/forest\\\".\");\n                return builder.ToString();\n            }\n        }\n\n        private sealed class AudioCategorySummary\n        {\n            public string Name { get; }\n            public List<AudioRange> SequentialRanges { get; } = new List<AudioRange>();\n            public List<string> NamedSamples { get; } = new List<string>();\n            public string SuggestedUsage { get; set; }\n            public int TotalSampleCount => SequentialRanges.Sum(r => r.Length) + NamedSamples.Count;\n\n            public AudioCategorySummary(string name)"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "public string SuggestedUsage { get; set; }\n            public int TotalSampleCount => SequentialRanges.Sum(r => r.Length) + NamedSamples.Count;\n\n            public AudioCategorySummary(string name)\n            {\n                Name = name;\n            }\n        }\n\n        private readonly struct AudioRange\n        {\n            public int Start { get; }\n            public int End { get; }\n            public int Length => End - Start + 1;\n\n            public AudioRange(int start, int end)\n            {\n                Start = start;\n                End = end;\n            }\n        }\n\n        private sealed class KnowledgeSourceFile\n        {\n            public string FullPath { get; set; }\n            public string RelativePath { get; set; }\n            public long LastWriteTicks { get; set; }\n        }\n\n        [System.Serializable]\n        private sealed class RagChunkRecord\n        {\n            public string Source;\n            public string Content;\n            public Dictionary<string, float> TermWeights;\n        }\n\n        [System.Serializable]\n        private sealed class RagIndexCache\n        {\n            public List<RagChunkRecord> Chunks = new List<RagChunkRecord>();"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "<string, float> TermWeights;\n        }\n\n        [System.Serializable]\n        private sealed class RagIndexCache\n        {\n            public List<RagChunkRecord> Chunks = new List<RagChunkRecord>();\n            public Dictionary<string, long> SourceFileVersions = new Dictionary<string, long>();\n        }\n\n        [System.Serializable]\n        private sealed class ChatCompletionMessage\n        {\n            public string role;\n            public string content;\n\n            public ChatCompletionMessage() { }\n\n            public ChatCompletionMessage(string roleValue, string contentValue)\n            {\n                role = roleValue;\n                content = contentValue;\n            }\n        }\n\n        [System.Serializable]\n        private sealed class ChatCompletionResponse\n        {\n            public ChatCompletionChoice[] choices;\n        }\n\n        [System.Serializable]\n        private sealed class ChatCompletionChoice\n        {\n            public ChatCompletionResponseMessage message;\n            public string finish_reason;\n        }\n\n        [System.Serializable]\n        private sealed class ChatCompletionResponseMessage\n        {\n            public string role;"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "Message message;\n            public string finish_reason;\n        }\n\n        [System.Serializable]\n        private sealed class ChatCompletionResponseMessage\n        {\n            public string role;\n            public string content;\n        }\n\n        [System.Serializable]\n        private sealed class OpenAIRequestPayload\n        {\n            public string model;\n            public ChatCompletionMessage[] messages;\n            public float temperature;\n            public int max_completion_tokens;\n        }\n\n        [System.Serializable]\n        private sealed class ChatCompletionRequestData\n        {\n            public string Model;\n            public List<ChatCompletionMessage> Messages;\n            public float Temperature;\n            public int MaxTokens;\n        }\n\n        [System.Serializable]\n        private sealed class ChatCompletionResult\n        {\n            public string Content;\n            public string FinishReason;\n        }\n\n        private interface IChatCompletionProviderAdapter\n        {\n            string Id { get; }\n            HttpRequestMessage CreateRequest(SatieAIConfig config, ChatCompletionRequestData request);"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "private interface IChatCompletionProviderAdapter\n        {\n            string Id { get; }\n            HttpRequestMessage CreateRequest(SatieAIConfig config, ChatCompletionRequestData request);\n            ChatCompletionResult ParseResponse(string responseJson);\n        }\n\n        private sealed class OpenAIChatCompletionAdapter : IChatCompletionProviderAdapter\n        {\n            public string Id => \"openai\";\n\n            public HttpRequestMessage CreateRequest(SatieAIConfig config, ChatCompletionRequestData request)\n            {\n                if (config == null) throw new ArgumentNullException(nameof(config));\n                if (request == null) throw new ArgumentNullException(nameof(request));\n\n                var payload = new OpenAIRequestPayload\n                {\n                    model = request.Model,\n                    messages = request.Messages?.ToArray() ?? new ChatCompletionMessage[0],\n                    temperature = request.Temperature,\n                    max_completion_tokens = request.MaxTokens\n                };\n\n                string json = JsonUtility.ToJson(payload);\n                Debug.Log($\"[AI Debug] Request JSON: {json}\");"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "max_completion_tokens = request.MaxTokens\n                };\n\n                string json = JsonUtility.ToJson(payload);\n                Debug.Log($\"[AI Debug] Request JSON: {json}\");\n                var httpRequest = new HttpRequestMessage(HttpMethod.Post, ResolveEndpoint(config));\n                httpRequest.Content = new StringContent(json, Encoding.UTF8, \"application/json\");\n                return httpRequest;\n            }\n\n            public ChatCompletionResult ParseResponse(string responseJson)\n            {\n                var parsed = JsonUtility.FromJson<ChatCompletionResponse>(responseJson);\n                var choice = parsed?.choices?.FirstOrDefault();\n\n                return new ChatCompletionResult\n                {\n                    Content = choice?.message?.content,\n                    FinishReason = choice?.finish_reason\n                };\n            }\n\n            private static Uri ResolveEndpoint(SatieAIConfig config)\n            {\n                string baseUrl = string.IsNullOrWhiteSpace(config.apiBaseUrl)\n                    ? \"https://api.openai.com\"\n                    : config.apiBaseUrl;"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "tieAIConfig config)\n            {\n                string baseUrl = string.IsNullOrWhiteSpace(config.apiBaseUrl)\n                    ? \"https://api.openai.com\"\n                    : config.apiBaseUrl;\n                string path = string.IsNullOrWhiteSpace(config.chatCompletionsPath)\n                    ? \"/v1/chat/completions\"\n                    : config.chatCompletionsPath;\n\n                Debug.Log($\"[AI Debug] ResolveEndpoint - BaseUrl: '{baseUrl}', Path: '{path}'\");\n\n                // Only accept absolute URIs that start with http or https\n                if (Uri.TryCreate(path, UriKind.Absolute, out var absolute)\n                    && (absolute.Scheme == \"http\" || absolute.Scheme == \"https\"))\n                {\n                    Debug.Log($\"[AI Debug] Using absolute path URL: {absolute}\");\n                    return absolute;\n                }\n\n                // Ensure baseUrl is a valid absolute URI\n                if (!Uri.TryCreate(baseUrl, UriKind.Absolute, out var baseUri)\n                    || (baseUri.Scheme != \"http\" && baseUri.Scheme != \"https\"))\n                {\n                    Debug.LogWarning($\"[AI Debug] Invalid base URL '{baseUrl}', using default\");"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "Uri)\n                    || (baseUri.Scheme != \"http\" && baseUri.Scheme != \"https\"))\n                {\n                    Debug.LogWarning($\"[AI Debug] Invalid base URL '{baseUrl}', using default\");\n                    baseUri = new Uri(\"https://api.openai.com/\");\n                }\n\n                // Combine base and path\n                if (Uri.TryCreate(baseUri, path, out var combined))\n                {\n                    Debug.Log($\"[AI Debug] Combined URL: {combined}\");\n                    return combined;\n                }\n\n                // Fallback: sanitize path and combine\n                string sanitized = path.TrimStart('/');\n                var result = new Uri(baseUri, sanitized);\n                Debug.Log($\"[AI Debug] Fallback URL: {result}\");\n                return result;\n            }\n        }\n\n        private static readonly OpenAIChatCompletionAdapter OpenAIProvider = new OpenAIChatCompletionAdapter();\n        private static readonly Dictionary<string, IChatCompletionProviderAdapter> ProviderAdapters =\n            new Dictionary<string, IChatCompletionProviderAdapter>(StringComparer.OrdinalIgnoreCase)\n            {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "tatic readonly Dictionary<string, IChatCompletionProviderAdapter> ProviderAdapters =\n            new Dictionary<string, IChatCompletionProviderAdapter>(StringComparer.OrdinalIgnoreCase)\n            {\n                { \"openai\", OpenAIProvider },\n                { \"openai-compatible\", OpenAIProvider }\n            };\n\n        private IChatCompletionProviderAdapter ResolveProviderAdapter()\n        {\n            string providerId = config?.providerId;\n            if (!string.IsNullOrWhiteSpace(providerId) &&\n                ProviderAdapters.TryGetValue(providerId, out var adapter))\n            {\n                return adapter;\n            }\n\n            if (!string.IsNullOrWhiteSpace(providerId))\n            {\n                Debug.LogWarning($\"[AI] Unknown provider '{providerId}', defaulting to OpenAI-compatible adapter.\");\n            }\n\n            return OpenAIProvider;\n        }\n\n        void Awake()\n        {\n            if (instance != null && instance != this)\n            {\n                Destroy(gameObject);\n                return;\n            }\n            instance = this;\n            DontDestroyOnLoad(gameObject);\n\n            // Configure HttpClient for performance"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "Destroy(gameObject);\n                return;\n            }\n            instance = this;\n            DontDestroyOnLoad(gameObject);\n\n            // Configure HttpClient for performance\n            httpClient = new HttpClient();\n            httpClient.Timeout = TimeSpan.FromSeconds(120); // Increased for AI requests\n            httpClient.DefaultRequestHeaders.Add(\"User-Agent\", \"SatieLang/1.0\");\n            httpClient.DefaultRequestHeaders.Add(\"Connection\", \"keep-alive\");\n            \n            // Pre-cache resource info\n            _ = RefreshResourceCache();\n\n#if !UNITY_WEBGL\n            InitializeAudioWatcher();\n#endif\n\n            projectRootPath = Path.GetFullPath(Path.Combine(Application.dataPath, \"..\"));\n            knowledgeIndexDirectory = Path.Combine(Application.dataPath, KNOWLEDGE_INDEX_DIRECTORY_NAME);\n            knowledgeIndexFilePath = Path.Combine(knowledgeIndexDirectory, KNOWLEDGE_INDEX_FILE_NAME);\n\n#if !UNITY_WEBGL\n            InitializeKnowledgeWatchers();\n#endif\n\n            _ = GetKnowledgeIndexAsync();\n        }\n\n        // Force re-indexing when called (e.g., after audio generation)\n        public void InvalidateAudioCache()\n        {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "geWatchers();\n#endif\n\n            _ = GetKnowledgeIndexAsync();\n        }\n\n        // Force re-indexing when called (e.g., after audio generation)\n        public void InvalidateAudioCache()\n        {\n            lastResourceScanTime = -1f;\n            cachedResourcePrompt = null;\n            Debug.Log(\"[AI] Audio cache invalidated - will re-index on next generation\");\n        }\n\n#if !UNITY_WEBGL\n        private void InitializeAudioWatcher()\n        {\n            try\n            {\n                string audioRoot = Path.Combine(Application.dataPath, \"Resources\", \"Audio\");\n                if (!Directory.Exists(audioRoot))\n                {\n                    return;\n                }\n\n                audioWatcher = new FileSystemWatcher(audioRoot)\n                {\n                    IncludeSubdirectories = true,\n                    EnableRaisingEvents = true,\n                    NotifyFilter = NotifyFilters.FileName |\n                                   NotifyFilters.DirectoryName |\n                                   NotifyFilters.LastWrite\n                };\n\n                audioWatcher.Changed += OnAudioLibraryChanged;"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "NotifyFilters.DirectoryName |\n                                   NotifyFilters.LastWrite\n                };\n\n                audioWatcher.Changed += OnAudioLibraryChanged;\n                audioWatcher.Created += OnAudioLibraryChanged;\n                audioWatcher.Deleted += OnAudioLibraryChanged;\n                audioWatcher.Renamed += OnAudioLibraryRenamed;\n            }\n            catch (Exception e)\n            {\n                Debug.LogWarning($\"[AI Cache] Failed to watch audio library: {e.Message}\");\n            }\n        }\n\n        private void OnAudioLibraryChanged(object sender, FileSystemEventArgs e)\n        {\n            pendingAudioCacheInvalidation = true;\n        }\n\n        private void OnAudioLibraryRenamed(object sender, RenamedEventArgs e)\n        {\n            pendingAudioCacheInvalidation = true;\n        }\n\n        private void InitializeKnowledgeWatchers()\n        {\n            try\n            {\n                foreach (var target in EnumerateKnowledgeWatchTargets())\n                {\n                    string path = target.path;\n                    if (string.IsNullOrEmpty(path) || !Directory.Exists(path))\n                    {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "EnumerateKnowledgeWatchTargets())\n                {\n                    string path = target.path;\n                    if (string.IsNullOrEmpty(path) || !Directory.Exists(path))\n                    {\n                        continue;\n                    }\n\n                    var watcher = new FileSystemWatcher(path)\n                    {\n                        IncludeSubdirectories = target.includeSubdirectories,\n                        NotifyFilter = NotifyFilters.FileName |\n                                       NotifyFilters.LastWrite |\n                                       NotifyFilters.Size |\n                                       NotifyFilters.DirectoryName\n                    };\n\n                    watcher.Changed += OnKnowledgeSourceChanged;\n                    watcher.Created += OnKnowledgeSourceChanged;\n                    watcher.Deleted += OnKnowledgeSourceChanged;\n                    watcher.Renamed += OnKnowledgeSourceRenamed;\n                    watcher.EnableRaisingEvents = true;\n                    knowledgeWatchers.Add(watcher);\n                }\n            }\n            catch (Exception e)\n            {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "ourceRenamed;\n                    watcher.EnableRaisingEvents = true;\n                    knowledgeWatchers.Add(watcher);\n                }\n            }\n            catch (Exception e)\n            {\n                Debug.LogWarning($\"[AI Knowledge] Failed to initialize watchers: {e.Message}\");\n            }\n        }\n\n        private void DisposeKnowledgeWatchers()\n        {\n            foreach (var watcher in knowledgeWatchers)\n            {\n                try\n                {\n                    watcher.EnableRaisingEvents = false;\n                    watcher.Changed -= OnKnowledgeSourceChanged;\n                    watcher.Created -= OnKnowledgeSourceChanged;\n                    watcher.Deleted -= OnKnowledgeSourceChanged;\n                    watcher.Renamed -= OnKnowledgeSourceRenamed;\n                    watcher.Dispose();\n                }\n                catch (Exception e)\n                {\n                    Debug.LogWarning($\"[AI Knowledge] Failed to dispose watcher: {e.Message}\");\n                }\n            }\n\n            knowledgeWatchers.Clear();\n        }\n\n        private void OnKnowledgeSourceChanged(object sender, FileSystemEventArgs e)\n        {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "atcher: {e.Message}\");\n                }\n            }\n\n            knowledgeWatchers.Clear();\n        }\n\n        private void OnKnowledgeSourceChanged(object sender, FileSystemEventArgs e)\n        {\n            if (IsPotentialKnowledgePath(e.FullPath))\n            {\n                pendingKnowledgeCacheInvalidation = true;\n            }\n        }\n\n        private void OnKnowledgeSourceRenamed(object sender, RenamedEventArgs e)\n        {\n            if (Directory.Exists(e.FullPath) || Directory.Exists(e.OldFullPath) ||\n                IsPotentialKnowledgePath(e.FullPath) || IsPotentialKnowledgePath(e.OldFullPath))\n            {\n                pendingKnowledgeCacheInvalidation = true;\n            }\n        }\n\n        private bool IsPotentialKnowledgePath(string fullPath)\n        {\n            if (string.IsNullOrEmpty(fullPath))\n            {\n                return false;\n            }\n\n            try\n            {\n                if (Directory.Exists(fullPath))\n                {\n                    return false;\n                }\n\n                if (!IsSupportedKnowledgeFile(fullPath))\n                {\n                    return false;\n                }"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "{\n                    return false;\n                }\n\n                if (!IsSupportedKnowledgeFile(fullPath))\n                {\n                    return false;\n                }\n\n                if (!string.IsNullOrEmpty(knowledgeIndexFilePath))\n                {\n                    string normalizedIndex = Path.GetFullPath(knowledgeIndexFilePath);\n                    string normalizedPath = Path.GetFullPath(fullPath);\n                    if (string.Equals(normalizedIndex, normalizedPath, StringComparison.OrdinalIgnoreCase))\n                    {\n                        return false;\n                    }\n                }\n\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        private IEnumerable<(string path, bool includeSubdirectories)> EnumerateKnowledgeWatchTargets()\n        {\n            var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n\n            if (!string.IsNullOrEmpty(Application.dataPath) && Directory.Exists(Application.dataPath))\n            {\n                string normalized = Path.GetFullPath(Application.dataPath);"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "ase);\n\n            if (!string.IsNullOrEmpty(Application.dataPath) && Directory.Exists(Application.dataPath))\n            {\n                string normalized = Path.GetFullPath(Application.dataPath);\n                if (seen.Add(normalized))\n                {\n                    yield return (Application.dataPath, true);\n                }\n            }\n\n            if (!string.IsNullOrEmpty(projectRootPath) && Directory.Exists(projectRootPath))\n            {\n                string rootNormalized = Path.GetFullPath(projectRootPath);\n                if (seen.Add(rootNormalized))\n                {\n                    yield return (projectRootPath, false);\n                }\n\n                string[] optional =\n                {\n                    \"Docs\",\n                    \"docs\",\n                    \"Documentation\",\n                    \"documentation\",\n                    \"Samples\",\n                    \"Guides\",\n                    \"SatieSyntaxVSCode\"\n                };\n\n                foreach (var folder in optional)\n                {\n                    string candidate = Path.Combine(projectRootPath, folder);\n                    if (!Directory.Exists(candidate))"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "foreach (var folder in optional)\n                {\n                    string candidate = Path.Combine(projectRootPath, folder);\n                    if (!Directory.Exists(candidate))\n                    {\n                        continue;\n                    }\n\n                    string normalized = Path.GetFullPath(candidate);\n                    if (seen.Add(normalized))\n                    {\n                        yield return (candidate, true);\n                    }\n                }\n            }\n        }\n#endif\n\n        void Update()\n        {\n#if !UNITY_WEBGL\n            if (pendingAudioCacheInvalidation)\n            {\n                pendingAudioCacheInvalidation = false;\n                InvalidateResourceCache();\n            }\n\n            if (pendingKnowledgeCacheInvalidation)\n            {\n                pendingKnowledgeCacheInvalidation = false;\n                InvalidateKnowledgeIndex();\n                _ = GetKnowledgeIndexAsync();\n            }\n#endif\n        }\n\n        private void OnDestroy()\n        {\n            httpClient?.Dispose();\n#if !UNITY_WEBGL\n            if (audioWatcher != null)\n            {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "owledgeIndexAsync();\n            }\n#endif\n        }\n\n        private void OnDestroy()\n        {\n            httpClient?.Dispose();\n#if !UNITY_WEBGL\n            if (audioWatcher != null)\n            {\n                audioWatcher.EnableRaisingEvents = false;\n                audioWatcher.Changed -= OnAudioLibraryChanged;\n                audioWatcher.Created -= OnAudioLibraryChanged;\n                audioWatcher.Deleted -= OnAudioLibraryChanged;\n                audioWatcher.Renamed -= OnAudioLibraryRenamed;\n                audioWatcher.Dispose();\n                audioWatcher = null;\n            }\n\n            DisposeKnowledgeWatchers();\n#endif\n\n            if (instance == this)\n            {\n                instance = null;\n            }\n        }\n\n        private async Task<string> GetDynamicAudioLibrary()\n        {\n            // Check if we need to rescan (cache expired or not cached)\n            if (Time.time - lastResourceScanTime > RESOURCE_CACHE_DURATION || string.IsNullOrEmpty(cachedResourcePrompt))\n            {\n                cachedResourcePrompt = await ScanAudioResources();\n                lastResourceScanTime = Time.time;"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "SOURCE_CACHE_DURATION || string.IsNullOrEmpty(cachedResourcePrompt))\n            {\n                cachedResourcePrompt = await ScanAudioResources();\n                lastResourceScanTime = Time.time;\n                Debug.Log($\"[AI] Re-indexed audio library\");\n            }\n            return cachedResourcePrompt;\n        }\n\n        private async Task<string> ScanAudioResources()\n        {\n            return await Task.Run(() =>\n            {\n                var snapshot = BuildAudioResourceSnapshot();\n                lock (resourceCacheLock)\n                {\n                    cachedResourceSnapshot = snapshot;\n                }\n\n                return snapshot.ToPromptString();\n            });\n        }\n\n        private AudioResourceSnapshot BuildAudioResourceSnapshot()\n        {\n            var snapshot = new AudioResourceSnapshot();\n            string audioPath = Path.Combine(Application.dataPath, \"Resources\", \"Audio\");\n\n            if (!Directory.Exists(audioPath))\n            {\n                return snapshot;\n            }\n\n            var directories = Directory.GetDirectories(audioPath);\n            foreach (var directory in directories)\n            {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "ath))\n            {\n                return snapshot;\n            }\n\n            var directories = Directory.GetDirectories(audioPath);\n            foreach (var directory in directories)\n            {\n                string categoryName = Path.GetFileName(directory);\n                if (string.IsNullOrEmpty(categoryName))\n                {\n                    continue;\n                }\n\n                var summary = new AudioCategorySummary(categoryName);\n                PopulateCategorySummary(directory, summary);\n\n                if (summary.TotalSampleCount > 0)\n                {\n                    summary.SuggestedUsage = InferUsageFromName(categoryName);\n                    snapshot.Categories.Add(summary);\n                }\n            }\n\n            return snapshot;\n        }\n\n        private void PopulateCategorySummary(string directory, AudioCategorySummary summary)\n        {\n            var files = Directory.GetFiles(directory, \"*.*\", SearchOption.AllDirectories)\n                .Where(HasSupportedAudioExtension)\n                .ToList();\n\n            if (files.Count == 0)\n            {\n                return;\n            }"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": ".*\", SearchOption.AllDirectories)\n                .Where(HasSupportedAudioExtension)\n                .ToList();\n\n            if (files.Count == 0)\n            {\n                return;\n            }\n\n            var numericIds = new List<int>();\n\n            foreach (var file in files)\n            {\n                string relative = Path.GetRelativePath(directory, file);\n                if (string.IsNullOrEmpty(relative))\n                {\n                    continue;\n                }\n\n                relative = relative.Replace('\\\\', '/');\n                string nameWithoutExtension = Path.GetFileNameWithoutExtension(relative);\n\n                if (!relative.Contains('/') && int.TryParse(nameWithoutExtension, out int number))\n                {\n                    numericIds.Add(number);\n                }\n                else\n                {\n                    summary.NamedSamples.Add(RemoveAudioExtension(relative));\n                }\n            }\n\n            numericIds.Sort();\n            foreach (var range in CollapseToRanges(numericIds))\n            {\n                summary.SequentialRanges.Add(range);\n            }\n        }"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "}\n\n            numericIds.Sort();\n            foreach (var range in CollapseToRanges(numericIds))\n            {\n                summary.SequentialRanges.Add(range);\n            }\n        }\n\n        private static IEnumerable<AudioRange> CollapseToRanges(List<int> sortedNumbers)\n        {\n            if (sortedNumbers == null || sortedNumbers.Count == 0)\n            {\n                yield break;\n            }\n\n            int start = sortedNumbers[0];\n            int previous = start;\n\n            for (int i = 1; i < sortedNumbers.Count; i++)\n            {\n                int current = sortedNumbers[i];\n                if (current == previous + 1)\n                {\n                    previous = current;\n                    continue;\n                }\n\n                yield return new AudioRange(start, previous);\n                start = previous = current;\n            }\n\n            yield return new AudioRange(start, previous);\n        }\n\n        private static bool HasSupportedAudioExtension(string filePath)\n        {\n            return filePath.EndsWith(\".wav\", StringComparison.OrdinalIgnoreCase) ||"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "ange(start, previous);\n        }\n\n        private static bool HasSupportedAudioExtension(string filePath)\n        {\n            return filePath.EndsWith(\".wav\", StringComparison.OrdinalIgnoreCase) ||\n                   filePath.EndsWith(\".mp3\", StringComparison.OrdinalIgnoreCase) ||\n                   filePath.EndsWith(\".ogg\", StringComparison.OrdinalIgnoreCase);\n        }\n\n        private static string RemoveAudioExtension(string relativePath)\n        {\n            int extensionIndex = relativePath.LastIndexOf('.');\n            return extensionIndex >= 0 ? relativePath.Substring(0, extensionIndex) : relativePath;\n        }\n\n        private static string InferUsageFromName(string categoryName)\n        {\n            if (string.IsNullOrEmpty(categoryName))\n            {\n                return string.Empty;\n            }\n\n            string lower = categoryName.ToLowerInvariant();\n\n            if (lower.Contains(\"amb\") || lower.Contains(\"pad\") || lower.Contains(\"drone\") || lower.Contains(\"music\"))\n            {\n                return \"loop\";\n            }\n\n            if (lower.Contains(\"step\") || lower.Contains(\"foot\") || lower.Contains(\"hit\") || lower.Contains(\"impact\") ||"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "Contains(\"music\"))\n            {\n                return \"loop\";\n            }\n\n            if (lower.Contains(\"step\") || lower.Contains(\"foot\") || lower.Contains(\"hit\") || lower.Contains(\"impact\") ||\n                lower.Contains(\"fx\") || lower.Contains(\"oneshot\") || lower.Contains(\"whoosh\"))\n            {\n                return \"oneshot\";\n            }\n\n            if (lower.Contains(\"voice\") || lower.Contains(\"dialog\") || lower.Contains(\"speech\"))\n            {\n                return \"oneshot (dialogue)\";\n            }\n\n            if (lower.Contains(\"loop\"))\n            {\n                return \"loop\";\n            }\n\n            return \"loop or oneshot\";\n        }\n\n        private static string FormatSampleRange(string categoryName, AudioRange range)\n        {\n            return range.Start == range.End\n                ? $\"{categoryName}/{range.Start}\"\n                : $\"{categoryName}/{range.Start}-{range.End}\";\n        }\n\n        private string ResolveCurrentScript(string explicitScript)\n        {\n            if (!string.IsNullOrWhiteSpace(explicitScript))\n            {\n                lastKnownScriptSnapshot = explicitScript;\n                return explicitScript;"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "ng explicitScript)\n        {\n            if (!string.IsNullOrWhiteSpace(explicitScript))\n            {\n                lastKnownScriptSnapshot = explicitScript;\n                return explicitScript;\n            }\n\n            if (!string.IsNullOrWhiteSpace(lastKnownScriptSnapshot))\n            {\n                return lastKnownScriptSnapshot;\n            }\n\n            try\n            {\n                var runtime = FindObjectOfType<SatieRuntime>();\n                if (runtime != null && runtime.ScriptFile != null)\n                {\n                    string runtimeScript = runtime.ScriptFile.text;\n                    if (!string.IsNullOrWhiteSpace(runtimeScript))\n                    {\n                        lastKnownScriptSnapshot = runtimeScript;\n                        return runtimeScript;\n                    }\n                }\n            }\n            catch (Exception e)\n            {\n                Debug.LogWarning($\"[AI] Unable to capture current script from runtime: {e.Message}\");\n            }\n\n            return string.Empty;\n        }\n\n        private string BuildScriptContextBlock(string scriptText)\n        {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "I] Unable to capture current script from runtime: {e.Message}\");\n            }\n\n            return string.Empty;\n        }\n\n        private string BuildScriptContextBlock(string scriptText)\n        {\n            string normalized = NormalizeLineEndings(scriptText).Trim();\n            if (string.IsNullOrEmpty(normalized))\n            {\n                return string.Empty;\n            }\n\n            var builder = new StringBuilder();\n            builder.AppendLine(\"CURRENT SCRIPT SNAPSHOT:\");\n\n            int summaryCount = 0;\n            foreach (var summary in SummarizeScriptBlocks(normalized))\n            {\n                builder.AppendLine($\"- {summary}\");\n                summaryCount++;\n                if (summaryCount >= MAX_SUMMARY_LINES)\n                {\n                    builder.AppendLine(\"- ...\");\n                    break;\n                }\n            }\n\n            builder.AppendLine(\"FULL SCRIPT (truncated if long):\");\n            builder.AppendLine(ClampForPrompt(normalized, MAX_SCRIPT_CONTEXT_CHARS));\n\n            return builder.ToString();\n        }\n\n        private IEnumerable<string> SummarizeScriptBlocks(string scriptText)\n        {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "ndLine(ClampForPrompt(normalized, MAX_SCRIPT_CONTEXT_CHARS));\n\n            return builder.ToString();\n        }\n\n        private IEnumerable<string> SummarizeScriptBlocks(string scriptText)\n        {\n            if (string.IsNullOrEmpty(scriptText))\n            {\n                yield break;\n            }\n\n            var lines = scriptText.Split('\\n');\n            var pattern = new Regex(@\"^\\s*(?:(\\d+)\\s*\\*\\s*)?(loop|oneshot)\\s+\"\"([^\"\"]+)\"\"\", RegexOptions.IgnoreCase);\n\n            for (int i = 0; i < lines.Length; i++)\n            {\n                string line = lines[i];\n                var match = pattern.Match(line);\n                if (!match.Success)\n                {\n                    continue;\n                }\n\n                string countText = match.Groups[1].Success ? match.Groups[1].Value : \"1\";\n                string type = match.Groups[2].Value.ToLowerInvariant();\n                string clip = match.Groups[3].Value;\n\n                int indent = CountLeadingWhitespace(line);\n                var details = new List<string>();\n\n                for (int j = i + 1; j < lines.Length; j++)\n                {\n                    string nextLine = lines[j];"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "eadingWhitespace(line);\n                var details = new List<string>();\n\n                for (int j = i + 1; j < lines.Length; j++)\n                {\n                    string nextLine = lines[j];\n                    if (string.IsNullOrWhiteSpace(nextLine))\n                    {\n                        continue;\n                    }\n\n                    int nextIndent = CountLeadingWhitespace(nextLine);\n                    if (nextIndent <= indent)\n                    {\n                        break;\n                    }\n\n                    string trimmed = nextLine.Trim();\n                    if (trimmed.StartsWith(\"#\"))\n                    {\n                        continue;\n                    }\n\n                    details.Add(trimmed);\n                    if (details.Count >= 3)\n                    {\n                        break;\n                    }\n                }\n\n                string detailText = details.Count > 0 ? $\" [{string.Join(\"; \", details)}]\" : string.Empty;\n                yield return $\"{countText} x {type} \\\"{clip}\\\"{detailText}\";\n            }\n        }"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "string detailText = details.Count > 0 ? $\" [{string.Join(\"; \", details)}]\" : string.Empty;\n                yield return $\"{countText} x {type} \\\"{clip}\\\"{detailText}\";\n            }\n        }\n\n        private async Task<string> BuildSystemPromptAsync(string scriptText, string userPrompt, bool includeEditInstructions)\n        {\n            string audioLibrary = await GetDynamicAudioLibrary();\n            string knowledgeBlock = await BuildKnowledgeContextAsync(scriptText, userPrompt);\n\n            var builder = new StringBuilder();\n            builder.Append(SYSTEM_PROMPT_BASE);\n\n            if (!string.IsNullOrEmpty(audioLibrary))\n            {\n                builder.AppendLine(audioLibrary.TrimEnd());\n            }\n\n            if (!string.IsNullOrEmpty(knowledgeBlock))\n            {\n                if (!string.IsNullOrEmpty(audioLibrary))\n                {\n                    builder.AppendLine();\n                }\n\n                builder.AppendLine(knowledgeBlock.TrimEnd());\n            }\n\n            string scriptContext = BuildScriptContextBlock(scriptText);\n            if (!string.IsNullOrEmpty(scriptContext))\n            {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "uilder.AppendLine(knowledgeBlock.TrimEnd());\n            }\n\n            string scriptContext = BuildScriptContextBlock(scriptText);\n            if (!string.IsNullOrEmpty(scriptContext))\n            {\n                if (!string.IsNullOrEmpty(audioLibrary) || !string.IsNullOrEmpty(knowledgeBlock))\n                {\n                    builder.AppendLine();\n                }\n\n                builder.AppendLine(scriptContext.TrimEnd());\n            }\n\n            if (includeEditInstructions)\n            {\n                builder.AppendLine();\n                builder.AppendLine(\"EDIT MODE: Make ONLY requested changes. Output COMPLETE modified script.\");\n            }\n\n            return builder.ToString();\n        }\n\n        private static string NormalizeLineEndings(string value)\n        {\n            if (string.IsNullOrEmpty(value))\n            {\n                return string.Empty;\n            }\n\n            return value.Replace(\"\\r\\n\", \"\\n\").Replace('\\r', '\\n');\n        }\n\n        private static string ClampForPrompt(string value, int maxChars)\n        {\n            if (string.IsNullOrEmpty(value) || value.Length <= maxChars)\n            {\n                return value;"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "private static string ClampForPrompt(string value, int maxChars)\n        {\n            if (string.IsNullOrEmpty(value) || value.Length <= maxChars)\n            {\n                return value;\n            }\n\n            return value.Substring(0, maxChars) + \"\\n...\";\n        }\n\n        private static int CountLeadingWhitespace(string line)\n        {\n            if (string.IsNullOrEmpty(line))\n            {\n                return 0;\n            }\n\n            int count = 0;\n            while (count < line.Length && char.IsWhiteSpace(line[count]))\n            {\n                count++;\n            }\n\n            return count;\n        }\n\n        private static string ResolveHeaderTemplate(string template, string apiKey)\n        {\n            string safeTemplate = template ?? string.Empty;\n            return string.IsNullOrEmpty(apiKey)\n                ? safeTemplate.Replace(\"{API_KEY}\", string.Empty)\n                : safeTemplate.Replace(\"{API_KEY}\", apiKey);\n        }\n\n        private void ApplyConfiguredHeaders(HttpRequestMessage request)\n        {\n            if (request == null)\n            {\n                return;\n            }"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "{API_KEY}\", apiKey);\n        }\n\n        private void ApplyConfiguredHeaders(HttpRequestMessage request)\n        {\n            if (request == null)\n            {\n                return;\n            }\n\n            if (!string.IsNullOrEmpty(apiKey) && config.sendAuthorizationHeader)\n            {\n                string headerName = string.IsNullOrWhiteSpace(config.authorizationHeaderName)\n                    ? \"Authorization\"\n                    : config.authorizationHeaderName.Trim();\n\n                string headerValue = ResolveHeaderTemplate(config.authorizationHeaderValueTemplate, apiKey);\n\n                if (!string.IsNullOrWhiteSpace(headerName) && !string.IsNullOrWhiteSpace(headerValue))\n                {\n                    request.Headers.Remove(headerName);\n                    request.Headers.TryAddWithoutValidation(headerName, headerValue);\n                }\n            }\n\n            if (config.additionalHeaders != null)\n            {\n                foreach (var header in config.additionalHeaders)\n                {\n                    if (header == null || string.IsNullOrWhiteSpace(header.name))\n                    {\n                        continue;"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "ch (var header in config.additionalHeaders)\n                {\n                    if (header == null || string.IsNullOrWhiteSpace(header.name))\n                    {\n                        continue;\n                    }\n\n                    string resolved = ResolveHeaderTemplate(header.value, apiKey);\n                    if (string.IsNullOrWhiteSpace(resolved))\n                    {\n                        continue;\n                    }\n\n                    request.Headers.Remove(header.name);\n                    request.Headers.TryAddWithoutValidation(header.name, resolved);\n                }\n            }\n        }\n\n        private async Task<string> SendChatCompletionAsync(List<ChatCompletionMessage> messages, string logPrefix, CancellationToken cancellationToken = default)\n        {\n            const int maxRetries = 3;\n            var adapter = ResolveProviderAdapter();\n\n            for (int attempt = 1; attempt <= maxRetries; attempt++)\n            {\n                try\n                {\n                    var requestData = new ChatCompletionRequestData\n                    {\n                        Model = config.model,\n                        Messages = messages,"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "{\n                    var requestData = new ChatCompletionRequestData\n                    {\n                        Model = config.model,\n                        Messages = messages,\n                        Temperature = config.temperature,\n                        MaxTokens = config.maxTokens\n                    };\n\n                    using var httpRequest = adapter.CreateRequest(config, requestData);\n                    ApplyConfiguredHeaders(httpRequest);\n\n                    Debug.Log($\"[{logPrefix}] Attempt {attempt}/{maxRetries} using provider {adapter.Id} model {config.model} (temp={config.temperature}, max_tokens={config.maxTokens}) -> {httpRequest.RequestUri}\");\n\n                    using var response = await httpClient.SendAsync(httpRequest, cancellationToken);\n                    string responseText = await response.Content.ReadAsStringAsync();\n\n                    if (!response.IsSuccessStatusCode)\n                    {\n                        Debug.LogError($\"[{logPrefix}] API error ({response.StatusCode}): {responseText}\");\n\n                        if ((int)response.StatusCode >= 400 && (int)response.StatusCode < 500)\n                        {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "LogError($\"[{logPrefix}] API error ({response.StatusCode}): {responseText}\");\n\n                        if ((int)response.StatusCode >= 400 && (int)response.StatusCode < 500)\n                        {\n                            return $\"# Error: API request failed - {response.StatusCode}\\n# Details: {responseText}\";\n                        }\n\n                        if (attempt == maxRetries)\n                        {\n                            return $\"# Error: API request failed after {maxRetries} attempts - {response.StatusCode}\\n# Details: {responseText}\";\n                        }\n\n                        await Task.Delay(1000 * attempt, cancellationToken);\n                        continue;\n                    }\n\n                    ChatCompletionResult result;\n                    try\n                    {\n                        result = adapter.ParseResponse(responseText);\n                    }\n                    catch (Exception parseEx)\n                    {\n                        Debug.LogError($\"[{logPrefix}] Failed to parse response: {parseEx.Message}\\nPayload: {responseText}\");"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "}\n                    catch (Exception parseEx)\n                    {\n                        Debug.LogError($\"[{logPrefix}] Failed to parse response: {parseEx.Message}\\nPayload: {responseText}\");\n                        return $\"# Error: Failed to parse AI response - {parseEx.Message}\";\n                    }\n\n                    string contentText = result?.Content;\n\n                    if (!string.IsNullOrEmpty(result?.FinishReason) && result.FinishReason.Equals(\"length\", StringComparison.OrdinalIgnoreCase))\n                    {\n                        Debug.LogWarning($\"[{logPrefix}] Response hit token limit (attempt {attempt})\");\n                    }\n\n                    if (!string.IsNullOrEmpty(contentText))\n                    {\n                        Debug.Log($\"[{logPrefix}] Success - received {contentText.Length} characters\");\n                        return contentText;\n                    }\n\n                    Debug.LogWarning($\"[{logPrefix}] Empty response content (attempt {attempt})\");\n                    if (attempt == maxRetries)\n                    {\n                        return \"# Error: No response from AI\";\n                    }"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "mpty response content (attempt {attempt})\");\n                    if (attempt == maxRetries)\n                    {\n                        return \"# Error: No response from AI\";\n                    }\n\n                    await Task.Delay(500 * attempt, cancellationToken);\n                }\n                catch (TaskCanceledException e) when (!cancellationToken.IsCancellationRequested)\n                {\n                    Debug.LogWarning($\"[{logPrefix}] Request timed out on attempt {attempt}: {e.Message}\");\n                    if (attempt == maxRetries)\n                    {\n                        return \"# Error: Request timed out after multiple attempts. Try a shorter prompt or check your connection.\";\n                    }\n                }\n                catch (Exception e)\n                {\n                    Debug.LogError($\"[{logPrefix}] Exception on attempt {attempt}: {e.Message}\");\n                    if (attempt == maxRetries)\n                    {\n                        return $\"# Error: {e.Message}\";\n                    }\n\n                    await Task.Delay(1000 * attempt, cancellationToken);\n                }\n            }"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "{\n                        return $\"# Error: {e.Message}\";\n                    }\n\n                    await Task.Delay(1000 * attempt, cancellationToken);\n                }\n            }\n\n            return \"# Error: All retry attempts failed\";\n        }\n\n        public async Task<string> TestAPIConnection()\n        {\n            if (!await LoadApiKey())\n            {\n                return \"API key not found\";\n            }\n\n            try\n            {\n                var adapter = ResolveProviderAdapter();\n                Debug.Log($\"[AI Test] Testing chat endpoint for provider '{adapter.Id}'...\");\n\n                var messages = new List<ChatCompletionMessage>\n                {\n                    new ChatCompletionMessage(\"user\", \"Say 'test'\")\n                };\n\n                var requestData = new ChatCompletionRequestData\n                {\n                    Model = string.IsNullOrWhiteSpace(config.model) ? \"gpt-3.5-turbo\" : config.model,\n                    Messages = messages,\n                    Temperature = 0f,\n                    MaxTokens = Mathf.Clamp(config.maxTokens > 0 ? config.maxTokens : 32, 16, 64)\n                };"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "l,\n                    Messages = messages,\n                    Temperature = 0f,\n                    MaxTokens = Mathf.Clamp(config.maxTokens > 0 ? config.maxTokens : 32, 16, 64)\n                };\n\n                using var request = adapter.CreateRequest(config, requestData);\n                ApplyConfiguredHeaders(request);\n\n                using var response = await httpClient.SendAsync(request);\n                string responseText = await response.Content.ReadAsStringAsync();\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    Debug.LogError($\"[AI Test] Chat endpoint failed ({response.StatusCode}): {responseText}\");\n                    return $\"Chat endpoint failed: {response.StatusCode}\";\n                }\n\n                ChatCompletionResult result;\n                try\n                {\n                    result = adapter.ParseResponse(responseText);\n                }\n                catch (Exception parseEx)\n                {\n                    Debug.LogError($\"[AI Test] Unable to parse chat response: {parseEx.Message}\\nPayload: {responseText}\");\n                    return $\"Chat response parse error: {parseEx.Message}\";"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "Debug.LogError($\"[AI Test] Unable to parse chat response: {parseEx.Message}\\nPayload: {responseText}\");\n                    return $\"Chat response parse error: {parseEx.Message}\";\n                }\n\n                string content = result?.Content ?? string.Empty;\n                Debug.Log($\"[AI Test] Chat endpoint status: {response.StatusCode}, content preview: {ClampForPrompt(content, 120)}\");\n\n                return $\"Chat endpoint succeeded: {response.StatusCode}\";\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"[AI Test] Exception: {e}\");\n                return $\"Test failed: {e.Message}\";\n            }\n        }\n\n        public async Task<string> GenerateSatieCode(string prompt)\n        {\n            if (!await LoadApiKey())\n            {\n                return \"# Error: API key not found. Please create Assets/api_key.txt with your OpenAI API key.\";\n            }\n\n            try\n            {\n                string scriptSnapshot = ResolveCurrentScript(string.Empty);\n                string systemPrompt = await BuildSystemPromptAsync(scriptSnapshot, prompt, includeEditInstructions: false);"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "string scriptSnapshot = ResolveCurrentScript(string.Empty);\n                string systemPrompt = await BuildSystemPromptAsync(scriptSnapshot, prompt, includeEditInstructions: false);\n\n                var messages = new List<ChatCompletionMessage>\n                {\n                    new ChatCompletionMessage(\"system\", systemPrompt),\n                    new ChatCompletionMessage(\"user\", prompt)\n                };\n\n                Debug.Log($\"[AI Debug] Using model: {config.model} (temp={config.temperature}, max_tokens={config.maxTokens})\");\n                Debug.Log($\"[AI Debug] Prompt chars: {prompt.Length}, Script chars: {scriptSnapshot.Length}\");\n\n                return await SendChatCompletionAsync(messages, \"AI Request\");\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"AI Generation Error: {e.Message}\");\n                return $\"# Error: {e.Message}\";\n            }\n        }\n\n        public void RecordRLHFFeedback(string prompt, string generatedCode, bool wasCorrect, string notes = \"\")\n        {\n            if (!config.enableRLHF) return;\n\n            var feedback = new RLHFFeedback\n            {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "dRLHFFeedback(string prompt, string generatedCode, bool wasCorrect, string notes = \"\")\n        {\n            if (!config.enableRLHF) return;\n\n            var feedback = new RLHFFeedback\n            {\n                prompt = prompt,\n                generatedCode = generatedCode,\n                wasCorrect = wasCorrect,\n                timestamp = System.DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss\"),\n                feedbackNotes = notes\n            };\n\n            try\n            {\n                string feedbackPath = Path.Combine(Application.dataPath, config.rlhfDataPath);\n                List<RLHFFeedback> allFeedback = new List<RLHFFeedback>();\n\n                if (File.Exists(feedbackPath))\n                {\n                    string existingData = File.ReadAllText(feedbackPath);\n                    if (!string.IsNullOrEmpty(existingData))\n                    {\n                        try\n                        {\n                            // Simple JSON array parsing since Unity's JsonUtility doesn't support lists directly\n                            string wrappedJson = \"{\\\"items\\\":\" + existingData + \"}\";"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "// Simple JSON array parsing since Unity's JsonUtility doesn't support lists directly\n                            string wrappedJson = \"{\\\"items\\\":\" + existingData + \"}\";\n                            var feedbackWrapper = JsonUtility.FromJson<RLHFFeedbackWrapper>(wrappedJson);\n                            if (feedbackWrapper?.items != null)\n                            {\n                                allFeedback = new List<RLHFFeedback>();\n                                foreach (var item in feedbackWrapper.items)\n                                    allFeedback.Add(item);\n                            }\n                        }\n                        catch (System.Exception parseEx)\n                        {\n                            Debug.LogWarning($\"Could not parse existing RLHF data: {parseEx.Message}\");\n                        }\n                    }\n                }\n\n                allFeedback.Add(feedback);\n                var feedbackArray = new RLHFFeedback[allFeedback.Count];\n                for (int i = 0; i < allFeedback.Count; i++)\n                    feedbackArray[i] = allFeedback[i];"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "(feedback);\n                var feedbackArray = new RLHFFeedback[allFeedback.Count];\n                for (int i = 0; i < allFeedback.Count; i++)\n                    feedbackArray[i] = allFeedback[i];\n                var wrapper = new RLHFFeedbackWrapper { items = feedbackArray };\n                string jsonData = JsonUtility.ToJson(wrapper, true);\n                // Extract just the items array from the wrapper\n                var match = System.Text.RegularExpressions.Regex.Match(jsonData, @\"\"\"items\"\"\\s*:\\s*(\\[.*\\])\");\n                if (match.Success)\n                    jsonData = match.Groups[1].Value;\n                else\n                    jsonData = \"[]\";\n                File.WriteAllText(feedbackPath, jsonData);\n                \n                Debug.Log($\"[RLHF] Recorded feedback: {(wasCorrect ? \"Correct\" : \"Incorrect\")} for prompt: {prompt.Substring(0, Mathf.Min(50, prompt.Length))}...\");\n            }\n            catch (System.Exception e)\n            {\n                Debug.LogError($\"[RLHF] Failed to record feedback: {e.Message}\");\n            }\n        }\n\n        public async Task<string> GenerateWithResourceAwareness(string prompt)\n        {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "{\n                Debug.LogError($\"[RLHF] Failed to record feedback: {e.Message}\");\n            }\n        }\n\n        public async Task<string> GenerateWithResourceAwareness(string prompt)\n        {\n            string scriptSnapshot = ResolveCurrentScript(string.Empty);\n            string systemPrompt = await BuildSystemPromptAsync(scriptSnapshot, prompt, includeEditInstructions: false);\n            return await GenerateSatieCodeWithCustomSystem(prompt, systemPrompt);\n        }\n\n        private async Task<string> GenerateSatieCodeWithCustomSystem(string prompt, string systemPrompt)\n        {\n            if (!await LoadApiKey())\n            {\n                return \"# Error: API key not found. Please create Assets/api_key.txt with your OpenAI API key.\";\n            }\n\n            var messages = new List<ChatCompletionMessage>\n            {\n                new ChatCompletionMessage(\"system\", systemPrompt),\n                new ChatCompletionMessage(\"user\", prompt)\n            };\n\n            return await SendChatCompletionAsync(messages, \"AI Request\");\n        }\n        private async Task<bool> LoadApiKey()\n        {\n            if (!string.IsNullOrEmpty(apiKey))\n            {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "return await SendChatCompletionAsync(messages, \"AI Request\");\n        }\n        private async Task<bool> LoadApiKey()\n        {\n            if (!string.IsNullOrEmpty(apiKey))\n            {\n                Debug.Log($\"[AI Debug] Using cached API key\");\n                return true;\n            }\n\n            // Use the centralized API key manager\n            apiKey = SatieAPIKeyManager.GetKey(SatieAPIKeyManager.Provider.OpenAI);\n\n            if (string.IsNullOrEmpty(apiKey))\n            {\n                Debug.LogError($\"[AI Debug] No OpenAI API key configured. Please use Satie > API Key Manager to set it up.\");\n                Debug.LogError(\"Legacy support: You can also create api_key.txt in Assets folder with your OpenAI API key.\");\n                return false;\n            }\n\n            // Validate API key format\n            if (!apiKey.StartsWith(\"sk-\"))\n            {\n                Debug.LogWarning($\"[AI Debug] API key doesn't start with 'sk-'. Got: {apiKey.Substring(0, Mathf.Min(10, apiKey.Length))}...\");\n            }"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "(!apiKey.StartsWith(\"sk-\"))\n            {\n                Debug.LogWarning($\"[AI Debug] API key doesn't start with 'sk-'. Got: {apiKey.Substring(0, Mathf.Min(10, apiKey.Length))}...\");\n            }\n\n            Debug.Log($\"[AI Debug] API key loaded successfully from centralized manager. Format: {apiKey.Substring(0, 3)}... Length: {apiKey.Length}\");\n            return true;\n        }\n        \n        private async Task RefreshResourceCache()\n        {\n            try\n            {\n                cachedResourcePrompt = await ScanAudioResources();\n                lastResourceScanTime = Time.realtimeSinceStartup;\n                int categoryCount = 0;\n                lock (resourceCacheLock)\n                {\n                    categoryCount = cachedResourceSnapshot?.Categories.Count ?? 0;\n                }\n                Debug.Log($\"[AI Cache] Resource cache refreshed ({categoryCount} categories)\");\n            }\n            catch (Exception e)\n            {\n                Debug.LogWarning($\"[AI Cache] Failed to refresh resource cache: {e.Message}\");\n            }\n        }\n\n        public void InvalidateResourceCache()\n        {\n            cachedResourcePrompt = null;"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "ebug.LogWarning($\"[AI Cache] Failed to refresh resource cache: {e.Message}\");\n            }\n        }\n\n        public void InvalidateResourceCache()\n        {\n            cachedResourcePrompt = null;\n            lock (resourceCacheLock)\n            {\n                cachedResourceSnapshot = null;\n            }\n            lastResourceScanTime = -1f;\n            Debug.Log(\"[AI Cache] Resource cache invalidated\");\n        }\n\n        public void InvalidateKnowledgeIndex()\n        {\n            lock (knowledgeIndexLock)\n            {\n                knowledgeIndexDirty = true;\n            }\n\n            Debug.Log(\"[AI Knowledge] Knowledge index invalidated\");\n        }\n\n        private async Task<RagIndexCache> GetKnowledgeIndexAsync()\n        {\n            Task<RagIndexCache> buildTask;\n            RagIndexCache snapshot;\n\n            lock (knowledgeIndexLock)\n            {\n                if (!knowledgeIndexDirty && cachedKnowledgeIndex != null)\n                {\n                    return cachedKnowledgeIndex;\n                }\n\n                if (knowledgeIndexBuildTask == null || knowledgeIndexBuildTask.IsCompleted)\n                {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "ll)\n                {\n                    return cachedKnowledgeIndex;\n                }\n\n                if (knowledgeIndexBuildTask == null || knowledgeIndexBuildTask.IsCompleted)\n                {\n                    knowledgeIndexBuildTask = Task.Run(BuildKnowledgeIndex);\n                }\n\n                buildTask = knowledgeIndexBuildTask;\n                snapshot = cachedKnowledgeIndex;\n            }\n\n            if (snapshot != null)\n            {\n                _ = FinalizeKnowledgeIndexBuildAsync(buildTask);\n                return snapshot;\n            }\n\n            await FinalizeKnowledgeIndexBuildAsync(buildTask);\n\n            lock (knowledgeIndexLock)\n            {\n                return cachedKnowledgeIndex ?? new RagIndexCache();\n            }\n        }\n\n        private async Task FinalizeKnowledgeIndexBuildAsync(Task<RagIndexCache> buildTask)\n        {\n            try\n            {\n                var index = await buildTask.ConfigureAwait(false);\n\n                lock (knowledgeIndexLock)\n                {\n                    cachedKnowledgeIndex = index ?? new RagIndexCache();\n                    knowledgeIndexDirty = false;"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "reAwait(false);\n\n                lock (knowledgeIndexLock)\n                {\n                    cachedKnowledgeIndex = index ?? new RagIndexCache();\n                    knowledgeIndexDirty = false;\n\n                    if (knowledgeIndexBuildTask == buildTask)\n                    {\n                        knowledgeIndexBuildTask = null;\n                    }\n                }\n            }\n            catch (Exception e)\n            {\n                Debug.LogWarning($\"[AI Knowledge] Index build failed: {e.Message}\");\n\n                lock (knowledgeIndexLock)\n                {\n                    if (knowledgeIndexBuildTask == buildTask)\n                    {\n                        knowledgeIndexBuildTask = null;\n                    }\n\n                    knowledgeIndexDirty = true;\n                }\n            }\n        }\n\n        private RagIndexCache BuildKnowledgeIndex()\n        {\n            try\n            {\n                Directory.CreateDirectory(knowledgeIndexDirectory);\n\n                var sources = CollectKnowledgeSourceFiles();\n                var sourceMap = sources.ToDictionary(s => s.RelativePath, s => s.LastWriteTicks, StringComparer.OrdinalIgnoreCase);"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "ry);\n\n                var sources = CollectKnowledgeSourceFiles();\n                var sourceMap = sources.ToDictionary(s => s.RelativePath, s => s.LastWriteTicks, StringComparer.OrdinalIgnoreCase);\n\n                var existing = LoadKnowledgeIndexFromDisk();\n                if (existing != null && IsIndexCurrent(existing, sourceMap))\n                {\n                    Debug.Log($\"[AI Knowledge] Using cached index ({existing.Chunks.Count} chunks)\");\n                    return existing;\n                }\n\n                var index = new RagIndexCache();\n\n                foreach (var source in sources)\n                {\n                    string text = SafeReadAllText(source.FullPath);\n                    index.SourceFileVersions[source.RelativePath] = source.LastWriteTicks;\n\n                    if (string.IsNullOrWhiteSpace(text))\n                    {\n                        continue;\n                    }\n\n                    foreach (var chunk in ChunkKnowledgeContent(source.RelativePath, text))\n                    {\n                        if (chunk != null)\n                        {\n                            index.Chunks.Add(chunk);\n                        }"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "t(source.RelativePath, text))\n                    {\n                        if (chunk != null)\n                        {\n                            index.Chunks.Add(chunk);\n                        }\n                    }\n                }\n\n                PersistKnowledgeIndex(index);\n                Debug.Log($\"[AI Knowledge] Rebuilt index with {index.Chunks.Count} chunks from {sources.Count} files\");\n\n                return index;\n            }\n            catch (Exception e)\n            {\n                Debug.LogWarning($\"[AI Knowledge] Failed to build index: {e.Message}\");\n                return cachedKnowledgeIndex ?? new RagIndexCache();\n            }\n        }\n\n        private RagIndexCache LoadKnowledgeIndexFromDisk()\n        {\n            try\n            {\n                if (string.IsNullOrEmpty(knowledgeIndexFilePath) || !File.Exists(knowledgeIndexFilePath))\n                {\n                    return null;\n                }\n\n                string json = File.ReadAllText(knowledgeIndexFilePath);\n                if (string.IsNullOrEmpty(json))\n                {\n                    return null;\n                }"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "}\n\n                string json = File.ReadAllText(knowledgeIndexFilePath);\n                if (string.IsNullOrEmpty(json))\n                {\n                    return null;\n                }\n\n                var index = JsonUtility.FromJson<RagIndexCache>(json) ?? new RagIndexCache();\n                index.Chunks ??= new List<RagChunkRecord>();\n                index.SourceFileVersions ??= new Dictionary<string, long>();\n                return index;\n            }\n            catch (Exception e)\n            {\n                Debug.LogWarning($\"[AI Knowledge] Failed to load cached index: {e.Message}\");\n                return null;\n            }\n        }\n\n        private void PersistKnowledgeIndex(RagIndexCache index)\n        {\n            try\n            {\n                if (string.IsNullOrEmpty(knowledgeIndexFilePath))\n                {\n                    return;\n                }\n\n                Directory.CreateDirectory(knowledgeIndexDirectory);\n                string json = JsonUtility.ToJson(index, true);\n                File.WriteAllText(knowledgeIndexFilePath, json);\n            }\n            catch (Exception e)\n            {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "Directory);\n                string json = JsonUtility.ToJson(index, true);\n                File.WriteAllText(knowledgeIndexFilePath, json);\n            }\n            catch (Exception e)\n            {\n                Debug.LogWarning($\"[AI Knowledge] Failed to persist index: {e.Message}\");\n            }\n        }\n\n        private static bool IsIndexCurrent(RagIndexCache existing, Dictionary<string, long> sourceMap)\n        {\n            if (existing == null)\n            {\n                return false;\n            }\n\n            foreach (var kvp in sourceMap)\n            {\n                if (!existing.SourceFileVersions.TryGetValue(kvp.Key, out long timestamp) || timestamp != kvp.Value)\n                {\n                    return false;\n                }\n            }\n\n            foreach (var key in existing.SourceFileVersions.Keys)\n            {\n                if (!sourceMap.ContainsKey(key))\n                {\n                    return false;\n                }\n            }\n\n            return existing.Chunks != null && existing.Chunks.Count > 0;\n        }\n\n        private List<KnowledgeSourceFile> CollectKnowledgeSourceFiles()\n        {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "}\n            }\n\n            return existing.Chunks != null && existing.Chunks.Count > 0;\n        }\n\n        private List<KnowledgeSourceFile> CollectKnowledgeSourceFiles()\n        {\n            var results = new List<KnowledgeSourceFile>();\n            var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n\n            void AddFile(string filePath)\n            {\n                if (string.IsNullOrEmpty(filePath) || !IsSupportedKnowledgeFile(filePath))\n                {\n                    return;\n                }\n\n                string relative = GetProjectRelativePath(filePath);\n                if (!seen.Add(relative))\n                {\n                    return;\n                }\n\n                try\n                {\n                    var info = new FileInfo(filePath);\n                    results.Add(new KnowledgeSourceFile\n                    {\n                        FullPath = filePath,\n                        RelativePath = relative,\n                        LastWriteTicks = info.LastWriteTimeUtc.Ticks\n                    });\n                }\n                catch (Exception e)\n                {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "RelativePath = relative,\n                        LastWriteTicks = info.LastWriteTimeUtc.Ticks\n                    });\n                }\n                catch (Exception e)\n                {\n                    Debug.LogWarning($\"[AI Knowledge] Unable to read metadata for {filePath}: {e.Message}\");\n                }\n            }\n\n            void Traverse(string root, bool recursive)\n            {\n                if (string.IsNullOrEmpty(root) || !Directory.Exists(root))\n                {\n                    return;\n                }\n\n                if (!recursive)\n                {\n                    foreach (var file in SafeGetFiles(root))\n                    {\n                        AddFile(file);\n                    }\n                    return;\n                }\n\n                var stack = new Stack<string>();\n                stack.Push(root);\n\n                while (stack.Count > 0)\n                {\n                    var current = stack.Pop();\n\n                    foreach (var directory in SafeGetDirectories(current))\n                    {\n                        if (ShouldSkipKnowledgeDirectory(directory))\n                        {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "Pop();\n\n                    foreach (var directory in SafeGetDirectories(current))\n                    {\n                        if (ShouldSkipKnowledgeDirectory(directory))\n                        {\n                            continue;\n                        }\n\n                        stack.Push(directory);\n                    }\n\n                    foreach (var file in SafeGetFiles(current))\n                    {\n                        AddFile(file);\n                    }\n                }\n            }\n\n            if (!string.IsNullOrEmpty(Application.dataPath))\n            {\n                Traverse(Application.dataPath, true);\n            }\n\n            if (!string.IsNullOrEmpty(projectRootPath))\n            {\n                string[] additionalFolders =\n                {\n                    \"Docs\",\n                    \"docs\",\n                    \"Documentation\",\n                    \"documentation\",\n                    \"Samples\",\n                    \"Guides\",\n                    \"SatieSyntaxVSCode\"\n                };\n\n                foreach (var folder in additionalFolders)\n                {\n                    Traverse(Path.Combine(projectRootPath, folder), true);"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "\"SatieSyntaxVSCode\"\n                };\n\n                foreach (var folder in additionalFolders)\n                {\n                    Traverse(Path.Combine(projectRootPath, folder), true);\n                }\n\n                Traverse(projectRootPath, false);\n            }\n\n            if (!string.IsNullOrEmpty(knowledgeIndexFilePath))\n            {\n                string normalizedIndex = Path.GetFullPath(knowledgeIndexFilePath);\n                results.RemoveAll(r => string.Equals(Path.GetFullPath(r.FullPath), normalizedIndex, StringComparison.OrdinalIgnoreCase));\n            }\n\n            return results;\n        }\n\n        private IEnumerable<RagChunkRecord> ChunkKnowledgeContent(string relativePath, string content)\n        {\n            string normalized = NormalizeLineEndings(content).Trim();\n            if (string.IsNullOrEmpty(normalized))\n            {\n                yield break;\n            }\n\n            var nameTokens = TokenizeText(Path.GetFileName(relativePath));\n            int start = 0;\n\n            while (start < normalized.Length)\n            {\n                int length = Math.Min(KNOWLEDGE_CHUNK_SIZE, normalized.Length - start);"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "ileName(relativePath));\n            int start = 0;\n\n            while (start < normalized.Length)\n            {\n                int length = Math.Min(KNOWLEDGE_CHUNK_SIZE, normalized.Length - start);\n                int end = start + length;\n\n                if (end < normalized.Length)\n                {\n                    int newline = normalized.LastIndexOf('\\n', end - 1, length);\n                    if (newline > start + KNOWLEDGE_CHUNK_SIZE / 2)\n                    {\n                        end = newline + 1;\n                    }\n                }\n\n                string chunkText = normalized.Substring(start, end - start).Trim();\n                if (!string.IsNullOrEmpty(chunkText))\n                {\n                    var tokens = TokenizeText(chunkText);\n                    if (tokens.Count > 0)\n                    {\n                        tokens.AddRange(nameTokens);\n                        var weights = BuildTermWeights(tokens);\n                        yield return new RagChunkRecord\n                        {\n                            Source = relativePath.Replace('\\\\', '/'),\n                            Content = chunkText,"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "yield return new RagChunkRecord\n                        {\n                            Source = relativePath.Replace('\\\\', '/'),\n                            Content = chunkText,\n                            TermWeights = weights\n                        };\n                    }\n                }\n\n                if (end >= normalized.Length)\n                {\n                    break;\n                }\n\n                int nextStart = Math.Max(end - KNOWLEDGE_CHUNK_OVERLAP, start + 1);\n                if (nextStart <= start)\n                {\n                    nextStart = end;\n                }\n\n                start = nextStart;\n            }\n        }\n\n        private static List<string> TokenizeText(string text)\n        {\n            var tokens = new List<string>();\n            if (string.IsNullOrWhiteSpace(text))\n            {\n                return tokens;\n            }\n\n            foreach (Match match in KnowledgeTokenRegex.Matches(text))\n            {\n                string token = match.Value.ToLowerInvariant();\n                if (token.Length <= 1)\n                {\n                    continue;\n                }"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "x.Matches(text))\n            {\n                string token = match.Value.ToLowerInvariant();\n                if (token.Length <= 1)\n                {\n                    continue;\n                }\n\n                tokens.Add(token);\n            }\n\n            return tokens;\n        }\n\n        private static Dictionary<string, float> BuildTermWeights(IEnumerable<string> tokens)\n        {\n            var counts = new Dictionary<string, int>();\n            int total = 0;\n\n            foreach (var token in tokens)\n            {\n                if (string.IsNullOrWhiteSpace(token))\n                {\n                    continue;\n                }\n\n                if (!counts.TryGetValue(token, out int count))\n                {\n                    count = 0;\n                }\n\n                counts[token] = count + 1;\n                total++;\n            }\n\n            var weights = new Dictionary<string, float>(counts.Count);\n            if (total <= 0)\n            {\n                return weights;\n            }\n\n            foreach (var kvp in counts)\n            {\n                weights[kvp.Key] = kvp.Value / (float)total;\n            }\n\n            return weights;\n        }"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "return weights;\n            }\n\n            foreach (var kvp in counts)\n            {\n                weights[kvp.Key] = kvp.Value / (float)total;\n            }\n\n            return weights;\n        }\n\n        private static float ScoreChunkAgainstQuery(RagChunkRecord chunk, Dictionary<string, float> queryWeights)\n        {\n            if (chunk?.TermWeights == null || queryWeights == null || queryWeights.Count == 0)\n            {\n                return 0f;\n            }\n\n            float score = 0f;\n\n            foreach (var kvp in queryWeights)\n            {\n                if (chunk.TermWeights.TryGetValue(kvp.Key, out float weight))\n                {\n                    score += weight * kvp.Value;\n                }\n            }\n\n            return score;\n        }\n\n        private static IEnumerable<string> SafeGetDirectories(string path)\n        {\n            try\n            {\n                return Directory.GetDirectories(path);\n            }\n            catch\n            {\n                return Array.Empty<string>();\n            }\n        }\n\n        private static IEnumerable<string> SafeGetFiles(string path)\n        {\n            try\n            {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "catch\n            {\n                return Array.Empty<string>();\n            }\n        }\n\n        private static IEnumerable<string> SafeGetFiles(string path)\n        {\n            try\n            {\n                return Directory.GetFiles(path);\n            }\n            catch\n            {\n                return Array.Empty<string>();\n            }\n        }\n\n        private static bool ShouldSkipKnowledgeDirectory(string directoryPath)\n        {\n            if (string.IsNullOrEmpty(directoryPath))\n            {\n                return true;\n            }\n\n            string name = Path.GetFileName(directoryPath);\n            if (string.IsNullOrEmpty(name))\n            {\n                return false;\n            }\n\n            if (name.StartsWith(\".\", StringComparison.Ordinal))\n            {\n                return true;\n            }\n\n            switch (name.ToLowerInvariant())\n            {\n                case \"library\":\n                case \"logs\":\n                case \"obj\":\n                case \"temp\":\n                case \"build\":\n                case \"builds\":\n                case \"packages\":\n                case KNOWLEDGE_INDEX_DIRECTORY_NAME:"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "case \"obj\":\n                case \"temp\":\n                case \"build\":\n                case \"builds\":\n                case \"packages\":\n                case KNOWLEDGE_INDEX_DIRECTORY_NAME:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private static bool IsSupportedKnowledgeFile(string filePath)\n        {\n            string extension = Path.GetExtension(filePath)?.ToLowerInvariant();\n            return extension switch\n            {\n                \".sat\" => true,\n                \".satie\" => true,\n                \".cs\" => true,\n                \".uxml\" => true,\n                \".uss\" => true,\n                \".shader\" => true,\n                \".txt\" => true,\n                \".md\" => true,\n                _ => false\n            };\n        }\n\n        private string GetProjectRelativePath(string fullPath)\n        {\n            if (string.IsNullOrEmpty(fullPath))\n            {\n                return string.Empty;\n            }\n\n            try\n            {\n                string projectRoot = projectRootPath ?? Path.GetFullPath(Path.Combine(Application.dataPath, \"..\"));"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "{\n                return string.Empty;\n            }\n\n            try\n            {\n                string projectRoot = projectRootPath ?? Path.GetFullPath(Path.Combine(Application.dataPath, \"..\"));\n                string normalized = Path.GetFullPath(fullPath);\n                string relative = Path.GetRelativePath(projectRoot, normalized);\n                return relative.Replace('\\\\', '/');\n            }\n            catch\n            {\n                return fullPath.Replace('\\\\', '/');\n            }\n        }\n\n        private static string SafeReadAllText(string path)\n        {\n            try\n            {\n                return File.ReadAllText(path);\n            }\n            catch (Exception e)\n            {\n                Debug.LogWarning($\"[AI Knowledge] Failed to read {path}: {e.Message}\");\n                return string.Empty;\n            }\n        }\n\n        private async Task<string> BuildKnowledgeContextAsync(string scriptText, string userPrompt)\n        {\n            try\n            {\n                var index = await GetKnowledgeIndexAsync();\n                var chunks = index?.Chunks;\n                if (chunks == null || chunks.Count == 0)\n                {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "try\n            {\n                var index = await GetKnowledgeIndexAsync();\n                var chunks = index?.Chunks;\n                if (chunks == null || chunks.Count == 0)\n                {\n                    return string.Empty;\n                }\n\n                var queryTokens = new List<string>();\n\n                if (!string.IsNullOrWhiteSpace(userPrompt))\n                {\n                    var promptTokens = TokenizeText(userPrompt);\n                    if (promptTokens.Count > 0)\n                    {\n                        // Weight the active request a little higher than passive script context.\n                        queryTokens.AddRange(promptTokens);\n                        queryTokens.AddRange(promptTokens);\n                    }\n                }\n\n                string normalizedScript = NormalizeLineEndings(scriptText ?? string.Empty);\n                if (!string.IsNullOrEmpty(normalizedScript))\n                {\n                    if (normalizedScript.Length > KNOWLEDGE_QUERY_SCRIPT_CHARS)\n                    {\n                        normalizedScript = normalizedScript.Substring(0, KNOWLEDGE_QUERY_SCRIPT_CHARS);\n                    }"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "lizedScript.Length > KNOWLEDGE_QUERY_SCRIPT_CHARS)\n                    {\n                        normalizedScript = normalizedScript.Substring(0, KNOWLEDGE_QUERY_SCRIPT_CHARS);\n                    }\n\n                    var scriptTokens = TokenizeText(normalizedScript);\n                    if (scriptTokens.Count > 0)\n                    {\n                        queryTokens.AddRange(scriptTokens);\n                    }\n                }\n\n                if (queryTokens.Count == 0)\n                {\n                    return string.Empty;\n                }\n\n                var queryWeights = BuildTermWeights(queryTokens);\n                if (queryWeights == null || queryWeights.Count == 0)\n                {\n                    return string.Empty;\n                }\n\n                var scoredChunks = new List<(RagChunkRecord chunk, float score)>();\n                foreach (var chunk in chunks)\n                {\n                    if (chunk == null || string.IsNullOrWhiteSpace(chunk.Content))\n                    {\n                        continue;\n                    }\n\n                    float score = ScoreChunkAgainstQuery(chunk, queryWeights);"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "string.IsNullOrWhiteSpace(chunk.Content))\n                    {\n                        continue;\n                    }\n\n                    float score = ScoreChunkAgainstQuery(chunk, queryWeights);\n                    if (score <= 0f)\n                    {\n                        continue;\n                    }\n\n                    scoredChunks.Add((chunk, score));\n                }\n\n                if (scoredChunks.Count == 0)\n                {\n                    return string.Empty;\n                }\n\n                scoredChunks.Sort((a, b) =>\n                {\n                    int scoreCompare = b.score.CompareTo(a.score);\n                    if (scoreCompare != 0)\n                    {\n                        return scoreCompare;\n                    }\n\n                    string sourceA = a.chunk?.Source ?? string.Empty;\n                    string sourceB = b.chunk?.Source ?? string.Empty;\n                    return string.Compare(sourceA, sourceB, StringComparison.OrdinalIgnoreCase);\n                });\n\n                var builder = new StringBuilder();\n                var seenSources = new HashSet<string>(StringComparer.OrdinalIgnoreCase);"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": ", StringComparison.OrdinalIgnoreCase);\n                });\n\n                var builder = new StringBuilder();\n                var seenSources = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n                int appended = 0;\n\n                foreach (var entry in scoredChunks)\n                {\n                    if (entry.chunk == null)\n                    {\n                        continue;\n                    }\n\n                    string source = entry.chunk.Source ?? string.Empty;\n                    if (!seenSources.Add(source))\n                    {\n                        continue;\n                    }\n\n                    string snippet = NormalizeLineEndings(entry.chunk.Content ?? string.Empty).Trim();\n                    if (string.IsNullOrEmpty(snippet))\n                    {\n                        continue;\n                    }\n\n                    snippet = ClampForPrompt(snippet, KNOWLEDGE_SNIPPET_MAX_CHARS)?.Trim();\n                    if (string.IsNullOrEmpty(snippet))\n                    {\n                        continue;\n                    }\n\n                    if (appended == 0)\n                    {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "m();\n                    if (string.IsNullOrEmpty(snippet))\n                    {\n                        continue;\n                    }\n\n                    if (appended == 0)\n                    {\n                        builder.AppendLine(\"PROJECT KNOWLEDGE SNIPPETS:\");\n                    }\n\n                    builder.AppendLine($\"[{appended + 1}] {source}\");\n                    builder.AppendLine(\"    \" + snippet.Replace(\"\\n\", \"\\n    \"));\n                    builder.AppendLine();\n\n                    appended++;\n                    if (appended >= KNOWLEDGE_MAX_SNIPPETS)\n                    {\n                        break;\n                    }\n                }\n\n                if (appended == 0)\n                {\n                    return string.Empty;\n                }\n\n                return builder.ToString().TrimEnd();\n            }\n            catch (Exception e)\n            {\n                Debug.LogWarning($\"[AI Knowledge] Failed to build knowledge context: {e.Message}\");\n                return string.Empty;\n            }\n        }\n\n        // Conversation context management\n        public void StartNewConversation(string scriptSnapshot)\n        {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "text: {e.Message}\");\n                return string.Empty;\n            }\n        }\n\n        // Conversation context management\n        public void StartNewConversation(string scriptSnapshot)\n        {\n            string resolvedScript = string.IsNullOrWhiteSpace(scriptSnapshot)\n                ? ResolveCurrentScript(string.Empty)\n                : scriptSnapshot;\n\n            resolvedScript = NormalizeLineEndings(resolvedScript ?? string.Empty);\n\n            if (!string.IsNullOrWhiteSpace(resolvedScript))\n            {\n                lastKnownScriptSnapshot = resolvedScript;\n            }\n\n            currentConversation = new ConversationHistory\n            {\n                messages = Array.Empty<ConversationMessage>(),\n                currentScript = resolvedScript\n            };\n\n            isEditMode = false;\n            Debug.Log(\"[AI Conversation] Started new conversation\");\n        }\n\n        private void UpdateConversationScript(string scriptSnapshot)\n        {\n            if (currentConversation == null)\n            {\n                return;\n            }\n\n            string normalized = NormalizeLineEndings(scriptSnapshot ?? string.Empty);"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "shot)\n        {\n            if (currentConversation == null)\n            {\n                return;\n            }\n\n            string normalized = NormalizeLineEndings(scriptSnapshot ?? string.Empty);\n            currentConversation.currentScript = normalized;\n\n            if (!string.IsNullOrWhiteSpace(normalized))\n            {\n                lastKnownScriptSnapshot = normalized;\n            }\n        }\n\n        public void SetEditMode(bool enabled, string currentScript = \"\")\n        {\n            string resolvedScript = ResolveCurrentScript(currentScript);\n\n            if (enabled)\n            {\n                if (currentConversation == null)\n                {\n                    StartNewConversation(resolvedScript);\n                }\n                else\n                {\n                    UpdateConversationScript(resolvedScript);\n                }\n                isEditMode = true;\n            }\n            else\n            {\n                UpdateConversationScript(resolvedScript);\n                isEditMode = false;\n            }\n\n            Debug.Log($\"[AI Conversation] Edit mode: {enabled}\");\n        }\n\n        private static bool IsErrorResponse(string response)"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "edScript);\n                isEditMode = false;\n            }\n\n            Debug.Log($\"[AI Conversation] Edit mode: {enabled}\");\n        }\n\n        private static bool IsErrorResponse(string response)\n        {\n            return !string.IsNullOrEmpty(response) &&\n                   response.StartsWith(\"# Error\", StringComparison.OrdinalIgnoreCase);\n        }\n\n        public bool IsInEditMode()\n        {\n            return isEditMode && currentConversation != null;\n        }\n\n        public ConversationHistory GetCurrentConversation()\n        {\n            return currentConversation;\n        }\n\n        private void AddMessageToConversation(string role, string content)\n        {\n            if (currentConversation == null) return;\n\n            var newMessage = new ConversationMessage\n            {\n                role = role,\n                content = content,\n                timestamp = System.DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss\")\n            };\n\n            var messagesList = new List<ConversationMessage>();\n            if (currentConversation.messages != null)\n            {\n                messagesList.AddRange(currentConversation.messages);\n            }"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "messagesList = new List<ConversationMessage>();\n            if (currentConversation.messages != null)\n            {\n                messagesList.AddRange(currentConversation.messages);\n            }\n            messagesList.Add(newMessage);\n            currentConversation.messages = messagesList.ToArray();\n        }\n\n        private List<ChatCompletionMessage> BuildConversationMessages(string systemPrompt)\n        {\n            var messages = new List<ChatCompletionMessage>\n            {\n                new ChatCompletionMessage(\"system\", systemPrompt)\n            };\n\n            var history = currentConversation?.messages;\n            if (history == null || history.Length == 0)\n            {\n                return messages;\n            }\n\n            int startIndex = Mathf.Max(0, history.Length - MAX_CONVERSATION_MESSAGES);\n            for (int i = startIndex; i < history.Length; i++)\n            {\n                var historyMessage = history[i];\n                string role = string.Equals(historyMessage.role, \"assistant\", StringComparison.OrdinalIgnoreCase)\n                    ? \"assistant\"\n                    : \"user\";"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "essage = history[i];\n                string role = string.Equals(historyMessage.role, \"assistant\", StringComparison.OrdinalIgnoreCase)\n                    ? \"assistant\"\n                    : \"user\";\n\n                string normalized = NormalizeLineEndings(historyMessage.content ?? string.Empty);\n                string trimmed = ClampForPrompt(normalized, MAX_CONVERSATION_MESSAGE_CHARS);\n\n                messages.Add(new ChatCompletionMessage(role, trimmed));\n            }\n\n            return messages;\n        }\n\n        public async Task<string> GenerateWithFollowUp(string prompt, string currentScript = \"\")\n        {\n            string scriptSnapshot = ResolveCurrentScript(currentScript);\n\n            if (isEditMode && currentConversation != null)\n            {\n                UpdateConversationScript(scriptSnapshot);\n                AddMessageToConversation(\"user\", prompt);\n\n                string result = await GenerateWithConversationContext(scriptSnapshot, prompt);\n\n                if (!IsErrorResponse(result))\n                {\n                    AddMessageToConversation(\"assistant\", result);\n                    UpdateConversationScript(result);\n                }"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "if (!IsErrorResponse(result))\n                {\n                    AddMessageToConversation(\"assistant\", result);\n                    UpdateConversationScript(result);\n                }\n\n                return result;\n            }\n\n            StartNewConversation(scriptSnapshot);\n            AddMessageToConversation(\"user\", prompt);\n\n            string generation = await GenerateWithResourceAwareness(prompt);\n\n            if (!IsErrorResponse(generation))\n            {\n                AddMessageToConversation(\"assistant\", generation);\n                UpdateConversationScript(generation);\n            }\n\n            return generation;\n        }\n\n        private async Task<string> GenerateWithConversationContext(string scriptSnapshot, string latestUserPrompt)\n        {\n            if (!await LoadApiKey())\n            {\n                return \"# Error: API key not found. Please create Assets/api_key.txt with your OpenAI API key.\";\n            }\n\n            try\n            {\n                string workingScript = currentConversation?.currentScript;\n                if (string.IsNullOrWhiteSpace(workingScript))\n                {"
    },
    {
      "Source": "Assets/Scripts/SatieAICodeGen.cs",
      "Content": "}\n\n            try\n            {\n                string workingScript = currentConversation?.currentScript;\n                if (string.IsNullOrWhiteSpace(workingScript))\n                {\n                    workingScript = scriptSnapshot;\n                }\n\n                workingScript = NormalizeLineEndings(workingScript ?? string.Empty);\n\n                string systemPrompt = await BuildSystemPromptAsync(workingScript, latestUserPrompt, includeEditInstructions: true);\n                var messages = BuildConversationMessages(systemPrompt);\n\n                int historyCount = Mathf.Max(0, messages.Count - 1);\n                Debug.Log($\"[AI Edit] Using model: {config.model} (temp={config.temperature}, max_tokens={config.maxTokens})\");\n                Debug.Log($\"[AI Edit] Script chars: {workingScript.Length}, history messages: {historyCount}\");\n\n                return await SendChatCompletionAsync(messages, \"AI Edit\");\n            }\n            catch (System.Exception e)\n            {\n                Debug.LogError($\"Follow-up generation error: {e.Message}\");\n                return $\"# Error: {e.Message}\";\n            }\n        }\n\n    }\n}"
    },
    {
      "Source": "Assets/Scripts/SatieAPIKeyManager.cs",
      "Content": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Security.Cryptography;\nusing System.Text;\nusing UnityEngine;\n\nnamespace Satie\n{\n    /// <summary>\n    /// Centralized API key management system for all Satie services\n    /// Supports multiple providers, secure storage, and environment variables\n    /// </summary>\n    public static class SatieAPIKeyManager\n    {\n        public enum Provider\n        {\n            OpenAI,\n            ElevenLabs,\n            Anthropic,\n            Google,\n            Azure,\n            Custom\n        }\n\n        [System.Serializable]\n        public class APIKeyConfig\n        {\n            public Provider provider;\n            public string key;\n            public string endpoint;\n            public bool isValid;\n            public DateTime lastValidated;\n        }\n\n        [System.Serializable]\n        private class APIKeyStorage\n        {\n            public List<APIKeyConfig> keys = new List<APIKeyConfig>();\n            public bool encrypted;\n            public string encryptionCheck;\n        }\n\n        private static Dictionary<Provider, APIKeyConfig> _keyCache = new Dictionary<Provider, APIKeyConfig>();"
    },
    {
      "Source": "Assets/Scripts/SatieAPIKeyManager.cs",
      "Content": "public bool encrypted;\n            public string encryptionCheck;\n        }\n\n        private static Dictionary<Provider, APIKeyConfig> _keyCache = new Dictionary<Provider, APIKeyConfig>();\n        private static bool _initialized = false;\n        private static string _configPath;\n        private static byte[] _entropy;\n\n        private const string CONFIG_FILENAME = \"satie_api_keys.json\";\n        private const string ENV_PREFIX = \"SATIE_API_KEY_\";\n        private const string ENCRYPTION_CHECK = \"SATIE_ENCRYPTED_V1\";\n\n        static SatieAPIKeyManager()\n        {\n            Initialize();\n        }\n\n        private static void Initialize()\n        {\n            if (_initialized) return;\n\n            // Set config path - in persistent data path for security\n            _configPath = Path.Combine(Application.persistentDataPath, CONFIG_FILENAME);\n\n            // Generate machine-specific entropy for encryption\n            string machineId = SystemInfo.deviceUniqueIdentifier;\n            _entropy = Encoding.UTF8.GetBytes(machineId);\n\n            // Load existing keys\n            LoadKeys();\n\n            _initialized = true;\n        }\n\n        #region Public API"
    },
    {
      "Source": "Assets/Scripts/SatieAPIKeyManager.cs",
      "Content": "entifier;\n            _entropy = Encoding.UTF8.GetBytes(machineId);\n\n            // Load existing keys\n            LoadKeys();\n\n            _initialized = true;\n        }\n\n        #region Public API\n\n        /// <summary>\n        /// Get API key for a specific provider\n        /// </summary>\n        public static string GetKey(Provider provider)\n        {\n            Initialize();\n\n            // 1. Check environment variable first (highest priority)\n            string envKey = GetEnvironmentKey(provider);\n            if (!string.IsNullOrEmpty(envKey))\n            {\n                Debug.Log($\"[APIKeys] Using environment variable for {provider}\");\n                return envKey;\n            }\n\n            // 2. Check cached keys\n            if (_keyCache.TryGetValue(provider, out var config) && config.isValid)\n            {\n                return config.key;\n            }\n\n            // 3. Check legacy file locations for backward compatibility\n            string legacyKey = GetLegacyKey(provider);\n            if (!string.IsNullOrEmpty(legacyKey))\n            {\n                Debug.Log($\"[APIKeys] Migrating legacy key for {provider}\");\n                SetKey(provider, legacyKey);"
    },
    {
      "Source": "Assets/Scripts/SatieAPIKeyManager.cs",
      "Content": "ey(provider);\n            if (!string.IsNullOrEmpty(legacyKey))\n            {\n                Debug.Log($\"[APIKeys] Migrating legacy key for {provider}\");\n                SetKey(provider, legacyKey);\n                return legacyKey;\n            }\n\n            Debug.LogWarning($\"[APIKeys] No valid API key found for {provider}\");\n            return null;\n        }\n\n        /// <summary>\n        /// Set API key for a provider\n        /// </summary>\n        public static void SetKey(Provider provider, string key, string endpoint = null)\n        {\n            Initialize();\n\n            if (string.IsNullOrWhiteSpace(key))\n            {\n                Debug.LogError($\"[APIKeys] Cannot set empty key for {provider}\");\n                return;\n            }\n\n            var config = new APIKeyConfig\n            {\n                provider = provider,\n                key = key,\n                endpoint = endpoint ?? GetDefaultEndpoint(provider),\n                isValid = true,\n                lastValidated = DateTime.Now\n            };\n\n            _keyCache[provider] = config;\n            SaveKeys();\n\n            Debug.Log($\"[APIKeys] Key set for {provider}\");\n        }"
    },
    {
      "Source": "Assets/Scripts/SatieAPIKeyManager.cs",
      "Content": "lastValidated = DateTime.Now\n            };\n\n            _keyCache[provider] = config;\n            SaveKeys();\n\n            Debug.Log($\"[APIKeys] Key set for {provider}\");\n        }\n\n        /// <summary>\n        /// Remove API key for a provider\n        /// </summary>\n        public static void RemoveKey(Provider provider)\n        {\n            Initialize();\n\n            if (_keyCache.ContainsKey(provider))\n            {\n                _keyCache.Remove(provider);\n                SaveKeys();\n                Debug.Log($\"[APIKeys] Key removed for {provider}\");\n            }\n        }\n\n        /// <summary>\n        /// Check if a provider has a valid key\n        /// </summary>\n        public static bool HasKey(Provider provider)\n        {\n            Initialize();\n            return !string.IsNullOrEmpty(GetKey(provider));\n        }\n\n        /// <summary>\n        /// Get all configured providers\n        /// </summary>\n        public static List<Provider> GetConfiguredProviders()\n        {\n            Initialize();\n            return _keyCache.Keys.ToList();\n        }\n\n        /// <summary>\n        /// Get endpoint for a provider\n        /// </summary>"
    },
    {
      "Source": "Assets/Scripts/SatieAPIKeyManager.cs",
      "Content": "etConfiguredProviders()\n        {\n            Initialize();\n            return _keyCache.Keys.ToList();\n        }\n\n        /// <summary>\n        /// Get endpoint for a provider\n        /// </summary>\n        public static string GetEndpoint(Provider provider)\n        {\n            Initialize();\n\n            if (_keyCache.TryGetValue(provider, out var config))\n            {\n                return config.endpoint;\n            }\n\n            return GetDefaultEndpoint(provider);\n        }\n\n        /// <summary>\n        /// Validate all keys (async in real implementation)\n        /// </summary>\n        public static void ValidateAllKeys()\n        {\n            Initialize();\n\n            foreach (var kvp in _keyCache.ToList())\n            {\n                // In production, this would make API calls to validate\n                // For now, just check format\n                bool isValid = ValidateKeyFormat(kvp.Key, kvp.Value.key);\n\n                var config = kvp.Value;\n                config.isValid = isValid;\n                config.lastValidated = DateTime.Now;\n                _keyCache[kvp.Key] = config;\n            }\n\n            SaveKeys();\n        }\n\n        #endregion"
    },
    {
      "Source": "Assets/Scripts/SatieAPIKeyManager.cs",
      "Content": "config.isValid = isValid;\n                config.lastValidated = DateTime.Now;\n                _keyCache[kvp.Key] = config;\n            }\n\n            SaveKeys();\n        }\n\n        #endregion\n\n        #region Key Storage\n\n        private static void SaveKeys()\n        {\n            try\n            {\n                var storage = new APIKeyStorage\n                {\n                    keys = _keyCache.Values.ToList(),\n                    encrypted = true,\n                    encryptionCheck = ENCRYPTION_CHECK\n                };\n\n                // Encrypt sensitive data\n                foreach (var key in storage.keys)\n                {\n                    key.key = EncryptString(key.key);\n                }\n\n                string json = JsonUtility.ToJson(storage, true);\n                File.WriteAllText(_configPath, json);\n\n                Debug.Log($\"[APIKeys] Saved {storage.keys.Count} keys to {_configPath}\");\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"[APIKeys] Failed to save keys: {e.Message}\");\n            }\n        }\n\n        private static void LoadKeys()\n        {\n            try\n            {"
    },
    {
      "Source": "Assets/Scripts/SatieAPIKeyManager.cs",
      "Content": "e)\n            {\n                Debug.LogError($\"[APIKeys] Failed to save keys: {e.Message}\");\n            }\n        }\n\n        private static void LoadKeys()\n        {\n            try\n            {\n                if (!File.Exists(_configPath))\n                {\n                    Debug.Log($\"[APIKeys] No config file found at {_configPath}\");\n                    return;\n                }\n\n                string json = File.ReadAllText(_configPath);\n                var storage = JsonUtility.FromJson<APIKeyStorage>(json);\n\n                if (storage == null || storage.keys == null)\n                {\n                    Debug.LogWarning(\"[APIKeys] Invalid config file\");\n                    return;\n                }\n\n                // Decrypt keys\n                if (storage.encrypted && storage.encryptionCheck == ENCRYPTION_CHECK)\n                {\n                    foreach (var key in storage.keys)\n                    {\n                        try\n                        {\n                            key.key = DecryptString(key.key);\n                        }\n                        catch (Exception e)\n                        {"
    },
    {
      "Source": "Assets/Scripts/SatieAPIKeyManager.cs",
      "Content": "try\n                        {\n                            key.key = DecryptString(key.key);\n                        }\n                        catch (Exception e)\n                        {\n                            Debug.LogError($\"[APIKeys] Failed to decrypt key for {key.provider}: {e.Message}\");\n                            key.isValid = false;\n                        }\n                    }\n                }\n\n                // Populate cache\n                _keyCache.Clear();\n                foreach (var key in storage.keys)\n                {\n                    _keyCache[key.provider] = key;\n                }\n\n                Debug.Log($\"[APIKeys] Loaded {storage.keys.Count} keys\");\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"[APIKeys] Failed to load keys: {e.Message}\");\n            }\n        }\n\n        #endregion\n\n        #region Encryption\n\n        private static string EncryptString(string plainText)\n        {\n            if (string.IsNullOrEmpty(plainText)) return plainText;\n\n            try\n            {\n                // Use AES encryption for cross-platform compatibility"
    },
    {
      "Source": "Assets/Scripts/SatieAPIKeyManager.cs",
      "Content": "ng(string plainText)\n        {\n            if (string.IsNullOrEmpty(plainText)) return plainText;\n\n            try\n            {\n                // Use AES encryption for cross-platform compatibility\n                using (Aes aes = Aes.Create())\n                {\n                    // Derive key from machine ID and entropy\n                    var key = DeriveKey(_entropy);\n                    aes.Key = key;\n                    aes.GenerateIV();\n\n                    using (var encryptor = aes.CreateEncryptor())\n                    using (var msEncrypt = new MemoryStream())\n                    {\n                        // Prepend IV to the encrypted data\n                        msEncrypt.Write(aes.IV, 0, aes.IV.Length);\n\n                        using (var csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))\n                        using (var swEncrypt = new StreamWriter(csEncrypt))\n                        {\n                            swEncrypt.Write(plainText);\n                        }\n\n                        return Convert.ToBase64String(msEncrypt.ToArray());\n                    }\n                }\n            }\n            catch (Exception e)"
    },
    {
      "Source": "Assets/Scripts/SatieAPIKeyManager.cs",
      "Content": "lainText);\n                        }\n\n                        return Convert.ToBase64String(msEncrypt.ToArray());\n                    }\n                }\n            }\n            catch (Exception e)\n            {\n                Debug.LogWarning($\"[APIKeys] Encryption failed, using base64: {e.Message}\");\n                // Fallback to base64 if encryption fails\n                return \"B64:\" + Convert.ToBase64String(Encoding.UTF8.GetBytes(plainText));\n            }\n        }\n\n        private static string DecryptString(string cipherText)\n        {\n            if (string.IsNullOrEmpty(cipherText)) return cipherText;\n\n            try\n            {\n                // Check if it's base64 fallback\n                if (cipherText.StartsWith(\"B64:\"))\n                {\n                    byte[] bytes = Convert.FromBase64String(cipherText.Substring(4));\n                    return Encoding.UTF8.GetString(bytes);\n                }\n\n                // Decrypt AES encrypted data\n                byte[] cipherBytes = Convert.FromBase64String(cipherText);\n\n                using (Aes aes = Aes.Create())\n                {\n                    var key = DeriveKey(_entropy);"
    },
    {
      "Source": "Assets/Scripts/SatieAPIKeyManager.cs",
      "Content": "ed data\n                byte[] cipherBytes = Convert.FromBase64String(cipherText);\n\n                using (Aes aes = Aes.Create())\n                {\n                    var key = DeriveKey(_entropy);\n                    aes.Key = key;\n\n                    // Extract IV from the beginning of cipher text\n                    byte[] iv = new byte[aes.BlockSize / 8];\n                    Array.Copy(cipherBytes, 0, iv, 0, iv.Length);\n                    aes.IV = iv;\n\n                    using (var decryptor = aes.CreateDecryptor())\n                    using (var msDecrypt = new MemoryStream(cipherBytes, iv.Length, cipherBytes.Length - iv.Length))\n                    using (var csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))\n                    using (var srDecrypt = new StreamReader(csDecrypt))\n                    {\n                        return srDecrypt.ReadToEnd();\n                    }\n                }\n            }\n            catch (Exception e)\n            {\n                Debug.LogWarning($\"[APIKeys] Decryption failed: {e.Message}\");\n\n                // Try legacy base64 fallback\n                try\n                {"
    },
    {
      "Source": "Assets/Scripts/SatieAPIKeyManager.cs",
      "Content": "catch (Exception e)\n            {\n                Debug.LogWarning($\"[APIKeys] Decryption failed: {e.Message}\");\n\n                // Try legacy base64 fallback\n                try\n                {\n                    byte[] bytes = Convert.FromBase64String(cipherText);\n                    return Encoding.UTF8.GetString(bytes);\n                }\n                catch\n                {\n                    Debug.LogError($\"[APIKeys] All decryption methods failed for key\");\n                    return cipherText; // Return as-is if all decryption fails\n                }\n            }\n        }\n\n        private static byte[] DeriveKey(byte[] entropy)\n        {\n            // Use PBKDF2 to derive a 256-bit key from entropy\n            using (var pbkdf2 = new Rfc2898DeriveBytes(entropy, entropy, 10000))\n            {\n                return pbkdf2.GetBytes(32); // 256 bits\n            }\n        }\n\n        #endregion\n\n        #region Helper Methods\n\n        private static string GetEnvironmentKey(Provider provider)\n        {\n            string envVar = $\"{ENV_PREFIX}{provider.ToString().ToUpper()}\";\n            return Environment.GetEnvironmentVariable(envVar);\n        }"
    },
    {
      "Source": "Assets/Scripts/SatieAPIKeyManager.cs",
      "Content": "ng GetEnvironmentKey(Provider provider)\n        {\n            string envVar = $\"{ENV_PREFIX}{provider.ToString().ToUpper()}\";\n            return Environment.GetEnvironmentVariable(envVar);\n        }\n\n        private static string GetLegacyKey(Provider provider)\n        {\n            // Check old file locations for backward compatibility\n            string[] possiblePaths = provider switch\n            {\n                Provider.OpenAI => new[] { \"api_key.txt\", \"openai_key.txt\", \".env\" },\n                Provider.ElevenLabs => new[] { \"elevenlabs_key.txt\", \"eleven_labs_key.txt\" },\n                _ => new string[0]\n            };\n\n            foreach (string filename in possiblePaths)\n            {\n                string path = Path.Combine(Application.dataPath, filename);\n                if (File.Exists(path))\n                {\n                    try\n                    {\n                        string key = File.ReadAllText(path).Trim();\n\n                        // For .env files, parse the content\n                        if (filename == \".env\")\n                        {\n                            var lines = key.Split('\\n');"
    },
    {
      "Source": "Assets/Scripts/SatieAPIKeyManager.cs",
      "Content": "rim();\n\n                        // For .env files, parse the content\n                        if (filename == \".env\")\n                        {\n                            var lines = key.Split('\\n');\n                            foreach (var line in lines)\n                            {\n                                if (line.StartsWith($\"{provider.ToString().ToUpper()}_API_KEY=\"))\n                                {\n                                    return line.Split('=')[1].Trim();\n                                }\n                            }\n                        }\n                        else if (!string.IsNullOrWhiteSpace(key))\n                        {\n                            return key;\n                        }\n                    }\n                    catch (Exception e)\n                    {\n                        Debug.LogWarning($\"[APIKeys] Failed to read legacy key from {path}: {e.Message}\");\n                    }\n                }\n            }\n\n            return null;\n        }\n\n        private static string GetDefaultEndpoint(Provider provider)\n        {\n            return provider switch\n            {"
    },
    {
      "Source": "Assets/Scripts/SatieAPIKeyManager.cs",
      "Content": "}\n                }\n            }\n\n            return null;\n        }\n\n        private static string GetDefaultEndpoint(Provider provider)\n        {\n            return provider switch\n            {\n                Provider.OpenAI => \"https://api.openai.com/v1\",\n                Provider.ElevenLabs => \"https://api.elevenlabs.io/v1\",\n                Provider.Anthropic => \"https://api.anthropic.com/v1\",\n                Provider.Google => \"https://generativelanguage.googleapis.com/v1\",\n                Provider.Azure => \"\", // User must provide\n                _ => \"\"\n            };\n        }\n\n        private static bool ValidateKeyFormat(Provider provider, string key)\n        {\n            if (string.IsNullOrWhiteSpace(key)) return false;\n\n            return provider switch\n            {\n                Provider.OpenAI => key.StartsWith(\"sk-\") && key.Length > 20,\n                Provider.ElevenLabs => key.Length == 32, // ElevenLabs uses 32-char keys\n                Provider.Anthropic => key.StartsWith(\"sk-ant-\"),\n                Provider.Google => key.Length > 30, // Google API keys are typically 39 chars\n                _ => key.Length > 10 // Basic validation for unknown providers"
    },
    {
      "Source": "Assets/Scripts/SatieAPIKeyManager.cs",
      "Content": "key.StartsWith(\"sk-ant-\"),\n                Provider.Google => key.Length > 30, // Google API keys are typically 39 chars\n                _ => key.Length > 10 // Basic validation for unknown providers\n            };\n        }\n\n        #endregion\n\n        #region Migration Helper\n\n        /// <summary>\n        /// Migrate all legacy API keys to the new system\n        /// </summary>\n        public static void MigrateLegacyKeys()\n        {\n            int migrated = 0;\n\n            // Try to migrate each provider\n            foreach (Provider provider in Enum.GetValues(typeof(Provider)))\n            {\n                if (provider == Provider.Custom) continue;\n\n                string legacyKey = GetLegacyKey(provider);\n                if (!string.IsNullOrEmpty(legacyKey) && !HasKey(provider))\n                {\n                    SetKey(provider, legacyKey);\n                    migrated++;\n                    Debug.Log($\"[APIKeys] Migrated legacy key for {provider}\");\n                }\n            }\n\n            if (migrated > 0)\n            {\n                Debug.Log($\"[APIKeys] Successfully migrated {migrated} legacy keys\");\n            }\n        }\n\n        #endregion\n    }\n}"
    },
    {
      "Source": "Assets/Scripts/SatieAudioGen.cs",
      "Content": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing UnityEngine;\nusing UnityEngine.Networking;\n\nnamespace Satie\n{\n    public enum AudioProvider\n    {\n        AudioLDM2,\n        ElevenLabs,\n        Test\n    }\n\n    [System.Serializable]\n    public class AudioGenerationResult\n    {\n        public string prompt;\n        public string[] audioFilePaths;\n        public byte[][] audioData;\n        public int selectedIndex = -1;\n        public string timestamp;\n        public AudioProvider provider;\n    }\n\n    public class SatieAudioGen : MonoBehaviour\n    {\n        private static SatieAudioGen instance;\n        public static SatieAudioGen Instance\n        {\n            get\n            {\n                if (instance == null)\n                {\n                    var go = new GameObject(\"SatieAudioGen\");\n                    instance = go.AddComponent<SatieAudioGen>();\n                    DontDestroyOnLoad(go);\n                }\n                return instance;\n            }\n        }\n\n        // API Configuration\n        [Header(\"Server Configuration\")]"
    },
    {
      "Source": "Assets/Scripts/SatieAudioGen.cs",
      "Content": "dioGen>();\n                    DontDestroyOnLoad(go);\n                }\n                return instance;\n            }\n        }\n\n        // API Configuration\n        [Header(\"Server Configuration\")]\n        [SerializeField] private string apiUrl = \"http://localhost:5001/generate\"; // Multi-provider audio server\n        [SerializeField] private int sampleRate = 44100;\n        [SerializeField] private int numOptions = 1;\n        [SerializeField] private AudioProvider defaultProvider = AudioProvider.ElevenLabs;\n\n        [Header(\"Eleven Labs Settings\")]\n        [SerializeField] [Range(1f, 30f)] private float elevenLabsDuration = 10f;\n        [SerializeField] [Range(0f, 1f)] private float elevenLabsPromptInfluence = 0.3f;\n\n        [Header(\"AudioLDM2 Settings\")]\n        [SerializeField] [Range(50, 500)] private int audioldm2InferenceSteps = 200;\n        [SerializeField] [Range(1f, 30f)] private float audioldm2Duration = 10f;\n\n        // Cache for generated audio\n        private Dictionary<string, AudioGenerationResult> generationCache = new Dictionary<string, AudioGenerationResult>();\n\n        void Awake()\n        {\n            if (instance != null && instance != this)\n            {"
    },
    {
      "Source": "Assets/Scripts/SatieAudioGen.cs",
      "Content": "y<string, AudioGenerationResult> generationCache = new Dictionary<string, AudioGenerationResult>();\n\n        void Awake()\n        {\n            if (instance != null && instance != this)\n            {\n                Destroy(gameObject);\n                return;\n            }\n            instance = this;\n            DontDestroyOnLoad(gameObject);\n        }\n\n        public async Task<AudioGenerationResult> GenerateAudioOptions(string prompt, int numOptions = 2, AudioProvider? provider = null, System.Action<AudioGenerationResult, int> onOptionGenerated = null)\n        {\n            return await GenerateAudioOptionsInternal(prompt, numOptions, provider ?? defaultProvider, onOptionGenerated);\n        }\n\n        private async Task<AudioGenerationResult> GenerateAudioOptionsInternal(string prompt, int numOptions, AudioProvider provider, System.Action<AudioGenerationResult, int> onOptionGenerated)\n        {\n            if (string.IsNullOrWhiteSpace(prompt))\n            {\n                Debug.LogError(\"Cannot generate audio with empty prompt\");\n                return null;\n            }\n\n            // Check cache first (cache key includes provider)"
    },
    {
      "Source": "Assets/Scripts/SatieAudioGen.cs",
      "Content": "t))\n            {\n                Debug.LogError(\"Cannot generate audio with empty prompt\");\n                return null;\n            }\n\n            // Check cache first (cache key includes provider)\n            string cacheKey = $\"{provider}_{prompt}\";\n            if (generationCache.ContainsKey(cacheKey))\n            {\n                Debug.Log($\"Returning cached audio for prompt: {prompt} (provider: {provider})\");\n                return generationCache[cacheKey];\n            }\n\n            var result = new AudioGenerationResult\n            {\n                prompt = prompt,\n                audioFilePaths = new string[numOptions],\n                audioData = new byte[numOptions][],\n                timestamp = System.DateTime.Now.ToString(\"yyyyMMdd_HHmmss\"),\n                provider = provider\n            };\n\n            try\n            {\n                Debug.Log($\"[AudioGen] Generating {numOptions} audio options for prompt: {prompt} using {provider}\");\n\n                for (int i = 0; i < numOptions; i++)\n                {\n                    // Generate audio using selected provider\n                    byte[] audioData = await CallAudioGenerationAPI(prompt, i, provider);"
    },
    {
      "Source": "Assets/Scripts/SatieAudioGen.cs",
      "Content": "i = 0; i < numOptions; i++)\n                {\n                    // Generate audio using selected provider\n                    byte[] audioData = await CallAudioGenerationAPI(prompt, i, provider);\n\n                    if (audioData != null && audioData.Length > 0)\n                    {\n                        result.audioData[i] = audioData;\n                        Debug.Log($\"[AudioGen] Successfully generated option {i + 1}/{numOptions}\");\n\n                        // Notify callback that this option is ready\n                        onOptionGenerated?.Invoke(result, i);\n                    }\n                    else\n                    {\n                        Debug.LogWarning($\"[AudioGen] Failed to generate option {i + 1}/{numOptions}\");\n                    }\n                }\n\n                // Cache the result with provider-specific key\n                generationCache[cacheKey] = result;\n                return result;\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"[AudioGen] Error generating audio: {e.Message}\");\n                return null;\n            }\n        }"
    },
    {
      "Source": "Assets/Scripts/SatieAudioGen.cs",
      "Content": "t;\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"[AudioGen] Error generating audio: {e.Message}\");\n                return null;\n            }\n        }\n\n        private async Task<byte[]> CallAudioGenerationAPI(string prompt, int seed, AudioProvider provider)\n        {\n            try\n            {\n                // Create JSON request object\n                var requestData = new AudioGenerationRequest\n                {\n                    prompt = prompt,\n                    seed = seed,\n                    sample_rate = sampleRate,\n                    num_inference_steps = audioldm2InferenceSteps,\n                    audio_length_in_s = audioldm2Duration,\n                    provider = provider.ToString().ToLower(),\n                    // Eleven Labs specific parameters\n                    duration_seconds = elevenLabsDuration,\n                    prompt_influence = elevenLabsPromptInfluence\n                };\n\n                string jsonRequest = JsonUtility.ToJson(requestData);\n                Debug.Log($\"[AudioGen] Sending request to {apiUrl} with seed {seed} using provider {provider}\");"
    },
    {
      "Source": "Assets/Scripts/SatieAudioGen.cs",
      "Content": "};\n\n                string jsonRequest = JsonUtility.ToJson(requestData);\n                Debug.Log($\"[AudioGen] Sending request to {apiUrl} with seed {seed} using provider {provider}\");\n\n                using (UnityWebRequest request = new UnityWebRequest(apiUrl, \"POST\"))\n                {\n                    byte[] bodyRaw = System.Text.Encoding.UTF8.GetBytes(jsonRequest);\n                    request.uploadHandler = new UploadHandlerRaw(bodyRaw);\n                    request.downloadHandler = new DownloadHandlerBuffer();\n                    request.SetRequestHeader(\"Content-Type\", \"application/json\");\n\n                    // Send request\n                    var operation = request.SendWebRequest();\n\n                    // Wait for completion\n                    while (!operation.isDone)\n                    {\n                        await Task.Yield();\n                    }\n\n                    if (request.result != UnityWebRequest.Result.Success)\n                    {\n                        Debug.LogError($\"[AudioGen] API request failed: {request.error}\");\n                        Debug.LogError($\"[AudioGen] Response code: {request.responseCode}\");"
    },
    {
      "Source": "Assets/Scripts/SatieAudioGen.cs",
      "Content": "{\n                        Debug.LogError($\"[AudioGen] API request failed: {request.error}\");\n                        Debug.LogError($\"[AudioGen] Response code: {request.responseCode}\");\n\n                        // Check if server is running\n                        if (request.error.Contains(\"Cannot connect\"))\n                        {\n                            Debug.LogError(\"[AudioGen] Cannot connect to audio generation server. Please ensure the server is running:\");\n                            Debug.LogError(\"[AudioGen] 1. Install requirements: pip install -r requirements.txt\");\n                            Debug.LogError(\"[AudioGen] 2. Run server: python audio_generation_server.py\");\n                        }\n                        return null;\n                    }\n\n                    Debug.Log($\"[AudioGen] Successfully received audio data ({request.downloadHandler.data.Length} bytes)\");\n                    return request.downloadHandler.data;\n                }\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"[AudioGen] API call error: {e.Message}\");\n                return null;\n            }\n        }"
    },
    {
      "Source": "Assets/Scripts/SatieAudioGen.cs",
      "Content": "}\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"[AudioGen] API call error: {e.Message}\");\n                return null;\n            }\n        }\n\n        [System.Serializable]\n        private class AudioGenerationRequest\n        {\n            public string prompt;\n            public int seed;\n            public int sample_rate;\n            public int num_inference_steps;\n            public float audio_length_in_s;\n            public string provider;\n            // Eleven Labs specific\n            public float duration_seconds;\n            public float prompt_influence;\n        }\n\n        public async Task<string> SaveSelectedAudio(AudioGenerationResult result, int selectedIndex)\n        {\n            if (result == null || selectedIndex < 0 || selectedIndex >= result.audioData.Length)\n            {\n                Debug.LogError(\"Invalid audio selection\");\n                return null;\n            }\n\n            if (result.audioData[selectedIndex] == null || result.audioData[selectedIndex].Length == 0)\n            {\n                Debug.LogError(\"No audio data to save\");\n                return null;\n            }"
    },
    {
      "Source": "Assets/Scripts/SatieAudioGen.cs",
      "Content": "ult.audioData[selectedIndex] == null || result.audioData[selectedIndex].Length == 0)\n            {\n                Debug.LogError(\"No audio data to save\");\n                return null;\n            }\n\n            try\n            {\n                // Create filename based on prompt only (cleaner naming)\n                string sanitizedPrompt = SanitizeFileName(result.prompt);\n                // Limit prompt to first 30 characters for cleaner names\n                if (sanitizedPrompt.Length > 30)\n                    sanitizedPrompt = sanitizedPrompt.Substring(0, 30);\n                string fileName = $\"{sanitizedPrompt}.wav\";\n                string relativePath = Path.Combine(\"Assets\", \"Resources\", \"Audio\", \"generation\", fileName);\n                string fullPath = Path.Combine(Application.dataPath, \"Resources\", \"Audio\", \"generation\", fileName);\n\n                // Ensure directory exists\n                string directory = Path.GetDirectoryName(fullPath);\n                if (!Directory.Exists(directory))\n                {\n                    Directory.CreateDirectory(directory);\n                }\n\n                // Write audio data to file"
    },
    {
      "Source": "Assets/Scripts/SatieAudioGen.cs",
      "Content": "fullPath);\n                if (!Directory.Exists(directory))\n                {\n                    Directory.CreateDirectory(directory);\n                }\n\n                // Write audio data to file\n                await File.WriteAllBytesAsync(fullPath, result.audioData[selectedIndex]);\n\n                Debug.Log($\"[AudioGen] Saved audio to: {relativePath}\");\n\n                // Store the selected index\n                result.selectedIndex = selectedIndex;\n                result.audioFilePaths[selectedIndex] = relativePath;\n\n                // Refresh Unity asset database\n                #if UNITY_EDITOR\n                UnityEditor.AssetDatabase.Refresh();\n                #endif\n\n                return relativePath;\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"[AudioGen] Error saving audio: {e.Message}\");\n                return null;\n            }\n        }\n\n        public AudioClip ConvertBytesToAudioClip(byte[] audioData, string name = \"GeneratedAudio\")\n        {\n            if (audioData == null || audioData.Length == 0)\n            {\n                Debug.LogError(\"Cannot convert null or empty audio data\");"
    },
    {
      "Source": "Assets/Scripts/SatieAudioGen.cs",
      "Content": "dioData, string name = \"GeneratedAudio\")\n        {\n            if (audioData == null || audioData.Length == 0)\n            {\n                Debug.LogError(\"Cannot convert null or empty audio data\");\n                return null;\n            }\n\n            try\n            {\n                // Parse WAV file header and extract PCM data\n                WAVData wavData = ParseWAVData(audioData);\n                if (wavData == null)\n                {\n                    Debug.LogError(\"Failed to parse WAV data\");\n                    return null;\n                }\n\n                // Create AudioClip\n                AudioClip audioClip = AudioClip.Create(\n                    name,\n                    wavData.samples.Length / wavData.channels,\n                    wavData.channels,\n                    wavData.sampleRate,\n                    false\n                );\n\n                audioClip.SetData(wavData.samples, 0);\n                return audioClip;\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"[AudioGen] Error converting audio: {e.Message}\");\n                return null;\n            }\n        }\n\n        private class WAVData\n        {"
    },
    {
      "Source": "Assets/Scripts/SatieAudioGen.cs",
      "Content": "ption e)\n            {\n                Debug.LogError($\"[AudioGen] Error converting audio: {e.Message}\");\n                return null;\n            }\n        }\n\n        private class WAVData\n        {\n            public int channels;\n            public int sampleRate;\n            public float[] samples;\n        }\n\n        private WAVData ParseWAVData(byte[] wavFile)\n        {\n            try\n            {\n                // Basic WAV file parsing\n                // Skip to format chunk\n                int pos = 12; // Skip RIFF header\n\n                while (pos < wavFile.Length - 8)\n                {\n                    string chunkId = System.Text.Encoding.ASCII.GetString(wavFile, pos, 4);\n                    int chunkSize = BitConverter.ToInt32(wavFile, pos + 4);\n\n                    if (chunkId == \"fmt \")\n                    {\n                        // Parse format chunk\n                        var wavData = new WAVData();\n                        wavData.channels = BitConverter.ToInt16(wavFile, pos + 10);\n                        wavData.sampleRate = BitConverter.ToInt32(wavFile, pos + 12);\n                        int bitDepth = BitConverter.ToInt16(wavFile, pos + 22);"
    },
    {
      "Source": "Assets/Scripts/SatieAudioGen.cs",
      "Content": "rter.ToInt16(wavFile, pos + 10);\n                        wavData.sampleRate = BitConverter.ToInt32(wavFile, pos + 12);\n                        int bitDepth = BitConverter.ToInt16(wavFile, pos + 22);\n\n                        // Find data chunk\n                        pos += 8 + chunkSize;\n                        while (pos < wavFile.Length - 8)\n                        {\n                            chunkId = System.Text.Encoding.ASCII.GetString(wavFile, pos, 4);\n                            chunkSize = BitConverter.ToInt32(wavFile, pos + 4);\n\n                            if (chunkId == \"data\")\n                            {\n                                // Parse audio samples\n                                int sampleCount = chunkSize / (bitDepth / 8);\n                                wavData.samples = new float[sampleCount];\n\n                                int dataPos = pos + 8;\n                                if (bitDepth == 16)\n                                {\n                                    for (int i = 0; i < sampleCount; i++)\n                                    {\n                                        short sample = BitConverter.ToInt16(wavFile, dataPos + i * 2);"
    },
    {
      "Source": "Assets/Scripts/SatieAudioGen.cs",
      "Content": "for (int i = 0; i < sampleCount; i++)\n                                    {\n                                        short sample = BitConverter.ToInt16(wavFile, dataPos + i * 2);\n                                        wavData.samples[i] = sample / 32768f;\n                                    }\n                                }\n                                else if (bitDepth == 24)\n                                {\n                                    for (int i = 0; i < sampleCount; i++)\n                                    {\n                                        int sample = (wavFile[dataPos + i * 3] |\n                                                     (wavFile[dataPos + i * 3 + 1] << 8) |\n                                                     (wavFile[dataPos + i * 3 + 2] << 16));\n                                        if ((sample & 0x800000) != 0)\n                                            sample |= unchecked((int)0xFF000000);\n                                        wavData.samples[i] = sample / 8388608f;\n                                    }\n                                }\n\n                                return wavData;\n                            }"
    },
    {
      "Source": "Assets/Scripts/SatieAudioGen.cs",
      "Content": "wavData.samples[i] = sample / 8388608f;\n                                    }\n                                }\n\n                                return wavData;\n                            }\n\n                            pos += 8 + chunkSize;\n                        }\n\n                        break;\n                    }\n\n                    pos += 8 + chunkSize;\n                }\n\n                return null;\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"Error parsing WAV: {e.Message}\");\n                return null;\n            }\n        }\n\n        private string SanitizeFileName(string fileName)\n        {\n            // Remove invalid characters for file names\n            string invalid = new string(Path.GetInvalidFileNameChars());\n            string sanitized = fileName;\n\n            foreach (char c in invalid)\n            {\n                sanitized = sanitized.Replace(c.ToString(), \"_\");\n            }\n\n            // Limit length\n            if (sanitized.Length > 50)\n            {\n                sanitized = sanitized.Substring(0, 50);\n            }\n\n            return sanitized.Replace(\" \", \"_\").ToLower();\n        }"
    },
    {
      "Source": "Assets/Scripts/SatieAudioGen.cs",
      "Content": "length\n            if (sanitized.Length > 50)\n            {\n                sanitized = sanitized.Substring(0, 50);\n            }\n\n            return sanitized.Replace(\" \", \"_\").ToLower();\n        }\n\n        public void ClearCache()\n        {\n            generationCache.Clear();\n            Debug.Log(\"[AudioGen] Cache cleared\");\n        }\n\n        public List<string> GetGeneratedAudioFiles()\n        {\n            string generationPath = Path.Combine(Application.dataPath, \"Resources\", \"Audio\", \"generation\");\n\n            if (!Directory.Exists(generationPath))\n            {\n                return new List<string>();\n            }\n\n            var files = Directory.GetFiles(generationPath, \"*.wav\")\n                .Select(f => Path.GetFileName(f))\n                .OrderByDescending(f => File.GetCreationTime(Path.Combine(generationPath, f)))\n                .ToList();\n\n            return files;\n        }\n\n        public void SetDefaultProvider(AudioProvider provider)\n        {\n            defaultProvider = provider;\n            Debug.Log($\"[AudioGen] Default provider set to: {provider}\");\n        }\n\n        public AudioProvider GetDefaultProvider()\n        {"
    },
    {
      "Source": "Assets/Scripts/SatieAudioGen.cs",
      "Content": "der)\n        {\n            defaultProvider = provider;\n            Debug.Log($\"[AudioGen] Default provider set to: {provider}\");\n        }\n\n        public AudioProvider GetDefaultProvider()\n        {\n            return defaultProvider;\n        }\n\n        public async Task<bool> CheckServerHealth()\n        {\n            try\n            {\n                string healthUrl = apiUrl.Replace(\"/generate\", \"/health\");\n                using (UnityWebRequest request = UnityWebRequest.Get(healthUrl))\n                {\n                    var operation = request.SendWebRequest();\n\n                    while (!operation.isDone)\n                    {\n                        await Task.Yield();\n                    }\n\n                    if (request.result == UnityWebRequest.Result.Success)\n                    {\n                        Debug.Log($\"[AudioGen] Server health check: {request.downloadHandler.text}\");\n                        return true;\n                    }\n                    else\n                    {\n                        Debug.LogError($\"[AudioGen] Server health check failed: {request.error}\");\n                        return false;\n                    }\n                }"
    },
    {
      "Source": "Assets/Scripts/SatieAudioGen.cs",
      "Content": "{\n                        Debug.LogError($\"[AudioGen] Server health check failed: {request.error}\");\n                        return false;\n                    }\n                }\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"[AudioGen] Health check error: {e.Message}\");\n                return false;\n            }\n        }\n\n        public void SetApiUrl(string url)\n        {\n            apiUrl = url;\n            Debug.Log($\"[AudioGen] API URL set to: {url}\");\n        }\n\n        public string GetApiUrl()\n        {\n            return apiUrl;\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Scripts/SatieParser.cs",
      "Content": "using System.Collections.Generic;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing UnityEngine;\n\nnamespace Satie\n{\n    public sealed class Statement\n    {\n        public string kind;\n        public string clip;\n        public int    count = 1;\n        public RangeOrValue starts_at = RangeOrValue.Zero;\n        public RangeOrValue duration = RangeOrValue.Null;\n        public RangeOrValue every = RangeOrValue.Zero;\n        public RangeOrValue volume = new(1f);\n        public RangeOrValue pitch = new(1f);\n        public bool overlap = false;\n        public RangeOrValue fade_in = RangeOrValue.Null;\n        public RangeOrValue fade_out = RangeOrValue.Null;\n\n        public enum WanderType { None, Walk, Fly, Fixed }\n        public WanderType wanderType = WanderType.None;\n        public Vector3 areaMin, areaMax;\n        public RangeOrValue wanderHz = new(0.3f);\n\n        public List<string> visual = new();\n    }\n\n    public readonly struct RangeOrValue\n    {\n        public readonly float min, max;\n        public readonly bool  isRange, isSet;\n\n        public static readonly RangeOrValue Zero = new(0f);\n        public static readonly RangeOrValue Null = default;"
    },
    {
      "Source": "Assets/Scripts/SatieParser.cs",
      "Content": "public readonly float min, max;\n        public readonly bool  isRange, isSet;\n\n        public static readonly RangeOrValue Zero = new(0f);\n        public static readonly RangeOrValue Null = default;\n\n        public RangeOrValue(float v) { min = max = v; isRange = false; isSet = true; }\n        public RangeOrValue(float a, float b) { min = a; max = b; isRange = true;  isSet = true; }\n\n        public float Sample() => !isSet ? 0f : isRange ? Random.Range(min, max) : min;\n\n        public static RangeOrValue Parse(string s)\n        {\n            if (string.IsNullOrWhiteSpace(s)) return Null;\n            if (s.Contains(\"to\"))\n            {\n                var p = s.Split(new[] { \"to\" }, System.StringSplitOptions.None);\n                return new(float.Parse(p[0]), float.Parse(p[1]));\n            }\n            return new(float.Parse(s));\n        }\n\n        public RangeOrValue Mul(float k) =>\n            !isSet ? this : isRange ? new(min * k, max * k) : new(min * k);\n    }\n\n    // parser\n    public static class SatieParser\n    {\n        static readonly Regex StmtRx = new("
    },
    {
      "Source": "Assets/Scripts/SatieParser.cs",
      "Content": "Mul(float k) =>\n            !isSet ? this : isRange ? new(min * k, max * k) : new(min * k);\n    }\n\n    // parser\n    public static class SatieParser\n    {\n        static readonly Regex StmtRx = new(\n            @\"^(?:(?<count>\\d+)\\s*\\*\\s*)?(?<kind>loop|oneshot)\\s+\"\"(?<clip>.+?)\"\"\\s*(?:every\\s+(?<e1>-?\\d+\\.?\\d*)to(?<e2>-?\\d+\\.?\\d*))?\\s*:\\s*\\r?\\n\" +\n            @\"(?<block>(?:[ \\t]+.*\\r?\\n?)*)\",\n            RegexOptions.Multiline | RegexOptions.IgnoreCase | RegexOptions.Compiled);\n\n        // pattern to recognise the start of a statement line, with optional count prefix\n        static readonly Regex StmtStartRx = new(\n            @\"^(?:\\d+\\s*\\*\\s*)?(?:loop|oneshot)\\b\",\n            RegexOptions.IgnoreCase | RegexOptions.Compiled);\n\n        static readonly Regex PropRx = new(\n            @\"^[ \\t]*(?<key>\\w+)\\s*=\\s*(?<val>[^\\r\\n#]+)\",\n            RegexOptions.Multiline | RegexOptions.Compiled);\n\n        sealed class GroupCtx\n        {\n            public readonly Dictionary<string,string> props = new();\n            public readonly List<Statement> children = new();\n            public int indent;\n        }\n\n        // Parse\n        public static List<Statement> Parse(string script)"
    },
    {
      "Source": "Assets/Scripts/SatieParser.cs",
      "Content": "ing> props = new();\n            public readonly List<Statement> children = new();\n            public int indent;\n        }\n\n        // Parse\n        public static List<Statement> Parse(string script)\n        {\n            var outList = new List<Statement>();\n            var lines   = script.Replace(\"\\r\\n\", \"\\n\").Split('\\n');\n\n            GroupCtx grp = null;\n\n            for (int i = 0; i < lines.Length; ++i)\n            {\n                string raw  = lines[i];\n                if (string.IsNullOrWhiteSpace(raw) || raw.TrimStart().StartsWith(\"#\"))\n                    continue;\n\n                int    indent = CountIndent(raw);\n                string body   = raw.TrimStart();\n\n                //  close grp?\n                if (grp != null &&\n                    indent == grp.indent &&\n                    (StmtStartRx.IsMatch(body) ||\n                     body.StartsWith(\"group \",  true, null) ||\n                     body.StartsWith(\"endgroup\",true, null)))\n                {\n                    FlushGroup(outList, grp);\n                    grp = null;\n                }\n                if (grp != null && body.StartsWith(\"endgroup\", true, null))"
    },
    {
      "Source": "Assets/Scripts/SatieParser.cs",
      "Content": ", null)))\n                {\n                    FlushGroup(outList, grp);\n                    grp = null;\n                }\n                if (grp != null && body.StartsWith(\"endgroup\", true, null))\n                    continue; // don't treat \"endgroup\" as a statement\n\n                // open group\n                if (body.StartsWith(\"group \", true, null) && body.TrimEnd().EndsWith(\":\"))\n                {\n                    grp = new GroupCtx { indent = indent };\n                    continue;\n                }\n\n                // statement\n                if (StmtStartRx.IsMatch(body))\n                {\n                    int stmtIndent = indent;\n                    var sb = new StringBuilder();\n                    sb.AppendLine(body);\n\n                    int j = i + 1;\n                    while (j < lines.Length && CountIndent(lines[j]) > stmtIndent)\n                    {\n                        sb.AppendLine(lines[j]);\n                        ++j;\n                    }\n                    i = j - 1;\n\n                    var st = ParseSingle(sb.ToString());\n                    if (grp != null) grp.children.Add(st); else outList.Add(st);\n                    continue;"
    },
    {
      "Source": "Assets/Scripts/SatieParser.cs",
      "Content": "i = j - 1;\n\n                    var st = ParseSingle(sb.ToString());\n                    if (grp != null) grp.children.Add(st); else outList.Add(st);\n                    continue;\n                }\n\n                //  property\n                if (grp != null && PropRx.IsMatch(body))\n                {\n                    var m = PropRx.Match(body);\n                    string k = m.Groups[\"key\"].Value.ToLower();\n                    if (k is \"move\" or \"visual\")\n                        Debug.LogWarning($\"[Satie] '{k}' not allowed on a group \u2013 ignored.\");\n                    else\n                        grp.props[k] = m.Groups[\"val\"].Value.Trim();\n                    continue;\n                }\n\n                Debug.LogWarning($\"[Satie] Unrecognised line: '{body}'\");\n            }\n\n            if (grp != null) FlushGroup(outList, grp);\n            return outList;\n        }\n\n        //  PathFor\n        public static string PathFor(string clip)\n        {\n            if (string.IsNullOrWhiteSpace(clip)) return string.Empty;\n            string c = clip.Replace('\\\\','/').TrimStart('/');\n            int dot = c.LastIndexOf('.');\n            if (dot >= 0) c = c[..dot];"
    },
    {
      "Source": "Assets/Scripts/SatieParser.cs",
      "Content": "(string.IsNullOrWhiteSpace(clip)) return string.Empty;\n            string c = clip.Replace('\\\\','/').TrimStart('/');\n            int dot = c.LastIndexOf('.');\n            if (dot >= 0) c = c[..dot];\n            if (!c.StartsWith(\"Audio/\")) c = $\"Audio/{c}\";\n            return c;\n        }\n\n        // helpers\n        static Statement ParseSingle(string block)\n        {\n            var m = StmtRx.Match(block);\n            var s = new Statement\n            {\n                kind = m.Groups[\"kind\"].Value.ToLower(),\n                clip = m.Groups[\"clip\"].Value.Trim(),\n                count = m.Groups[\"count\"].Success ? int.Parse(m.Groups[\"count\"].Value) : 1\n            };\n\n            if (m.Groups[\"e1\"].Success)\n                s.every = new RangeOrValue(\n                    float.Parse(m.Groups[\"e1\"].Value),\n                    float.Parse(m.Groups[\"e2\"].Value));\n\n            foreach (Match p in PropRx.Matches(m.Groups[\"block\"].Value))\n            {\n                string k = p.Groups[\"key\"].Value.ToLower();\n                string v = p.Groups[\"val\"].Value.Trim();\n                switch (k)\n                {\n                    case \"volume\": s.volume = RangeOrValue.Parse(v); break;"
    },
    {
      "Source": "Assets/Scripts/SatieParser.cs",
      "Content": "ey\"].Value.ToLower();\n                string v = p.Groups[\"val\"].Value.Trim();\n                switch (k)\n                {\n                    case \"volume\": s.volume = RangeOrValue.Parse(v); break;\n                    case \"pitch\": s.pitch = RangeOrValue.Parse(v); break;\n                    case \"starts_at\": s.starts_at = RangeOrValue.Parse(v); break;\n                    case \"duration\": s.duration = RangeOrValue.Parse(v); break;\n                    case \"fade_in\": s.fade_in = RangeOrValue.Parse(v); break;\n                    case \"fade_out\": s.fade_out = RangeOrValue.Parse(v); break;\n                    case \"every\": s.every = RangeOrValue.Parse(v); break;\n                    case \"overlap\": s.overlap = v.ToLower().StartsWith(\"t\"); break;\n                    case \"visual\": ParseVisual(s, v); break;\n                    case \"move\": ParseMove(s,v); break;\n                }\n            }\n            return s;\n        }\n\n        static void FlushGroup(List<Statement> dst, GroupCtx g)\n        {\n            bool hasVol = g.props.TryGetValue(\"volume\", out string vRaw);\n            bool hasPitch = g.props.TryGetValue(\"pitch\",  out string pRaw);"
    },
    {
      "Source": "Assets/Scripts/SatieParser.cs",
      "Content": "hGroup(List<Statement> dst, GroupCtx g)\n        {\n            bool hasVol = g.props.TryGetValue(\"volume\", out string vRaw);\n            bool hasPitch = g.props.TryGetValue(\"pitch\",  out string pRaw);\n            RangeOrValue gVolRange = hasVol ? RangeOrValue.Parse(vRaw) : new RangeOrValue(1f);\n            RangeOrValue gPitchRange = hasPitch ? RangeOrValue.Parse(pRaw) : new RangeOrValue(1f);\n\n            foreach (var s in g.children)\n            {\n                // Volume and pitch multiply with group values\n                // Sample per statement so each gets its own random value if group has a range\n                float gVol = gVolRange.Sample();\n                float gPitch = gPitchRange.Sample();\n                \n                if (hasVol) s.volume = s.volume.isSet ? s.volume.Mul(gVol) : new RangeOrValue(gVol);\n                if (hasPitch) s.pitch = s.pitch.isSet  ? s.pitch .Mul(gPitch) : new RangeOrValue(gPitch);\n\n                foreach (var kv in g.props)\n                {\n                    switch (kv.Key)\n                    {\n                        case \"volume\":\n                        case \"pitch\": break;   // done above"
    },
    {
      "Source": "Assets/Scripts/SatieParser.cs",
      "Content": "ach (var kv in g.props)\n                {\n                    switch (kv.Key)\n                    {\n                        case \"volume\":\n                        case \"pitch\": break;   // done above\n                        case \"starts_at\" when !s.starts_at.isSet: s.starts_at = RangeOrValue.Parse(kv.Value); break;\n                        case \"duration\" when !s.duration.isSet: s.duration = RangeOrValue.Parse(kv.Value); break;\n                        case \"fade_in\" when !s.fade_in.isSet: s.fade_in = RangeOrValue.Parse(kv.Value); break;\n                        case \"fade_out\" when !s.fade_out.isSet: s.fade_out = RangeOrValue.Parse(kv.Value); break;\n                        case \"every\" when !s.every.isSet: s.every = RangeOrValue.Parse(kv.Value); break;\n                        case \"overlap\": s.overlap = kv.Value.ToLower().StartsWith(\"t\"); break;\n                    }\n                }\n                dst.Add(s);\n            }\n        }\n\n        static int CountIndent(string line)\n        {\n            int n = 0; while (n < line.Length && (line[n]==' ' || line[n]=='\\t')) ++n; return n;\n        }\n\n        static void ParseMove(Statement s,string v)\n        {"
    },
    {
      "Source": "Assets/Scripts/SatieParser.cs",
      "Content": "Indent(string line)\n        {\n            int n = 0; while (n < line.Length && (line[n]==' ' || line[n]=='\\t')) ++n; return n;\n        }\n\n        static void ParseMove(Statement s,string v)\n        {\n            string[] t = v.Split(',');\n            if (t.Length < 4) { Debug.LogError(\"move: not enough parameters\"); return; }\n\n            static (float,float) R(string str)\n            {\n                if (str.Contains(\"to\")) { var p=str.Split(new[] { \"to\" }, System.StringSplitOptions.None); return (float.Parse(p[0]),float.Parse(p[1])); }\n                float f=float.Parse(str); return (f,f);\n            }\n\n            string mode=t[0].Trim().ToLower();\n            if (mode==\"walk\" && t.Length==4)\n            {\n                var (xmin,xmax)=R(t[1]); var (zmin,zmax)=R(t[2]);\n                s.wanderType=Statement.WanderType.Walk;\n                s.areaMin=new Vector3(xmin,0f,zmin); s.areaMax=new Vector3(xmax,0f,zmax);\n                s.wanderHz=RangeOrValue.Parse(t[3]);\n            }\n            else if (mode==\"fly\" && t.Length==5)\n            {\n                var (xmin,xmax)=R(t[1]); var (ymin,ymax)=R(t[2]); var (zmin,zmax)=R(t[3]);"
    },
    {
      "Source": "Assets/Scripts/SatieParser.cs",
      "Content": "derHz=RangeOrValue.Parse(t[3]);\n            }\n            else if (mode==\"fly\" && t.Length==5)\n            {\n                var (xmin,xmax)=R(t[1]); var (ymin,ymax)=R(t[2]); var (zmin,zmax)=R(t[3]);\n                s.wanderType=Statement.WanderType.Fly;\n                s.areaMin=new Vector3(xmin,ymin,zmin); s.areaMax=new Vector3(xmax,ymax,zmax);\n                s.wanderHz=RangeOrValue.Parse(t[4]);\n            }\n            else if (mode==\"pos\" && t.Length==4)\n            {\n                var (xmin,xmax)=R(t[1]); var (ymin,ymax)=R(t[2]); var (zmin,zmax)=R(t[3]);\n                s.wanderType=Statement.WanderType.Fixed;\n                s.areaMin=new Vector3(xmin,ymin,zmin); s.areaMax=new Vector3(xmax,ymax,zmax);\n            }\n            else Debug.LogError($\"move: bad syntax '{v}'\");\n        }\n\n        static void ParseVisual(Statement s, string v)\n        {\n            v = v.Trim();\n            if (string.IsNullOrWhiteSpace(v)) return;\n\n            // Split by \"and\" to support multiple visuals\n            string[] parts = v.Split(new[] { \" and \" }, System.StringSplitOptions.RemoveEmptyEntries);\n            \n            foreach (string part in parts)\n            {"
    },
    {
      "Source": "Assets/Scripts/SatieParser.cs",
      "Content": "o support multiple visuals\n            string[] parts = v.Split(new[] { \" and \" }, System.StringSplitOptions.RemoveEmptyEntries);\n            \n            foreach (string part in parts)\n            {\n                string trimmed = part.Trim();\n                \n                // Check for object \"path\" syntax\n                if (trimmed.StartsWith(\"object \", System.StringComparison.OrdinalIgnoreCase))\n                {\n                    // Extract the quoted path\n                    var match = Regex.Match(trimmed, @\"object\\s+\"\"(.+?)\"\"\");\n                    if (match.Success)\n                    {\n                        s.visual.Add($\"object:{match.Groups[1].Value}\");\n                    }\n                    else\n                    {\n                        Debug.LogWarning($\"[Satie] Invalid object syntax: '{trimmed}'\");\n                    }\n                }\n                else\n                {\n                    // It's a primitive type (trail, sphere, cube, etc.)\n                    s.visual.Add(trimmed.ToLower());\n                }\n            }\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Scripts/SatieRuntime.cs",
      "Content": "using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Satie;\n\npublic class SatieRuntime : MonoBehaviour\n{\n    [Tooltip(\".sp script (TextAsset)\")]\n    [SerializeField] private TextAsset scriptFile;\n    public TextAsset ScriptFile => scriptFile;\n\n    private readonly List<AudioSource> spawned  = new();\n    private readonly List<Coroutine>   schedulers = new();\n\n    // Components\n    private SatieSpatialAudio spatialAudio;\n    \n    void Start()\n    {\n        if (!scriptFile)\n        {\n            Debug.LogError(\"SatieRuntime: TextAsset missing.\");\n            return;\n        }\n\n        // Get spatial audio component\n        spatialAudio = GetComponent<SatieSpatialAudio>();\n\n        Sync(fullReset: true);\n    }\n\n#if UNITY_EDITOR\n    void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.R) && !Input.GetKey(KeyCode.LeftShift)) Sync(false);\n        if (Input.GetKeyDown(KeyCode.R) &&  Input.GetKey(KeyCode.LeftShift)) Sync(true);\n    }\n#endif\n    \n    public void Sync(bool fullReset)\n    {\n        if (fullReset) HardReset();\n\n        foreach (var stmt in SatieParser.Parse(scriptFile.text))\n            for (int i = 0; i < Mathf.Max(1, stmt.count); ++i)"
    },
    {
      "Source": "Assets/Scripts/SatieRuntime.cs",
      "Content": "ic void Sync(bool fullReset)\n    {\n        if (fullReset) HardReset();\n\n        foreach (var stmt in SatieParser.Parse(scriptFile.text))\n            for (int i = 0; i < Mathf.Max(1, stmt.count); ++i)\n                schedulers.Add(StartCoroutine(RunStmt(stmt)));\n\n        Debug.Log($\"[SP] Synced ({(fullReset ? \"full\" : \"delta\")}).\");\n    }\n\n    IEnumerator RunStmt(Statement s)\n    {\n        yield return new WaitForSeconds(s.starts_at.Sample());\n        if (s.kind == \"loop\")  yield return HandleLoop(s);\n        else yield return HandleOneShot(s);\n    }\n    \n    IEnumerator HandleLoop(Statement s)\n    {\n        var src = SpawnSource(s);\n        if (!src) yield break;\n\n        if (s.duration.isSet)\n        {\n            float fadeOut = s.fade_out.Sample();\n            yield return StopAfter(src, s.duration.Sample(), fadeOut);\n        }\n    }\n    \n    IEnumerator HandleOneShot(Statement s)\n    {\n        AudioSource persistent = null;\n\n        while (true)\n        {\n            if (s.overlap)\n            {\n                var src = SpawnSource(s);\n                if (!src) yield break;\n            }\n            else\n            {\n                if (persistent == null)\n                {"
    },
    {
      "Source": "Assets/Scripts/SatieRuntime.cs",
      "Content": ")\n            {\n                var src = SpawnSource(s);\n                if (!src) yield break;\n            }\n            else\n            {\n                if (persistent == null)\n                {\n                    persistent = SpawnSource(s);\n                    if (!persistent) yield break;\n                }\n\n                string clipName = SatieUtil.ResolveClip(s.clip);\n                var newClip = Resources.Load<AudioClip>(SatieParser.PathFor(clipName));\n                if (!newClip) { Debug.LogWarning($\"[Satie] Audio clip '{clipName}' missing.\"); yield break; }\n\n                persistent.clip = newClip;\n                persistent.pitch = s.pitch.Sample();\n                float targetVol  = s.volume.Sample();\n\n                StartCoroutine(Fade(persistent, 0f, targetVol, s.fade_in.Sample()));\n\n                persistent.time = 0f;\n                persistent.Play();\n\n                float fadeOut = s.fade_out.Sample();\n                if (fadeOut > 0f)\n                    StartCoroutine(StopAfter(persistent, persistent.clip.length, fadeOut));\n            }\n\n            yield return new WaitForSeconds(s.every.Sample());\n        }\n    }"
    },
    {
      "Source": "Assets/Scripts/SatieRuntime.cs",
      "Content": "ut > 0f)\n                    StartCoroutine(StopAfter(persistent, persistent.clip.length, fadeOut));\n            }\n\n            yield return new WaitForSeconds(s.every.Sample());\n        }\n    }\n    \n    AudioSource SpawnSource(Statement s)\n    {\n        string clipName = SatieUtil.ResolveClip(s.clip);\n        var clip = Resources.Load<AudioClip>(SatieParser.PathFor(clipName));\n        if (!clip)\n        {\n            Debug.LogWarning($\"[Satie] Audio clip '{clipName}' not found. \"\n                             + $\"Looked for Resources/{SatieParser.PathFor(clipName)}.*\");\n            return null;\n        }\n        \n        var go = new GameObject($\"[SP] {clipName}\");\n        go.transform.SetParent(transform);\n\n        var src = go.AddComponent<AudioSource>();\n        spawned.Add(src);\n\n        src.clip = clip;\n        src.loop = (s.kind == \"loop\");\n        src.volume = 0f;\n        src.pitch = s.pitch.Sample();\n\n        // Configure spatial audio using the spatial audio component\n        bool is3D = s.wanderType != Statement.WanderType.None;\n        if (spatialAudio != null)\n        {\n            spatialAudio.ConfigureAudioSource(src, is3D);\n        }\n        else\n        {"
    },
    {
      "Source": "Assets/Scripts/SatieRuntime.cs",
      "Content": "t\n        bool is3D = s.wanderType != Statement.WanderType.None;\n        if (spatialAudio != null)\n        {\n            spatialAudio.ConfigureAudioSource(src, is3D);\n        }\n        else\n        {\n            // Fallback configuration if no spatial audio component\n            src.spatialBlend = is3D ? 1f : 0f;\n            if (is3D)\n            {\n                src.spatialize = true;\n                src.spatializePostEffects = true;\n                src.dopplerLevel = 0.5f;\n                src.spread = 0f;\n                src.rolloffMode = AudioRolloffMode.Logarithmic;\n                src.minDistance = 1f;\n                src.maxDistance = 100f;\n            }\n        }\n        \n        src.Play();\n\n        if (s.wanderType == Statement.WanderType.Walk ||\n            s.wanderType == Statement.WanderType.Fly)\n        {\n            var mover = go.AddComponent<SSpatial>();\n            mover.type = s.wanderType;\n            mover.minPos = s.areaMin;\n            mover.maxPos = s.areaMax;\n            mover.hz = s.wanderHz.Sample();\n        }\n        else if (s.wanderType == Statement.WanderType.Fixed)\n        {\n            UnityEngine.Vector3 p = new UnityEngine.Vector3("
    },
    {
      "Source": "Assets/Scripts/SatieRuntime.cs",
      "Content": "= s.areaMax;\n            mover.hz = s.wanderHz.Sample();\n        }\n        else if (s.wanderType == Statement.WanderType.Fixed)\n        {\n            UnityEngine.Vector3 p = new UnityEngine.Vector3(\n                Random.Range(s.areaMin.x, s.areaMax.x),\n                Random.Range(s.areaMin.y, s.areaMax.y),\n                Random.Range(s.areaMin.z, s.areaMax.z));\n            go.transform.position = p;\n        }\n\n        AddVisuals(go, s);\n\n        // Add Steam Audio components if available and source is spatialized\n        if (spatialAudio != null && s.wanderType != Statement.WanderType.None)\n        {\n            spatialAudio.AddSteamAudioComponents(go);\n        }\n\n        StartCoroutine(Fade(src, 0f, s.volume.Sample(), s.fade_in.Sample()));\n        return src;\n    }\n\n    void AddVisuals(GameObject go, Statement s)\n    {\n        foreach (string visual in s.visual)\n        {\n            if (visual.StartsWith(\"object:\"))\n            {\n                // Load prefab from Resources\n                string prefabPath = visual.Substring(7); // Remove \"object:\" prefix\n                string fullPath = $\"Prefabs/{SatieUtil.ResolveClip(prefabPath)}\";"
    },
    {
      "Source": "Assets/Scripts/SatieRuntime.cs",
      "Content": "// Load prefab from Resources\n                string prefabPath = visual.Substring(7); // Remove \"object:\" prefix\n                string fullPath = $\"Prefabs/{SatieUtil.ResolveClip(prefabPath)}\";\n                GameObject prefab = Resources.Load<GameObject>(fullPath);\n                \n                if (prefab != null)\n                {\n                    GameObject instance = Instantiate(prefab, go.transform);\n                    instance.transform.localPosition = UnityEngine.Vector3.zero;\n                }\n                else\n                {\n                    Debug.LogWarning($\"[Satie] Prefab '{fullPath}' not found in Resources.\");\n                }\n            }\n            else\n            {\n                // Handle primitive visuals\n                switch (visual)\n                {\n                    case \"trail\":\n                        AddTrail(go);\n                        break;\n                    case \"sphere\":\n                        AddPrimitive(go, PrimitiveType.Sphere);\n                        break;\n                    case \"cube\":\n                        AddPrimitive(go, PrimitiveType.Cube);\n                        break;"
    },
    {
      "Source": "Assets/Scripts/SatieRuntime.cs",
      "Content": "AddPrimitive(go, PrimitiveType.Sphere);\n                        break;\n                    case \"cube\":\n                        AddPrimitive(go, PrimitiveType.Cube);\n                        break;\n                    case \"cylinder\":\n                        AddPrimitive(go, PrimitiveType.Cylinder);\n                        break;\n                    case \"capsule\":\n                        AddPrimitive(go, PrimitiveType.Capsule);\n                        break;\n                    case \"plane\":\n                        AddPrimitive(go, PrimitiveType.Plane);\n                        break;\n                    case \"quad\":\n                        AddPrimitive(go, PrimitiveType.Quad);\n                        break;\n                    default:\n                        Debug.LogWarning($\"[Satie] Unknown visual type: '{visual}'\");\n                        break;\n                }\n            }\n        }\n    }\n\n    void AddTrail(GameObject go)\n    {\n        var tr = go.AddComponent<TrailRenderer>();\n        tr.widthMultiplier = 0.1f;\n        tr.time = 5f;\n        tr.material = new UnityEngine.Material(Shader.Find(\"Sprites/Default\"));"
    },
    {
      "Source": "Assets/Scripts/SatieRuntime.cs",
      "Content": "t go)\n    {\n        var tr = go.AddComponent<TrailRenderer>();\n        tr.widthMultiplier = 0.1f;\n        tr.time = 5f;\n        tr.material = new UnityEngine.Material(Shader.Find(\"Sprites/Default\"));\n        tr.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;\n\n        Color start = new Color(Random.value, Random.value, Random.value, 1f);\n        Color end   = new Color(start.r, start.g, start.b, 0f);\n\n        var grad = new Gradient();\n        grad.SetKeys(\n            new[] { new GradientColorKey(start, 0f), new GradientColorKey(end, 1f) },\n            new[] { new GradientAlphaKey(1f, 0f),    new GradientAlphaKey(0f, 1f) }\n        );\n        tr.colorGradient = grad;\n    }\n\n    void AddPrimitive(GameObject go, PrimitiveType type)\n    {\n        GameObject primitive = GameObject.CreatePrimitive(type);\n        primitive.transform.SetParent(go.transform);\n        primitive.transform.localPosition = UnityEngine.Vector3.zero;\n        primitive.transform.localScale = UnityEngine.Vector3.one * 0.5f; // Scale down a bit\n        \n        // Remove collider as we don't need physics\n        Collider col = primitive.GetComponent<Collider>();\n        if (col) Destroy(col);"
    },
    {
      "Source": "Assets/Scripts/SatieRuntime.cs",
      "Content": "tyEngine.Vector3.one * 0.5f; // Scale down a bit\n        \n        // Remove collider as we don't need physics\n        Collider col = primitive.GetComponent<Collider>();\n        if (col) Destroy(col);\n        \n        // Add a random color to the material\n        Renderer rend = primitive.GetComponent<Renderer>();\n        if (rend)\n        {\n            rend.material = new UnityEngine.Material(Shader.Find(\"Standard\"));\n            rend.material.color = new Color(Random.value, Random.value, Random.value, 0.8f);\n        }\n    }\n\n    IEnumerator StopAfter(AudioSource src, float secs, float fadeOut)\n    {\n        yield return new WaitForSeconds(secs - fadeOut);\n        yield return Fade(src, src.volume, 0f, fadeOut);\n        if (src) src.Stop();\n    }\n\n    IEnumerator Fade(AudioSource src, float from, float to, float dur)\n    {\n        if (dur <= 0f) { if (src) src.volume = to; yield break; }\n        float t = 0f;\n        while (t < dur && src)\n        {\n            src.volume = Mathf.Lerp(from, to, t / dur);\n            t += Time.deltaTime;\n            yield return null;\n        }\n        if (src) src.volume = to;\n    }\n\n    void HardReset()\n    {"
    },
    {
      "Source": "Assets/Scripts/SatieRuntime.cs",
      "Content": "{\n            src.volume = Mathf.Lerp(from, to, t / dur);\n            t += Time.deltaTime;\n            yield return null;\n        }\n        if (src) src.volume = to;\n    }\n\n    void HardReset()\n    {\n        foreach (var co in schedulers)\n            if (co != null) StopCoroutine(co);\n        schedulers.Clear();\n\n        foreach (var src in spawned)\n            if (src) Destroy(src.gameObject);\n        spawned.Clear();\n    }\n}"
    },
    {
      "Source": "Assets/Scripts/SatieSpatialAudio.cs",
      "Content": "using UnityEngine;\n\n#if STEAMAUDIO_ENABLED\nusing SteamAudio;\n#endif\n\nnamespace Satie\n{\n    /// <summary>\n    /// Handles spatial audio configuration and Steam Audio integration for SatieLang\n    /// </summary>\n    public class SatieSpatialAudio : MonoBehaviour\n    {\n        [Header(\"Spatial Audio Settings\")]\n        [Tooltip(\"Enable Head-Related Transfer Function for realistic 3D audio positioning\")]\n        [SerializeField] private bool useHRTF = true;\n\n        [Tooltip(\"Automatically setup Steam Audio components when needed\")]\n        [SerializeField] private bool autoSetupSteamAudio = true;\n\n        [Header(\"3D Audio Settings\")]\n        [Tooltip(\"Default settings applied to 3D audio sources\")]\n        [SerializeField] private AudioSpatialSettings defaultSpatialSettings = new AudioSpatialSettings();\n\n        [Header(\"Steam Audio Features\")]\n        [Tooltip(\"Enable occlusion effects (impacts performance)\")]\n        [SerializeField] private bool enableOcclusion = false;\n\n        [Tooltip(\"Enable transmission effects (impacts performance)\")]\n        [SerializeField] private bool enableTransmission = false;"
    },
    {
      "Source": "Assets/Scripts/SatieSpatialAudio.cs",
      "Content": "[SerializeField] private bool enableOcclusion = false;\n\n        [Tooltip(\"Enable transmission effects (impacts performance)\")]\n        [SerializeField] private bool enableTransmission = false;\n\n        [Tooltip(\"Enable reflection/reverb effects (impacts performance)\")]\n        [SerializeField] private bool enableReflections = false;\n\n        // Properties\n        public bool UseHRTF => useHRTF;\n        public bool AutoSetupSteamAudio => autoSetupSteamAudio;\n        public AudioSpatialSettings DefaultSpatialSettings => defaultSpatialSettings;\n        public bool EnableOcclusion => enableOcclusion;\n        public bool EnableTransmission => enableTransmission;\n        public bool EnableReflections => enableReflections;\n\n        void Start()\n        {\n            if (useHRTF && autoSetupSteamAudio)\n            {\n                SetupSteamAudio();\n            }\n        }\n\n        /// <summary>\n        /// Configure an AudioSource for spatial audio\n        /// </summary>\n        public void ConfigureAudioSource(AudioSource source, bool is3D = true)\n        {\n            if (!is3D)\n            {\n                source.spatialBlend = 0f;\n                source.spatialize = false;"
    },
    {
      "Source": "Assets/Scripts/SatieSpatialAudio.cs",
      "Content": "lic void ConfigureAudioSource(AudioSource source, bool is3D = true)\n        {\n            if (!is3D)\n            {\n                source.spatialBlend = 0f;\n                source.spatialize = false;\n                return;\n            }\n\n            // Apply 3D settings\n            source.spatialBlend = 1f;\n            source.spatialize = useHRTF;\n            source.spatializePostEffects = true;\n\n            // Apply default spatial settings\n            source.dopplerLevel = defaultSpatialSettings.dopplerLevel;\n            source.spread = defaultSpatialSettings.spread;\n            source.rolloffMode = defaultSpatialSettings.rolloffMode;\n            source.minDistance = defaultSpatialSettings.minDistance;\n            source.maxDistance = defaultSpatialSettings.maxDistance;\n        }\n\n        /// <summary>\n        /// Add Steam Audio components to an AudioSource GameObject\n        /// </summary>\n        public void AddSteamAudioComponents(GameObject audioObject)\n        {\n            if (!useHRTF) return;\n\n#if STEAMAUDIO_ENABLED\n            try\n            {\n                var steamSource = audioObject.GetComponent<SteamAudioSource>();\n                if (steamSource == null)"
    },
    {
      "Source": "Assets/Scripts/SatieSpatialAudio.cs",
      "Content": "if (!useHRTF) return;\n\n#if STEAMAUDIO_ENABLED\n            try\n            {\n                var steamSource = audioObject.GetComponent<SteamAudioSource>();\n                if (steamSource == null)\n                {\n                    steamSource = audioObject.AddComponent<SteamAudioSource>();\n                }\n\n                // Configure Steam Audio Source\n                steamSource.directivity = false;\n                steamSource.dipoleWeight = 0.0f;\n                steamSource.dipolePower = 1.0f;\n\n                // Advanced features based on settings\n                steamSource.occlusion = enableOcclusion;\n                steamSource.occlusionType = OcclusionType.Raycast;\n                steamSource.occlusionRadius = 0.1f;\n\n                steamSource.transmission = enableTransmission;\n                steamSource.transmissionType = TransmissionType.FrequencyDependent;\n\n                steamSource.reflections = enableReflections;\n                steamSource.reflectionsType = ReflectionsType.Realtime;\n\n                Debug.Log($\"[SpatialAudio] Added Steam Audio components to {audioObject.name}\");\n            }\n            catch (System.Exception e)\n            {"
    },
    {
      "Source": "Assets/Scripts/SatieSpatialAudio.cs",
      "Content": "nsType = ReflectionsType.Realtime;\n\n                Debug.Log($\"[SpatialAudio] Added Steam Audio components to {audioObject.name}\");\n            }\n            catch (System.Exception e)\n            {\n                Debug.LogWarning($\"[SpatialAudio] Failed to add Steam Audio components: {e.Message}\");\n            }\n#else\n            if (Application.isPlaying)\n            {\n                Debug.Log(\"[SpatialAudio] Steam Audio not enabled. Using Unity's default spatializer.\");\n            }\n#endif\n        }\n\n        /// <summary>\n        /// Setup Steam Audio manager and listener components\n        /// </summary>\n        public void SetupSteamAudio()\n        {\n#if STEAMAUDIO_ENABLED\n            // Check if Steam Audio Manager exists, create if missing\n            var manager = FindObjectOfType<SteamAudioManager>();\n            if (manager == null)\n            {\n                Debug.Log(\"[SpatialAudio] Creating Steam Audio Manager for HRTF support.\");\n                var managerGO = new GameObject(\"Steam Audio Manager\");\n                manager = managerGO.AddComponent<SteamAudioManager>();\n            }\n\n            // Check if main camera has Steam Audio Listener"
    },
    {
      "Source": "Assets/Scripts/SatieSpatialAudio.cs",
      "Content": "r managerGO = new GameObject(\"Steam Audio Manager\");\n                manager = managerGO.AddComponent<SteamAudioManager>();\n            }\n\n            // Check if main camera has Steam Audio Listener\n            var mainCamera = Camera.main;\n            if (mainCamera != null)\n            {\n                SetupCameraAudioComponents(mainCamera);\n            }\n            else\n            {\n                Debug.LogWarning(\"[SpatialAudio] No Main Camera found. Please ensure a camera with AudioListener exists in the scene.\");\n            }\n#else\n            Debug.Log(\"[SpatialAudio] Steam Audio not enabled. To enable:\" +\n                     \"\\n1. Add 'STEAMAUDIO_ENABLED' to Scripting Define Symbols\" +\n                     \"\\n2. Set Project Settings > Audio > Spatializer Plugin to 'Steam Audio Spatializer'\");\n#endif\n        }\n\n        /// <summary>\n        /// Setup audio components on the main camera\n        /// </summary>\n        private void SetupCameraAudioComponents(Camera camera)\n        {\n#if STEAMAUDIO_ENABLED\n            var steamListener = camera.GetComponent<SteamAudioListener>();\n            var audioListener = camera.GetComponent<AudioListener>();"
    },
    {
      "Source": "Assets/Scripts/SatieSpatialAudio.cs",
      "Content": "nents(Camera camera)\n        {\n#if STEAMAUDIO_ENABLED\n            var steamListener = camera.GetComponent<SteamAudioListener>();\n            var audioListener = camera.GetComponent<AudioListener>();\n\n            // Ensure Unity's AudioListener exists (required by Steam Audio)\n            if (audioListener == null)\n            {\n                Debug.Log(\"[SpatialAudio] Adding Unity AudioListener to Main Camera (required by Steam Audio).\");\n                audioListener = camera.gameObject.AddComponent<AudioListener>();\n            }\n\n            // Add Steam Audio Listener component if missing\n            if (steamListener == null)\n            {\n                Debug.Log(\"[SpatialAudio] Adding Steam Audio Listener to Main Camera for HRTF support.\");\n                steamListener = camera.gameObject.AddComponent<SteamAudioListener>();\n\n                // Configure Steam Audio Listener\n                steamListener.applyReverb = enableReflections;\n                steamListener.reverbType = ReverbType.Realtime;\n            }\n#endif\n        }\n\n        /// <summary>\n        /// Check if Steam Audio is properly configured\n        /// </summary>"
    },
    {
      "Source": "Assets/Scripts/SatieSpatialAudio.cs",
      "Content": "s;\n                steamListener.reverbType = ReverbType.Realtime;\n            }\n#endif\n        }\n\n        /// <summary>\n        /// Check if Steam Audio is properly configured\n        /// </summary>\n        public bool IsSteamAudioConfigured()\n        {\n#if STEAMAUDIO_ENABLED\n            var manager = FindObjectOfType<SteamAudioManager>();\n            var mainCamera = Camera.main;\n\n            if (mainCamera != null)\n            {\n                var steamListener = mainCamera.GetComponent<SteamAudioListener>();\n                var audioListener = mainCamera.GetComponent<AudioListener>();\n\n                return manager != null && steamListener != null && audioListener != null;\n            }\n\n            return manager != null;\n#else\n            return false;\n#endif\n        }\n\n        /// <summary>\n        /// Get status information about the spatial audio setup\n        /// </summary>\n        public SpatialAudioStatus GetStatus()\n        {\n            return new SpatialAudioStatus\n            {\n                useHRTF = this.useHRTF,\n                steamAudioAvailable = IsSteamAudioAvailable(),\n                steamAudioConfigured = IsSteamAudioConfigured(),"
    },
    {
      "Source": "Assets/Scripts/SatieSpatialAudio.cs",
      "Content": "patialAudioStatus\n            {\n                useHRTF = this.useHRTF,\n                steamAudioAvailable = IsSteamAudioAvailable(),\n                steamAudioConfigured = IsSteamAudioConfigured(),\n                mainCameraFound = Camera.main != null,\n                audioListenerFound = Camera.main != null && Camera.main.GetComponent<AudioListener>() != null\n            };\n        }\n\n        private bool IsSteamAudioAvailable()\n        {\n#if STEAMAUDIO_ENABLED\n            return true;\n#else\n            return false;\n#endif\n        }\n\n        // Validation in editor\n        void OnValidate()\n        {\n            // Ensure reasonable values\n            defaultSpatialSettings.Validate();\n        }\n    }\n\n    /// <summary>\n    /// Settings for 3D audio spatialization\n    /// </summary>\n    [System.Serializable]\n    public class AudioSpatialSettings\n    {\n        [Header(\"Distance Settings\")]\n        [Tooltip(\"Distance where audio begins to fade\")]\n        [Range(0.1f, 50f)] public float minDistance = 1f;\n\n        [Tooltip(\"Distance where audio is completely silent\")]\n        [Range(1f, 500f)] public float maxDistance = 100f;\n\n        [Header(\"Effect Settings\")]"
    },
    {
      "Source": "Assets/Scripts/SatieSpatialAudio.cs",
      "Content": "f, 50f)] public float minDistance = 1f;\n\n        [Tooltip(\"Distance where audio is completely silent\")]\n        [Range(1f, 500f)] public float maxDistance = 100f;\n\n        [Header(\"Effect Settings\")]\n        [Tooltip(\"Strength of doppler effect\")]\n        [Range(0f, 5f)] public float dopplerLevel = 0.5f;\n\n        [Tooltip(\"Spread angle for 3D sound (0 = point source)\")]\n        [Range(0f, 360f)] public float spread = 0f;\n\n        [Header(\"Rolloff\")]\n        [Tooltip(\"How audio fades with distance\")]\n        public AudioRolloffMode rolloffMode = AudioRolloffMode.Logarithmic;\n\n        public void Validate()\n        {\n            minDistance = Mathf.Clamp(minDistance, 0.1f, 50f);\n            maxDistance = Mathf.Clamp(maxDistance, minDistance + 0.1f, 500f);\n            dopplerLevel = Mathf.Clamp(dopplerLevel, 0f, 5f);\n            spread = Mathf.Clamp(spread, 0f, 360f);\n        }\n    }\n\n    /// <summary>\n    /// Status information about spatial audio configuration\n    /// </summary>\n    public struct SpatialAudioStatus\n    {\n        public bool useHRTF;\n        public bool steamAudioAvailable;\n        public bool steamAudioConfigured;\n        public bool mainCameraFound;"
    },
    {
      "Source": "Assets/Scripts/SatieSpatialAudio.cs",
      "Content": "ummary>\n    public struct SpatialAudioStatus\n    {\n        public bool useHRTF;\n        public bool steamAudioAvailable;\n        public bool steamAudioConfigured;\n        public bool mainCameraFound;\n        public bool audioListenerFound;\n\n        public bool IsFullyConfigured => useHRTF ?\n            (steamAudioAvailable && steamAudioConfigured && mainCameraFound && audioListenerFound) :\n            (mainCameraFound && audioListenerFound);\n    }\n}"
    },
    {
      "Source": "Assets/Scripts/SatieUtil.cs",
      "Content": "using System.Text.RegularExpressions;\nusing UnityEngine;\n\nnamespace Satie\n{\n    internal static class SatieUtil\n    {\n        // \"birds/01to08\"  \u2192 \"birds/05\" (random)\n        static readonly Regex clipRangeRx =\n            new(@\"^(.*\\/)?(\\d+)to(\\d+)$\",  // folders optional\n                RegexOptions.Compiled);\n\n        public static string ResolveClip(string pattern)\n        {\n            var m = clipRangeRx.Match(pattern);\n            if (!m.Success)\n                return pattern;\n\n            int min = int.Parse(m.Groups[2].Value);\n            int max = int.Parse(m.Groups[3].Value) + 1;\n            int choice = Random.Range(min, max);\n\n            // preserve zero-padding width (001, 0007, \u2026)\n            int digits = m.Groups[2].Value.Length;\n            string idx = choice.ToString().PadLeft(digits, '0');\n\n            string prefix = m.Groups[1].Success ? m.Groups[1].Value : string.Empty;\n            return prefix + idx;\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAIAssistantEditor.cs",
      "Content": "using System;\nusing System.Threading.Tasks;\nusing UnityEngine;\nusing UnityEditor;\nusing Satie;\n\n[CustomEditor(typeof(SatieAIAssistant))]\npublic class SatieAIAssistantEditor : Editor\n{\n    private string userPrompt = \"\";\n    private string currentScript = \"\";\n    private string generatedCode = \"\";\n    private bool isGenerating = false;\n    private bool showAdvanced = false;\n    private Vector2 scrollPosition;\n    private Vector2 scriptScrollPosition;\n    private Vector2 generatedScrollPosition;\n\n    private GUIStyle headerStyle;\n    private GUIStyle codeStyle;\n\n    private void OnEnable()\n    {\n        var assistant = target as SatieAIAssistant;\n        if (assistant != null)\n        {\n            _ = assistant.Initialize();\n        }\n    }\n\n    public override void OnInspectorGUI()\n    {\n        InitializeStyles();\n\n        var assistant = target as SatieAIAssistant;\n\n        EditorGUILayout.Space(10);\n\n        // Header\n        EditorGUILayout.LabelField(\"\ud83e\udd16 Satie AI Assistant (Modern RAG)\", headerStyle);\n        EditorGUILayout.HelpBox(\"Using OpenAI Assistants API v2 with File Search for state-of-the-art code generation\", MessageType.Info);\n\n        EditorGUILayout.Space(10);"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAIAssistantEditor.cs",
      "Content": "rn RAG)\", headerStyle);\n        EditorGUILayout.HelpBox(\"Using OpenAI Assistants API v2 with File Search for state-of-the-art code generation\", MessageType.Info);\n\n        EditorGUILayout.Space(10);\n\n        // Current Script Section\n        EditorGUILayout.LabelField(\"Current Script\", EditorStyles.boldLabel);\n        scriptScrollPosition = EditorGUILayout.BeginScrollView(scriptScrollPosition, GUILayout.Height(150));\n        currentScript = EditorGUILayout.TextArea(currentScript, codeStyle, GUILayout.ExpandHeight(true));\n        EditorGUILayout.EndScrollView();\n\n        EditorGUILayout.Space(10);\n\n        // Prompt Section\n        EditorGUILayout.LabelField(\"Prompt\", EditorStyles.boldLabel);\n        EditorGUILayout.BeginHorizontal();\n        EditorGUILayout.PrefixLabel(\"Request:\");\n        userPrompt = EditorGUILayout.TextArea(userPrompt, GUILayout.Height(60));\n        EditorGUILayout.EndHorizontal();\n\n        // Quick Prompts\n        EditorGUILayout.BeginHorizontal();\n        if (GUILayout.Button(\"Add Birds\", GUILayout.Width(80)))\n        {\n            userPrompt = \"Add birds flying around with trail visuals\";\n        }"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAIAssistantEditor.cs",
      "Content": "s\n        EditorGUILayout.BeginHorizontal();\n        if (GUILayout.Button(\"Add Birds\", GUILayout.Width(80)))\n        {\n            userPrompt = \"Add birds flying around with trail visuals\";\n        }\n        if (GUILayout.Button(\"Add Music\", GUILayout.Width(80)))\n        {\n            userPrompt = \"Add background music with slow movement\";\n        }\n        if (GUILayout.Button(\"Add Ambience\", GUILayout.Width(90)))\n        {\n            userPrompt = \"Add forest ambience with nature sounds\";\n        }\n        if (GUILayout.Button(\"Fix Syntax\", GUILayout.Width(80)))\n        {\n            userPrompt = \"Fix any syntax errors in the script\";\n        }\n        EditorGUILayout.EndHorizontal();\n\n        EditorGUILayout.Space(10);\n\n        // Generate Button\n        EditorGUI.BeginDisabledGroup(isGenerating || string.IsNullOrEmpty(userPrompt));\n        if (GUILayout.Button(isGenerating ? \"Generating...\" : \"\u2728 Generate Code\", GUILayout.Height(35)))\n        {\n            GenerateCode(assistant);\n        }\n        EditorGUI.EndDisabledGroup();\n\n        // Generated Code Section\n        if (!string.IsNullOrEmpty(generatedCode))\n        {\n            EditorGUILayout.Space(10);"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAIAssistantEditor.cs",
      "Content": "eCode(assistant);\n        }\n        EditorGUI.EndDisabledGroup();\n\n        // Generated Code Section\n        if (!string.IsNullOrEmpty(generatedCode))\n        {\n            EditorGUILayout.Space(10);\n            EditorGUILayout.LabelField(\"Generated Code\", EditorStyles.boldLabel);\n\n            generatedScrollPosition = EditorGUILayout.BeginScrollView(generatedScrollPosition, GUILayout.Height(200));\n            EditorGUILayout.TextArea(generatedCode, codeStyle, GUILayout.ExpandHeight(true));\n            EditorGUILayout.EndScrollView();\n\n            EditorGUILayout.BeginHorizontal();\n            if (GUILayout.Button(\"\ud83d\udccb Copy to Clipboard\"))\n            {\n                GUIUtility.systemCopyBuffer = generatedCode;\n                Debug.Log(\"[AI Assistant] Code copied to clipboard\");\n            }\n            if (GUILayout.Button(\"Replace Current Script\"))\n            {\n                currentScript = generatedCode;\n                generatedCode = \"\";\n            }\n            if (GUILayout.Button(\"Clear\"))\n            {\n                generatedCode = \"\";\n            }\n            EditorGUILayout.EndHorizontal();\n        }\n\n        EditorGUILayout.Space(10);"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAIAssistantEditor.cs",
      "Content": "if (GUILayout.Button(\"Clear\"))\n            {\n                generatedCode = \"\";\n            }\n            EditorGUILayout.EndHorizontal();\n        }\n\n        EditorGUILayout.Space(10);\n\n        // Advanced Settings\n        showAdvanced = EditorGUILayout.Foldout(showAdvanced, \"Advanced Settings\");\n        if (showAdvanced)\n        {\n            EditorGUI.indentLevel++;\n\n            EditorGUILayout.LabelField(\"Configuration\", EditorStyles.boldLabel);\n\n            var serializedObject = new SerializedObject(target);\n\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"assistantId\"));\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"vectorStoreId\"));\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"model\"));\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"apiKeyPath\"));\n\n            serializedObject.ApplyModifiedProperties();\n\n            EditorGUILayout.Space(5);\n\n            EditorGUILayout.BeginHorizontal();\n            if (GUILayout.Button(\"Reinitialize Assistant\"))\n            {\n                _ = assistant.Initialize();\n            }"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAIAssistantEditor.cs",
      "Content": "GUILayout.Space(5);\n\n            EditorGUILayout.BeginHorizontal();\n            if (GUILayout.Button(\"Reinitialize Assistant\"))\n            {\n                _ = assistant.Initialize();\n            }\n            if (GUILayout.Button(\"Upload New Files\"))\n            {\n                _ = UploadFiles(assistant);\n            }\n            EditorGUILayout.EndHorizontal();\n\n            EditorGUI.indentLevel--;\n        }\n\n        // Status\n        EditorGUILayout.Space(10);\n        EditorGUILayout.HelpBox(\n            \"Status: \" + (isGenerating ? \"Generating code...\" : \"Ready\") +\n            \"\\nAssistant: \" + (!string.IsNullOrEmpty(assistant.GetAssistantId()) ? \"Connected\" : \"Not initialized\") +\n            \"\\nVector Store: \" + (!string.IsNullOrEmpty(assistant.GetVectorStoreId()) ? \"Active\" : \"Not created\"),\n            isGenerating ? MessageType.Info : MessageType.None\n        );\n    }\n\n    private async void GenerateCode(SatieAIAssistant assistant)\n    {\n        isGenerating = true;\n        generatedCode = \"\";\n\n        try\n        {\n            Debug.Log($\"[AI Assistant] Generating code with prompt: {userPrompt}\");\n\n            // Ensure assistant is initialized"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAIAssistantEditor.cs",
      "Content": "nerating = true;\n        generatedCode = \"\";\n\n        try\n        {\n            Debug.Log($\"[AI Assistant] Generating code with prompt: {userPrompt}\");\n\n            // Ensure assistant is initialized\n            if (string.IsNullOrEmpty(assistant.GetAssistantId()))\n            {\n                Debug.Log(\"[AI Assistant] Initializing assistant...\");\n                bool initialized = await assistant.Initialize();\n                if (!initialized)\n                {\n                    Debug.LogError(\"[AI Assistant] Failed to initialize\");\n                    isGenerating = false;\n                    return;\n                }\n            }\n\n            // Generate code\n            generatedCode = await assistant.GenerateCode(userPrompt, currentScript);\n\n            if (string.IsNullOrEmpty(generatedCode))\n            {\n                Debug.LogError(\"[AI Assistant] No code generated\");\n            }\n            else\n            {\n                Debug.Log(\"[AI Assistant] Code generated successfully\");\n\n                // Clean up the response (remove markdown if present)\n                generatedCode = CleanGeneratedCode(generatedCode);\n            }\n        }"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAIAssistantEditor.cs",
      "Content": "stant] Code generated successfully\");\n\n                // Clean up the response (remove markdown if present)\n                generatedCode = CleanGeneratedCode(generatedCode);\n            }\n        }\n        catch (Exception e)\n        {\n            Debug.LogError($\"[AI Assistant] Generation error: {e.Message}\");\n            generatedCode = $\"// Error: {e.Message}\";\n        }\n        finally\n        {\n            isGenerating = false;\n            Repaint();\n        }\n    }\n\n    private async Task UploadFiles(SatieAIAssistant assistant)\n    {\n        try\n        {\n            Debug.Log(\"[AI Assistant] Uploading project files...\");\n            await assistant.UploadProjectFiles();\n            Debug.Log(\"[AI Assistant] Files uploaded successfully\");\n        }\n        catch (Exception e)\n        {\n            Debug.LogError($\"[AI Assistant] Upload error: {e.Message}\");\n        }\n    }\n\n    private string CleanGeneratedCode(string code)\n    {\n        // Remove markdown code blocks if present\n        if (code.Contains(\"```\"))\n        {\n            var lines = code.Split('\\n');\n            bool inCodeBlock = false;"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAIAssistantEditor.cs",
      "Content": "edCode(string code)\n    {\n        // Remove markdown code blocks if present\n        if (code.Contains(\"```\"))\n        {\n            var lines = code.Split('\\n');\n            bool inCodeBlock = false;\n            var cleanedLines = new System.Collections.Generic.List<string>();\n\n            foreach (var line in lines)\n            {\n                if (line.Trim().StartsWith(\"```\"))\n                {\n                    inCodeBlock = !inCodeBlock;\n                    continue;\n                }\n\n                if (inCodeBlock || !line.Trim().StartsWith(\"```\"))\n                {\n                    cleanedLines.Add(line);\n                }\n            }\n\n            code = string.Join(\"\\n\", cleanedLines);\n        }\n\n        return code.Trim();\n    }\n\n    private void InitializeStyles()\n    {\n        if (headerStyle == null)\n        {\n            headerStyle = new GUIStyle(EditorStyles.boldLabel)\n            {\n                fontSize = 16,\n                alignment = TextAnchor.MiddleCenter\n            };\n        }\n\n        if (codeStyle == null)\n        {\n            codeStyle = new GUIStyle(EditorStyles.textArea)\n            {"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAIAssistantEditor.cs",
      "Content": "= 16,\n                alignment = TextAnchor.MiddleCenter\n            };\n        }\n\n        if (codeStyle == null)\n        {\n            codeStyle = new GUIStyle(EditorStyles.textArea)\n            {\n                font = Font.CreateDynamicFontFromOSFont(\"Courier New\", 12),\n                wordWrap = true\n            };\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAICodeGenEditor.cs",
      "Content": "using System;\nusing System.Threading.Tasks;\nusing UnityEngine;\nusing UnityEditor;\nusing Satie;\n\n[CustomEditor(typeof(SatieAICodeGen))]\npublic class SatieAICodeGenEditor : Editor\n{\n    private SatieAICodeGen aiGen;\n\n    // UI State\n    private string aiPrompt = \"\";\n    private bool isGeneratingCode = false;\n    private string lastGeneratedCode = \"\";\n    private string lastPrompt = \"\";\n\n    // Editor foldouts\n    private bool showAdvancedSettings = false;\n    private bool showConversationHistory = false;\n\n    void OnEnable()\n    {\n        aiGen = (SatieAICodeGen)target;\n\n        // Always enable edit mode to maintain context\n        var runtime = FindObjectOfType<SatieRuntime>();\n        string currentScript = \"\";\n        if (runtime != null && runtime.ScriptFile != null)\n        {\n            currentScript = runtime.ScriptFile.text;\n        }\n        aiGen.SetEditMode(true, currentScript);\n    }\n\n    public override void OnInspectorGUI()\n    {\n        serializedObject.Update();\n\n        EditorGUILayout.LabelField(\"AI Code Generation\", EditorStyles.boldLabel);\n        EditorGUILayout.Space(5);\n\n        // Generation section (prompt first)\n        DrawGenerationSection();"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAICodeGenEditor.cs",
      "Content": ");\n\n        EditorGUILayout.LabelField(\"AI Code Generation\", EditorStyles.boldLabel);\n        EditorGUILayout.Space(5);\n\n        // Generation section (prompt first)\n        DrawGenerationSection();\n\n        // Conversation history (always show since we're always in edit mode)\n        DrawConversationSection();\n\n        // Results section\n        if (!string.IsNullOrEmpty(lastGeneratedCode))\n        {\n            DrawResultsSection();\n        }\n\n        EditorGUILayout.Space(10);\n        EditorGUILayout.LabelField(\"\", GUI.skin.horizontalSlider);\n        EditorGUILayout.Space(5);\n\n        // Configuration section (moved to end)\n        DrawConfigurationSection();\n\n        serializedObject.ApplyModifiedProperties();\n    }\n\n    private void DrawConfigurationSection()\n    {\n        showAdvancedSettings = EditorGUILayout.Foldout(showAdvancedSettings, \"Configuration\", true);\n\n        if (showAdvancedSettings)\n        {\n            EditorGUI.indentLevel++;\n\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"config.model\"));\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"config.temperature\"));"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAICodeGenEditor.cs",
      "Content": "dentLevel++;\n\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"config.model\"));\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"config.temperature\"));\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"config.maxTokens\"));\n\n            EditorGUILayout.Space(5);\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"config.enableRLHF\"));\n\n            if (aiGen.config.enableRLHF)\n            {\n                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"config.rlhfDataPath\"));\n            }\n\n            EditorGUILayout.Space(5);\n\n            EditorGUILayout.BeginHorizontal();\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"config.apiKeyPath\"));\n            if (GUILayout.Button(\"Test API\", GUILayout.Width(80)))\n            {\n                TestAPIConnection();\n            }\n            EditorGUILayout.EndHorizontal();\n\n            EditorGUI.indentLevel--;\n        }\n    }\n\n    private void DrawGenerationSection()\n    {\n        EditorGUILayout.LabelField(\"Generate Satie Code\", EditorStyles.boldLabel);\n\n        EditorGUILayout.LabelField(\"Prompt:\");"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAICodeGenEditor.cs",
      "Content": "l--;\n        }\n    }\n\n    private void DrawGenerationSection()\n    {\n        EditorGUILayout.LabelField(\"Generate Satie Code\", EditorStyles.boldLabel);\n\n        EditorGUILayout.LabelField(\"Prompt:\");\n        aiPrompt = EditorGUILayout.TextArea(aiPrompt, GUILayout.Height(60));\n\n        EditorGUI.BeginDisabledGroup(isGeneratingCode || string.IsNullOrWhiteSpace(aiPrompt));\n\n        Color bgColor = GUI.backgroundColor;\n        GUI.backgroundColor = isGeneratingCode ? Color.yellow : Color.green;\n\n        string buttonText = isGeneratingCode ? \"Generating...\" : \"Generate Code\";\n        if (GUILayout.Button(buttonText, GUILayout.Height(30)))\n        {\n            GenerateCode();\n        }\n\n        GUI.backgroundColor = bgColor;\n        EditorGUI.EndDisabledGroup();\n\n        if (!string.IsNullOrEmpty(lastPrompt))\n        {\n            EditorGUILayout.Space(5);\n            EditorGUILayout.HelpBox($\"Last prompt: {lastPrompt}\", MessageType.Info);\n        }\n    }\n\n    private void DrawConversationSection()\n    {\n        EditorGUILayout.Space(10);\n\n        showConversationHistory = EditorGUILayout.Foldout(showConversationHistory, \"Conversation History\", true);"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAICodeGenEditor.cs",
      "Content": "private void DrawConversationSection()\n    {\n        EditorGUILayout.Space(10);\n\n        showConversationHistory = EditorGUILayout.Foldout(showConversationHistory, \"Conversation History\", true);\n\n        if (showConversationHistory)\n        {\n            EditorGUI.indentLevel++;\n            DrawConversationHistory();\n            EditorGUI.indentLevel--;\n        }\n    }\n\n    private void DrawResultsSection()\n    {\n        EditorGUILayout.Space(10);\n        EditorGUILayout.LabelField(\"Generated Code:\", EditorStyles.boldLabel);\n\n        EditorGUILayout.BeginVertical(\"box\");\n        Vector2 scrollPos = Vector2.zero;\n        scrollPos = EditorGUILayout.BeginScrollView(scrollPos, GUILayout.MaxHeight(200));\n\n        GUIStyle codeStyle = new GUIStyle(EditorStyles.textArea)\n        {\n            wordWrap = true,\n            fontStyle = FontStyle.Normal\n        };\n\n        EditorGUILayout.TextArea(lastGeneratedCode, codeStyle);\n        EditorGUILayout.EndScrollView();\n        EditorGUILayout.EndVertical();\n\n        // Only show Apply to Runtime button\n        if (GUILayout.Button(\"Apply to Runtime\", GUILayout.Height(30)))\n        {\n            ApplyGeneratedCode();\n        }"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAICodeGenEditor.cs",
      "Content": "orGUILayout.EndVertical();\n\n        // Only show Apply to Runtime button\n        if (GUILayout.Button(\"Apply to Runtime\", GUILayout.Height(30)))\n        {\n            ApplyGeneratedCode();\n        }\n\n        // RLHF Feedback\n        if (aiGen.config.enableRLHF && !string.IsNullOrEmpty(lastGeneratedCode))\n        {\n            DrawRLHFFeedback();\n        }\n    }\n\n    private void DrawRLHFFeedback()\n    {\n        EditorGUILayout.Space(10);\n        EditorGUILayout.LabelField(\"Feedback (RLHF):\", EditorStyles.boldLabel);\n\n        EditorGUILayout.BeginHorizontal();\n\n        Color bgColor = GUI.backgroundColor;\n        GUI.backgroundColor = Color.green;\n        if (GUILayout.Button(\"\u2713 Correct\", GUILayout.Height(25)))\n        {\n            RecordFeedback(true);\n        }\n\n        GUI.backgroundColor = Color.red;\n        if (GUILayout.Button(\"\u2717 Incorrect\", GUILayout.Height(25)))\n        {\n            RecordFeedback(false);\n        }\n\n        GUI.backgroundColor = bgColor;\n        EditorGUILayout.EndHorizontal();\n    }\n\n    private void DrawConversationHistory()\n    {\n        var conversation = aiGen.GetCurrentConversation();"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAICodeGenEditor.cs",
      "Content": "}\n\n        GUI.backgroundColor = bgColor;\n        EditorGUILayout.EndHorizontal();\n    }\n\n    private void DrawConversationHistory()\n    {\n        var conversation = aiGen.GetCurrentConversation();\n        if (conversation?.messages == null || conversation.messages.Length == 0)\n        {\n            EditorGUILayout.LabelField(\"No conversation history yet.\", EditorStyles.miniLabel);\n            return;\n        }\n\n        foreach (var message in conversation.messages)\n        {\n            string roleLabel = message.role == \"user\" ? \"[You]\" : \"[AI]\";\n            string preview = message.content.Length > 100\n                ? message.content.Substring(0, 100) + \"...\"\n                : message.content;\n\n            EditorGUILayout.LabelField($\"{roleLabel}: {preview}\", EditorStyles.wordWrappedMiniLabel);\n        }\n    }\n\n    private async void GenerateCode()\n    {\n        if (string.IsNullOrWhiteSpace(aiPrompt)) return;\n\n        isGeneratingCode = true;\n        lastPrompt = aiPrompt;\n        Repaint();\n\n        try\n        {\n            // Get current script from SatieRuntime if it exists\n            string currentScript = \"\";"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAICodeGenEditor.cs",
      "Content": "GeneratingCode = true;\n        lastPrompt = aiPrompt;\n        Repaint();\n\n        try\n        {\n            // Get current script from SatieRuntime if it exists\n            string currentScript = \"\";\n            var runtime = FindObjectOfType<SatieRuntime>();\n            if (runtime != null && runtime.ScriptFile != null)\n            {\n                currentScript = runtime.ScriptFile.text;\n            }\n\n            string result = await aiGen.GenerateWithFollowUp(aiPrompt, currentScript);\n\n            if (!string.IsNullOrEmpty(result))\n            {\n                lastGeneratedCode = result;\n\n                if (!result.StartsWith(\"# Error\"))\n                {\n                    Debug.Log($\"[AI] Successfully generated {result.Length} characters of Satie code\");\n                }\n                else\n                {\n                    Debug.LogError($\"[AI] Generation failed: {result}\");\n                    EditorUtility.DisplayDialog(\"Generation Failed\",\n                        result.Replace(\"# Error: \", \"\"), \"OK\");\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            Debug.LogError($\"Code generation error: {e.Message}\");"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAICodeGenEditor.cs",
      "Content": "result.Replace(\"# Error: \", \"\"), \"OK\");\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            Debug.LogError($\"Code generation error: {e.Message}\");\n            EditorUtility.DisplayDialog(\"Generation Error\",\n                $\"An error occurred: {e.Message}\", \"OK\");\n        }\n        finally\n        {\n            isGeneratingCode = false;\n            Repaint();\n        }\n    }\n\n    private void ApplyGeneratedCode()\n    {\n        if (string.IsNullOrEmpty(lastGeneratedCode))\n        {\n            Debug.LogError(\"No generated code to apply\");\n            return;\n        }\n\n        Debug.Log(\"Starting to apply generated code...\");\n\n        // Find SatieRuntime in the scene\n        var runtime = FindObjectOfType<SatieRuntime>();\n        if (runtime == null)\n        {\n            Debug.LogError(\"No SatieRuntime found in scene\");\n            EditorUtility.DisplayDialog(\"No Runtime Found\",\n                \"Please add a SatieRuntime component to a GameObject in the scene.\", \"OK\");\n            return;\n        }\n\n        Debug.Log($\"Found SatieRuntime on GameObject: {runtime.gameObject.name}\");\n\n        try\n        {"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAICodeGenEditor.cs",
      "Content": "SatieRuntime component to a GameObject in the scene.\", \"OK\");\n            return;\n        }\n\n        Debug.Log($\"Found SatieRuntime on GameObject: {runtime.gameObject.name}\");\n\n        try\n        {\n            // Check if runtime has a script file assigned\n            if (runtime.ScriptFile == null)\n            {\n                EditorUtility.DisplayDialog(\"No Script File\",\n                    \"Please assign a .sat script file to the SatieRuntime component first.\", \"OK\");\n                return;\n            }\n\n            // Get the path of the current script file\n            string path = AssetDatabase.GetAssetPath(runtime.ScriptFile);\n\n            if (string.IsNullOrEmpty(path))\n            {\n                Debug.LogError(\"Could not get asset path for script file\");\n                return;\n            }\n\n            Debug.Log($\"Updating existing script file at: {path}\");\n\n            // Write the generated code to the existing file\n            System.IO.File.WriteAllText(path, lastGeneratedCode);\n            Debug.Log($\"Wrote {lastGeneratedCode.Length} characters to file\");\n\n            // Refresh the asset database to reload the file"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAICodeGenEditor.cs",
      "Content": "System.IO.File.WriteAllText(path, lastGeneratedCode);\n            Debug.Log($\"Wrote {lastGeneratedCode.Length} characters to file\");\n\n            // Refresh the asset database to reload the file\n            AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate);\n            AssetDatabase.Refresh();\n            Debug.Log(\"AssetDatabase refreshed\");\n\n            // The TextAsset reference should automatically update since we're modifying the same file\n            Debug.Log($\"Updated script file: {path}\");\n\n            // Trigger sync/recompile if in play mode (equivalent to Shift+R)\n            if (Application.isPlaying)\n            {\n                Debug.Log(\"Triggering runtime sync...\");\n                runtime.Sync(fullReset: true);\n            }\n\n            Debug.Log($\"Generated code applied to: {System.IO.Path.GetFileName(path)}\");\n        }\n        catch (System.Exception e)\n        {\n            Debug.LogError($\"Error applying generated code: {e.Message}\");\n            EditorUtility.DisplayDialog(\"Apply Error\",\n                $\"Error applying code: {e.Message}\", \"OK\");\n        }\n    }\n\n    private async void TestAPIConnection()\n    {\n        try\n        {"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAICodeGenEditor.cs",
      "Content": "EditorUtility.DisplayDialog(\"Apply Error\",\n                $\"Error applying code: {e.Message}\", \"OK\");\n        }\n    }\n\n    private async void TestAPIConnection()\n    {\n        try\n        {\n            string result = await aiGen.TestAPIConnection();\n            EditorUtility.DisplayDialog(\"API Test Result\", result, \"OK\");\n        }\n        catch (Exception e)\n        {\n            EditorUtility.DisplayDialog(\"API Test Failed\",\n                $\"Error: {e.Message}\", \"OK\");\n        }\n    }\n\n    private void RecordFeedback(bool wasCorrect)\n    {\n        if (string.IsNullOrEmpty(lastPrompt) || string.IsNullOrEmpty(lastGeneratedCode))\n        {\n            Debug.LogWarning(\"No generation to provide feedback for\");\n            return;\n        }\n\n        aiGen.RecordRLHFFeedback(lastPrompt, lastGeneratedCode, wasCorrect);\n\n        string feedbackText = wasCorrect ? \"positive\" : \"negative\";\n        Debug.Log($\"[RLHF] Recorded {feedbackText} feedback\");\n\n        EditorUtility.DisplayDialog(\"Feedback Recorded\",\n            $\"Thank you! Your {feedbackText} feedback has been recorded.\", \"OK\");\n    }\n\n}"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAPIKeyManagerWindow.cs",
      "Content": "using System;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEditor;\nusing Satie;\n\npublic class SatieAPIKeyManagerWindow : EditorWindow\n{\n    private Vector2 scrollPosition;\n    private Dictionary<SatieAPIKeyManager.Provider, string> tempKeys = new Dictionary<SatieAPIKeyManager.Provider, string>();\n    private Dictionary<SatieAPIKeyManager.Provider, bool> showKey = new Dictionary<SatieAPIKeyManager.Provider, bool>();\n    private Dictionary<SatieAPIKeyManager.Provider, string> endpoints = new Dictionary<SatieAPIKeyManager.Provider, string>();\n\n    private GUIStyle headerStyle;\n    private GUIStyle successStyle;\n    private GUIStyle errorStyle;\n    private bool showEndpoints = false;\n    private bool autoMigrate = true;\n\n    [MenuItem(\"Satie/API Key Manager\")]\n    public static void ShowWindow()\n    {\n        var window = GetWindow<SatieAPIKeyManagerWindow>(\"Satie API Keys\");\n        window.minSize = new Vector2(450, 400);\n        window.Show();\n    }\n\n    private void OnEnable()\n    {\n        RefreshKeys();\n\n        // Auto-migrate on first open\n        if (EditorPrefs.GetBool(\"Satie_FirstAPIKeyManagerOpen\", true))\n        {"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAPIKeyManagerWindow.cs",
      "Content": "window.Show();\n    }\n\n    private void OnEnable()\n    {\n        RefreshKeys();\n\n        // Auto-migrate on first open\n        if (EditorPrefs.GetBool(\"Satie_FirstAPIKeyManagerOpen\", true))\n        {\n            EditorPrefs.SetBool(\"Satie_FirstAPIKeyManagerOpen\", false);\n\n            if (autoMigrate)\n            {\n                SatieAPIKeyManager.MigrateLegacyKeys();\n                RefreshKeys();\n            }\n        }\n    }\n\n    private void RefreshKeys()\n    {\n        tempKeys.Clear();\n        showKey.Clear();\n        endpoints.Clear();\n\n        foreach (SatieAPIKeyManager.Provider provider in Enum.GetValues(typeof(SatieAPIKeyManager.Provider)))\n        {\n            if (provider == SatieAPIKeyManager.Provider.Custom) continue;\n\n            string key = SatieAPIKeyManager.GetKey(provider);\n            tempKeys[provider] = key ?? \"\";\n            showKey[provider] = false;\n            endpoints[provider] = SatieAPIKeyManager.GetEndpoint(provider);\n        }\n    }\n\n    private void OnGUI()\n    {\n        InitializeStyles();\n\n        // Header\n        EditorGUILayout.Space(10);\n        EditorGUILayout.LabelField(\"\ud83d\udd10 Satie API Key Manager\", headerStyle);"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAPIKeyManagerWindow.cs",
      "Content": "}\n    }\n\n    private void OnGUI()\n    {\n        InitializeStyles();\n\n        // Header\n        EditorGUILayout.Space(10);\n        EditorGUILayout.LabelField(\"\ud83d\udd10 Satie API Key Manager\", headerStyle);\n        EditorGUILayout.Space(5);\n\n        // Info box\n        EditorGUILayout.HelpBox(\n            \"Manage all your API keys in one secure location.\\n\" +\n            \"Keys are encrypted and stored in: \" + Application.persistentDataPath,\n            MessageType.Info\n        );\n\n        EditorGUILayout.Space(10);\n\n        // Toolbar\n        EditorGUILayout.BeginHorizontal();\n\n        if (GUILayout.Button(\"Refresh\", GUILayout.Width(80)))\n        {\n            RefreshKeys();\n        }\n\n        if (GUILayout.Button(\"Validate All\", GUILayout.Width(80)))\n        {\n            SatieAPIKeyManager.ValidateAllKeys();\n            RefreshKeys();\n        }\n\n        if (GUILayout.Button(\"Migrate Legacy\", GUILayout.Width(100)))\n        {\n            SatieAPIKeyManager.MigrateLegacyKeys();\n            RefreshKeys();\n            ShowNotification(new GUIContent(\"Legacy keys migrated\"));\n        }\n\n        GUILayout.FlexibleSpace();"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAPIKeyManagerWindow.cs",
      "Content": "{\n            SatieAPIKeyManager.MigrateLegacyKeys();\n            RefreshKeys();\n            ShowNotification(new GUIContent(\"Legacy keys migrated\"));\n        }\n\n        GUILayout.FlexibleSpace();\n\n        showEndpoints = EditorGUILayout.ToggleLeft(\"Show Endpoints\", showEndpoints, GUILayout.Width(110));\n\n        EditorGUILayout.EndHorizontal();\n\n        EditorGUILayout.Space(10);\n\n        // Scroll view for providers\n        scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition);\n\n        foreach (var provider in tempKeys.Keys)\n        {\n            DrawProviderSection(provider);\n            EditorGUILayout.Space(5);\n        }\n\n        EditorGUILayout.EndScrollView();\n\n        EditorGUILayout.Space(10);\n\n        // Environment Variables Info\n        if (EditorGUILayout.Foldout(EditorPrefs.GetBool(\"Satie_ShowEnvInfo\", false), \"Environment Variables\"))\n        {\n            EditorPrefs.SetBool(\"Satie_ShowEnvInfo\", true);\n            EditorGUI.indentLevel++;\n            EditorGUILayout.HelpBox(\n                \"You can also set API keys using environment variables:\\n\" +\n                \"\u2022 SATIE_API_KEY_OPENAI\\n\" +\n                \"\u2022 SATIE_API_KEY_ELEVENLABS\\n\" +"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAPIKeyManagerWindow.cs",
      "Content": "EditorGUILayout.HelpBox(\n                \"You can also set API keys using environment variables:\\n\" +\n                \"\u2022 SATIE_API_KEY_OPENAI\\n\" +\n                \"\u2022 SATIE_API_KEY_ELEVENLABS\\n\" +\n                \"\u2022 SATIE_API_KEY_ANTHROPIC\\n\" +\n                \"\u2022 SATIE_API_KEY_GOOGLE\\n\\n\" +\n                \"Environment variables take priority over saved keys.\",\n                MessageType.None\n            );\n            EditorGUI.indentLevel--;\n        }\n        else\n        {\n            EditorPrefs.SetBool(\"Satie_ShowEnvInfo\", false);\n        }\n\n        EditorGUILayout.Space(10);\n\n        // Status bar\n        DrawStatusBar();\n    }\n\n    private void DrawProviderSection(SatieAPIKeyManager.Provider provider)\n    {\n        bool hasKey = SatieAPIKeyManager.HasKey(provider);\n\n        EditorGUILayout.BeginVertical(EditorStyles.helpBox);\n\n        // Provider header\n        EditorGUILayout.BeginHorizontal();\n\n        // Provider name with status indicator\n        string statusIcon = hasKey ? \"\u2713\" : \"\u2717\";\n        Color statusColor = hasKey ? Color.green : Color.red;\n\n        var prevColor = GUI.color;\n        GUI.color = statusColor;"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAPIKeyManagerWindow.cs",
      "Content": "ith status indicator\n        string statusIcon = hasKey ? \"\u2713\" : \"\u2717\";\n        Color statusColor = hasKey ? Color.green : Color.red;\n\n        var prevColor = GUI.color;\n        GUI.color = statusColor;\n        EditorGUILayout.LabelField(statusIcon, GUILayout.Width(20));\n        GUI.color = prevColor;\n\n        EditorGUILayout.LabelField(GetProviderDisplayName(provider), EditorStyles.boldLabel);\n\n        if (hasKey)\n        {\n            EditorGUILayout.LabelField(\"Configured\", successStyle, GUILayout.Width(80));\n        }\n        else\n        {\n            EditorGUILayout.LabelField(\"Not Set\", errorStyle, GUILayout.Width(80));\n        }\n\n        EditorGUILayout.EndHorizontal();\n\n        EditorGUILayout.Space(3);\n\n        // API Key field\n        EditorGUILayout.BeginHorizontal();\n        EditorGUILayout.PrefixLabel(\"API Key:\");\n\n        if (!showKey[provider] && !string.IsNullOrEmpty(tempKeys[provider]))\n        {\n            // Show masked key\n            string masked = MaskApiKey(tempKeys[provider]);\n            EditorGUILayout.TextField(masked);\n        }\n        else\n        {\n            // Show actual key input"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAPIKeyManagerWindow.cs",
      "Content": "// Show masked key\n            string masked = MaskApiKey(tempKeys[provider]);\n            EditorGUILayout.TextField(masked);\n        }\n        else\n        {\n            // Show actual key input\n            tempKeys[provider] = EditorGUILayout.TextField(tempKeys[provider]);\n        }\n\n        // Toggle show/hide\n        if (!string.IsNullOrEmpty(tempKeys[provider]))\n        {\n            if (GUILayout.Button(showKey[provider] ? \"Hide\" : \"Show\", GUILayout.Width(50)))\n            {\n                showKey[provider] = !showKey[provider];\n            }\n        }\n\n        EditorGUILayout.EndHorizontal();\n\n        // Endpoint field (if shown)\n        if (showEndpoints)\n        {\n            EditorGUILayout.BeginHorizontal();\n            EditorGUILayout.PrefixLabel(\"Endpoint:\");\n            endpoints[provider] = EditorGUILayout.TextField(endpoints[provider]);\n            EditorGUILayout.EndHorizontal();\n        }\n\n        // Action buttons\n        EditorGUILayout.BeginHorizontal();\n        GUILayout.FlexibleSpace();\n\n        if (!string.IsNullOrEmpty(tempKeys[provider]))\n        {\n            if (GUILayout.Button(\"Save\", GUILayout.Width(60)))\n            {"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAPIKeyManagerWindow.cs",
      "Content": "ut.BeginHorizontal();\n        GUILayout.FlexibleSpace();\n\n        if (!string.IsNullOrEmpty(tempKeys[provider]))\n        {\n            if (GUILayout.Button(\"Save\", GUILayout.Width(60)))\n            {\n                SatieAPIKeyManager.SetKey(\n                    provider,\n                    tempKeys[provider],\n                    showEndpoints ? endpoints[provider] : null\n                );\n                ShowNotification(new GUIContent($\"{provider} key saved\"));\n                RefreshKeys();\n            }\n        }\n\n        if (hasKey)\n        {\n            if (GUILayout.Button(\"Remove\", GUILayout.Width(60)))\n            {\n                if (EditorUtility.DisplayDialog(\n                    \"Remove API Key\",\n                    $\"Are you sure you want to remove the API key for {provider}?\",\n                    \"Remove\", \"Cancel\"))\n                {\n                    SatieAPIKeyManager.RemoveKey(provider);\n                    ShowNotification(new GUIContent($\"{provider} key removed\"));\n                    RefreshKeys();\n                }\n            }\n        }\n\n        // Provider-specific help button\n        if (GUILayout.Button(\"?\", GUILayout.Width(25)))\n        {"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAPIKeyManagerWindow.cs",
      "Content": "ey removed\"));\n                    RefreshKeys();\n                }\n            }\n        }\n\n        // Provider-specific help button\n        if (GUILayout.Button(\"?\", GUILayout.Width(25)))\n        {\n            ShowProviderHelp(provider);\n        }\n\n        EditorGUILayout.EndHorizontal();\n\n        EditorGUILayout.EndVertical();\n    }\n\n    private void DrawStatusBar()\n    {\n        EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);\n\n        var configured = SatieAPIKeyManager.GetConfiguredProviders();\n        int totalProviders = Enum.GetValues(typeof(SatieAPIKeyManager.Provider)).Length - 1; // Exclude Custom\n\n        EditorGUILayout.LabelField($\"Status: {configured.Count}/{totalProviders} providers configured\");\n\n        EditorGUILayout.EndHorizontal();\n    }\n\n    private string GetProviderDisplayName(SatieAPIKeyManager.Provider provider)\n    {\n        return provider switch\n        {\n            SatieAPIKeyManager.Provider.OpenAI => \"OpenAI (GPT, DALL-E, Whisper)\",\n            SatieAPIKeyManager.Provider.ElevenLabs => \"ElevenLabs (Voice Synthesis)\",\n            SatieAPIKeyManager.Provider.Anthropic => \"Anthropic (Claude)\","
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAPIKeyManagerWindow.cs",
      "Content": "AI => \"OpenAI (GPT, DALL-E, Whisper)\",\n            SatieAPIKeyManager.Provider.ElevenLabs => \"ElevenLabs (Voice Synthesis)\",\n            SatieAPIKeyManager.Provider.Anthropic => \"Anthropic (Claude)\",\n            SatieAPIKeyManager.Provider.Google => \"Google (Gemini, PaLM)\",\n            SatieAPIKeyManager.Provider.Azure => \"Azure OpenAI Service\",\n            _ => provider.ToString()\n        };\n    }\n\n    private string MaskApiKey(string key)\n    {\n        if (string.IsNullOrEmpty(key)) return \"\";\n\n        int visibleChars = 8;\n        if (key.Length <= visibleChars)\n        {\n            return new string('\u2022', key.Length);\n        }\n\n        string prefix = key.Substring(0, 4);\n        string suffix = key.Substring(key.Length - 4);\n        int maskedLength = key.Length - 8;\n\n        return $\"{prefix}{new string('\u2022', maskedLength)}{suffix}\";\n    }\n\n    private void ShowProviderHelp(SatieAPIKeyManager.Provider provider)\n    {\n        string url = provider switch\n        {\n            SatieAPIKeyManager.Provider.OpenAI => \"https://platform.openai.com/api-keys\",\n            SatieAPIKeyManager.Provider.ElevenLabs => \"https://elevenlabs.io/api\","
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAPIKeyManagerWindow.cs",
      "Content": "provider switch\n        {\n            SatieAPIKeyManager.Provider.OpenAI => \"https://platform.openai.com/api-keys\",\n            SatieAPIKeyManager.Provider.ElevenLabs => \"https://elevenlabs.io/api\",\n            SatieAPIKeyManager.Provider.Anthropic => \"https://console.anthropic.com/settings/keys\",\n            SatieAPIKeyManager.Provider.Google => \"https://makersuite.google.com/app/apikey\",\n            SatieAPIKeyManager.Provider.Azure => \"https://portal.azure.com\",\n            _ => \"\"\n        };\n\n        if (!string.IsNullOrEmpty(url))\n        {\n            if (EditorUtility.DisplayDialog(\n                $\"Get {provider} API Key\",\n                $\"Would you like to open the {provider} console to get an API key?\",\n                \"Open Browser\", \"Cancel\"))\n            {\n                Application.OpenURL(url);\n            }\n        }\n    }\n\n    private void InitializeStyles()\n    {\n        if (headerStyle == null)\n        {\n            headerStyle = new GUIStyle(EditorStyles.boldLabel)\n            {\n                fontSize = 16,\n                alignment = TextAnchor.MiddleCenter\n            };\n        }\n\n        if (successStyle == null)\n        {"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAPIKeyManagerWindow.cs",
      "Content": "GUIStyle(EditorStyles.boldLabel)\n            {\n                fontSize = 16,\n                alignment = TextAnchor.MiddleCenter\n            };\n        }\n\n        if (successStyle == null)\n        {\n            successStyle = new GUIStyle(EditorStyles.label);\n            successStyle.normal.textColor = new Color(0.2f, 0.8f, 0.2f);\n        }\n\n        if (errorStyle == null)\n        {\n            errorStyle = new GUIStyle(EditorStyles.label);\n            errorStyle.normal.textColor = new Color(0.8f, 0.2f, 0.2f);\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAudioGenEditor.cs",
      "Content": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading.Tasks;\nusing UnityEngine;\nusing UnityEditor;\nusing Satie;\n\n[CustomEditor(typeof(SatieAudioGen))]\npublic class SatieAudioGenEditor : Editor\n{\n    private SatieAudioGen audioGen;\n\n    // UI State\n    private string audioPrompt = \"\";\n    private bool isGeneratingAudio = false;\n    private AudioGenerationResult currentAudioResult;\n    private int selectedAudioIndex = -1;\n    private AudioSource previewAudioSource;\n\n    // Foldouts\n    private bool showServerSettings = false;\n    private bool showProviderSettings = true;\n    private bool showGeneratedFiles = false;\n\n    void OnEnable()\n    {\n        audioGen = (SatieAudioGen)target;\n    }\n\n    void OnDisable()\n    {\n        // Clean up preview audio source\n        if (previewAudioSource != null)\n        {\n            DestroyImmediate(previewAudioSource.gameObject);\n        }\n    }\n\n    public override void OnInspectorGUI()\n    {\n        serializedObject.Update();\n\n        EditorGUILayout.LabelField(\"Audio Generation\", EditorStyles.boldLabel);\n        EditorGUILayout.Space(5);\n\n        // Generation interface (prompt first)"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAudioGenEditor.cs",
      "Content": "{\n        serializedObject.Update();\n\n        EditorGUILayout.LabelField(\"Audio Generation\", EditorStyles.boldLabel);\n        EditorGUILayout.Space(5);\n\n        // Generation interface (prompt first)\n        DrawGenerationInterface();\n\n        // Show current generation results\n        if (currentAudioResult != null)\n        {\n            DrawGenerationResults();\n        }\n\n        EditorGUILayout.Space(10);\n\n        // Show generated files\n        DrawGeneratedFiles();\n\n        EditorGUILayout.Space(10);\n        EditorGUILayout.LabelField(\"\", GUI.skin.horizontalSlider);\n        EditorGUILayout.Space(5);\n\n        // Provider settings\n        DrawProviderSettings();\n\n        EditorGUILayout.Space(5);\n\n        // Server configuration (moved to end)\n        DrawServerConfiguration();\n\n        serializedObject.ApplyModifiedProperties();\n    }\n\n    private void DrawServerConfiguration()\n    {\n        showServerSettings = EditorGUILayout.Foldout(showServerSettings, \"Server Configuration\", true);\n\n        if (showServerSettings)\n        {\n            EditorGUI.indentLevel++;\n\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"apiUrl\"));"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAudioGenEditor.cs",
      "Content": "gs, \"Server Configuration\", true);\n\n        if (showServerSettings)\n        {\n            EditorGUI.indentLevel++;\n\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"apiUrl\"));\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"sampleRate\"));\n\n            EditorGUILayout.BeginHorizontal();\n            if (GUILayout.Button(\"Check Server Health\", GUILayout.Height(20)))\n            {\n                CheckServerHealth();\n            }\n\n            if (GUILayout.Button(\"Clear Cache\", GUILayout.Height(20)))\n            {\n                audioGen.ClearCache();\n                Debug.Log(\"Audio generation cache cleared\");\n            }\n            EditorGUILayout.EndHorizontal();\n\n            EditorGUI.indentLevel--;\n        }\n    }\n\n    private void DrawProviderSettings()\n    {\n        showProviderSettings = EditorGUILayout.Foldout(showProviderSettings, \"Provider Settings\", true);\n\n        if (showProviderSettings)\n        {\n            EditorGUI.indentLevel++;\n\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"defaultProvider\"));\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"numOptions\"));"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAudioGenEditor.cs",
      "Content": "I.indentLevel++;\n\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"defaultProvider\"));\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"numOptions\"));\n\n            EditorGUILayout.Space(5);\n\n            AudioProvider currentProvider = (AudioProvider)serializedObject.FindProperty(\"defaultProvider\").enumValueIndex;\n\n            if (currentProvider == AudioProvider.ElevenLabs)\n            {\n                EditorGUILayout.LabelField(\"Eleven Labs Settings\", EditorStyles.boldLabel);\n                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"elevenLabsDuration\"));\n                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"elevenLabsPromptInfluence\"));\n            }\n            else if (currentProvider == AudioProvider.AudioLDM2)\n            {\n                EditorGUILayout.LabelField(\"AudioLDM2 Settings\", EditorStyles.boldLabel);\n                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"audioldm2InferenceSteps\"));\n                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"audioldm2Duration\"));\n            }\n\n            EditorGUI.indentLevel--;\n        }\n    }"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAudioGenEditor.cs",
      "Content": "ty(\"audioldm2InferenceSteps\"));\n                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"audioldm2Duration\"));\n            }\n\n            EditorGUI.indentLevel--;\n        }\n    }\n\n    private void DrawGenerationInterface()\n    {\n        EditorGUILayout.LabelField(\"Generate Audio\", EditorStyles.boldLabel);\n\n        EditorGUILayout.LabelField(\"Prompt:\");\n        audioPrompt = EditorGUILayout.TextArea(audioPrompt, GUILayout.Height(40));\n\n        EditorGUI.BeginDisabledGroup(isGeneratingAudio || string.IsNullOrWhiteSpace(audioPrompt));\n\n        Color bgColor = GUI.backgroundColor;\n        GUI.backgroundColor = isGeneratingAudio ? Color.yellow : new Color(0.5f, 0.8f, 1f);\n\n        string buttonText = isGeneratingAudio ? \"Generating Audio...\" : \"Generate Audio Options\";\n        if (GUILayout.Button(buttonText, GUILayout.Height(30)))\n        {\n            GenerateAudioOptions();\n        }\n\n        GUI.backgroundColor = bgColor;\n        EditorGUI.EndDisabledGroup();\n    }\n\n    private void DrawGenerationResults()\n    {\n        EditorGUILayout.Space(10);"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAudioGenEditor.cs",
      "Content": "enerateAudioOptions();\n        }\n\n        GUI.backgroundColor = bgColor;\n        EditorGUI.EndDisabledGroup();\n    }\n\n    private void DrawGenerationResults()\n    {\n        EditorGUILayout.Space(10);\n        EditorGUILayout.LabelField($\"Generated Audio Options ({currentAudioResult.provider})\", EditorStyles.boldLabel);\n\n        if (currentAudioResult.audioData != null)\n        {\n            for (int i = 0; i < currentAudioResult.audioData.Length; i++)\n            {\n                EditorGUILayout.BeginHorizontal();\n\n                bool hasData = currentAudioResult.audioData[i] != null && currentAudioResult.audioData[i].Length > 0;\n                EditorGUI.BeginDisabledGroup(!hasData);\n\n                string optionLabel = $\"Option {i + 1}\";\n                if (hasData)\n                {\n                    optionLabel += $\" ({currentAudioResult.audioData[i].Length / 1024} KB)\";\n                }\n                else\n                {\n                    optionLabel += \" (Generating...)\";\n                }\n\n                EditorGUILayout.LabelField(optionLabel, GUILayout.Width(150));\n\n                if (GUILayout.Button(\"\u25b6 Preview\", GUILayout.Width(80)))\n                {"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAudioGenEditor.cs",
      "Content": "ting...)\";\n                }\n\n                EditorGUILayout.LabelField(optionLabel, GUILayout.Width(150));\n\n                if (GUILayout.Button(\"\u25b6 Preview\", GUILayout.Width(80)))\n                {\n                    PlayAudioPreview(i);\n                }\n\n                bool isSelected = selectedAudioIndex == i;\n                GUI.backgroundColor = isSelected ? Color.green : GUI.backgroundColor;\n\n                if (GUILayout.Button(isSelected ? \"\u2713 Selected\" : \"Select\", GUILayout.Width(80)))\n                {\n                    selectedAudioIndex = i;\n                }\n\n                GUI.backgroundColor = GUI.backgroundColor;\n                EditorGUI.EndDisabledGroup();\n\n                EditorGUILayout.EndHorizontal();\n            }\n\n            EditorGUILayout.Space(5);\n\n            if (previewAudioSource != null && previewAudioSource.isPlaying)\n            {\n                if (GUILayout.Button(\"\u25a0 Stop Preview\", GUILayout.Height(25)))\n                {\n                    StopAudioPreview();\n                }\n            }\n\n            if (selectedAudioIndex >= 0)\n            {\n                EditorGUILayout.Space(5);"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAudioGenEditor.cs",
      "Content": "ight(25)))\n                {\n                    StopAudioPreview();\n                }\n            }\n\n            if (selectedAudioIndex >= 0)\n            {\n                EditorGUILayout.Space(5);\n\n                Color bgColor = GUI.backgroundColor;\n                GUI.backgroundColor = Color.cyan;\n\n                if (GUILayout.Button(\"Save Selected Audio\", GUILayout.Height(30)))\n                {\n                    SaveSelectedAudio();\n                }\n\n                GUI.backgroundColor = bgColor;\n            }\n        }\n    }\n\n    private void DrawGeneratedFiles()\n    {\n        showGeneratedFiles = EditorGUILayout.Foldout(showGeneratedFiles, \"Previously Generated Audio\", true);\n\n        if (showGeneratedFiles)\n        {\n            var files = audioGen.GetGeneratedAudioFiles();\n\n            if (files.Count > 0)\n            {\n                EditorGUI.indentLevel++;\n\n                EditorGUILayout.LabelField($\"Found {files.Count} generated audio files:\", EditorStyles.miniLabel);\n\n                int maxDisplay = Mathf.Min(10, files.Count);\n                for (int i = 0; i < maxDisplay; i++)\n                {\n                    EditorGUILayout.BeginHorizontal();"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAudioGenEditor.cs",
      "Content": "miniLabel);\n\n                int maxDisplay = Mathf.Min(10, files.Count);\n                for (int i = 0; i < maxDisplay; i++)\n                {\n                    EditorGUILayout.BeginHorizontal();\n                    EditorGUILayout.LabelField(files[i], EditorStyles.miniLabel);\n\n                    if (GUILayout.Button(\"Load\", GUILayout.Width(50), GUILayout.Height(16)))\n                    {\n                        string fullPath = Path.Combine(\"Audio\", \"generation\", files[i]);\n                        AudioClip clip = Resources.Load<AudioClip>(fullPath);\n                        if (clip != null)\n                        {\n                            Debug.Log($\"Loaded audio clip: {files[i]}\");\n                            PlayLoadedClip(clip);\n                        }\n                    }\n\n                    EditorGUILayout.EndHorizontal();\n                }\n\n                if (files.Count > maxDisplay)\n                {\n                    EditorGUILayout.LabelField($\"... and {files.Count - maxDisplay} more\", EditorStyles.miniLabel);\n                }\n\n                EditorGUI.indentLevel--;\n            }\n            else\n            {"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAudioGenEditor.cs",
      "Content": "ditorGUILayout.LabelField($\"... and {files.Count - maxDisplay} more\", EditorStyles.miniLabel);\n                }\n\n                EditorGUI.indentLevel--;\n            }\n            else\n            {\n                EditorGUI.indentLevel++;\n                EditorGUILayout.LabelField(\"No generated audio files found.\", EditorStyles.miniLabel);\n                EditorGUI.indentLevel--;\n            }\n        }\n    }\n\n    private async void GenerateAudioOptions()\n    {\n        isGeneratingAudio = true;\n        currentAudioResult = null;\n        selectedAudioIndex = -1;\n        Repaint();\n\n        try\n        {\n            int numOptions = serializedObject.FindProperty(\"numOptions\").intValue;\n            currentAudioResult = await audioGen.GenerateAudioOptions(\n                audioPrompt,\n                numOptions,\n                null,\n                OnAudioOptionGenerated\n            );\n\n            if (currentAudioResult != null)\n            {\n                Debug.Log($\"Successfully generated {currentAudioResult.audioData.Length} audio options\");\n            }\n            else\n            {\n                EditorUtility.DisplayDialog(\"Generation Failed\","
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAudioGenEditor.cs",
      "Content": "Debug.Log($\"Successfully generated {currentAudioResult.audioData.Length} audio options\");\n            }\n            else\n            {\n                EditorUtility.DisplayDialog(\"Generation Failed\",\n                    \"Failed to generate audio. Make sure the audio server is running.\", \"OK\");\n            }\n        }\n        catch (Exception e)\n        {\n            Debug.LogError($\"Audio generation error: {e.Message}\");\n            EditorUtility.DisplayDialog(\"Generation Error\", $\"Error: {e.Message}\", \"OK\");\n        }\n        finally\n        {\n            isGeneratingAudio = false;\n            Repaint();\n        }\n    }\n\n    private void OnAudioOptionGenerated(AudioGenerationResult result, int optionIndex)\n    {\n        currentAudioResult = result;\n        EditorApplication.delayCall += () => Repaint();\n        Debug.Log($\"Audio option {optionIndex + 1} is now available for preview\");\n    }\n\n    private void PlayAudioPreview(int index)\n    {\n        if (currentAudioResult == null || index < 0 || index >= currentAudioResult.audioData.Length)\n            return;\n\n        if (currentAudioResult.audioData[index] == null || currentAudioResult.audioData[index].Length == 0)\n        {"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAudioGenEditor.cs",
      "Content": "| index < 0 || index >= currentAudioResult.audioData.Length)\n            return;\n\n        if (currentAudioResult.audioData[index] == null || currentAudioResult.audioData[index].Length == 0)\n        {\n            Debug.LogError($\"No audio data for option {index + 1}\");\n            return;\n        }\n\n        try\n        {\n            if (previewAudioSource == null)\n            {\n                GameObject tempGO = new GameObject(\"AudioPreview\");\n                tempGO.hideFlags = HideFlags.HideAndDontSave;\n                previewAudioSource = tempGO.AddComponent<AudioSource>();\n            }\n\n            var audioClip = audioGen.ConvertBytesToAudioClip(\n                currentAudioResult.audioData[index],\n                $\"Preview_{index}\"\n            );\n\n            if (audioClip != null)\n            {\n                previewAudioSource.clip = audioClip;\n                previewAudioSource.Play();\n                Debug.Log($\"Playing audio option {index + 1}\");\n            }\n            else\n            {\n                Debug.LogError(\"Failed to convert audio data to AudioClip\");\n            }\n        }\n        catch (Exception e)\n        {"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAudioGenEditor.cs",
      "Content": "{index + 1}\");\n            }\n            else\n            {\n                Debug.LogError(\"Failed to convert audio data to AudioClip\");\n            }\n        }\n        catch (Exception e)\n        {\n            Debug.LogError($\"Error playing audio preview: {e.Message}\");\n        }\n    }\n\n    private void PlayLoadedClip(AudioClip clip)\n    {\n        if (clip == null) return;\n\n        try\n        {\n            if (previewAudioSource == null)\n            {\n                GameObject tempGO = new GameObject(\"AudioPreview\");\n                tempGO.hideFlags = HideFlags.HideAndDontSave;\n                previewAudioSource = tempGO.AddComponent<AudioSource>();\n            }\n\n            previewAudioSource.clip = clip;\n            previewAudioSource.Play();\n            Debug.Log($\"Playing loaded audio clip\");\n        }\n        catch (Exception e)\n        {\n            Debug.LogError($\"Error playing loaded clip: {e.Message}\");\n        }\n    }\n\n    private void StopAudioPreview()\n    {\n        if (previewAudioSource != null && previewAudioSource.isPlaying)\n        {\n            previewAudioSource.Stop();\n            Debug.Log(\"Stopped audio preview\");\n        }\n    }"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAudioGenEditor.cs",
      "Content": "eview()\n    {\n        if (previewAudioSource != null && previewAudioSource.isPlaying)\n        {\n            previewAudioSource.Stop();\n            Debug.Log(\"Stopped audio preview\");\n        }\n    }\n\n    private async void SaveSelectedAudio()\n    {\n        if (currentAudioResult == null || selectedAudioIndex < 0) return;\n\n        try\n        {\n            string savedPath = await audioGen.SaveSelectedAudio(\n                currentAudioResult,\n                selectedAudioIndex\n            );\n\n            if (!string.IsNullOrEmpty(savedPath))\n            {\n                EditorUtility.DisplayDialog(\"Audio Saved\",\n                    $\"Audio saved to: {savedPath}\", \"OK\");\n\n                // Apply to SatieRuntime if exists\n                var runtime = FindObjectOfType<SatieRuntime>();\n                if (runtime != null)\n                {\n                    Debug.Log($\"Audio saved and can be used in Satie scripts: {savedPath}\");\n                }\n\n                // Invalidate AI code gen cache so it re-indexes the audio library\n                var aiCodeGen = FindObjectOfType<SatieAICodeGen>();\n                if (aiCodeGen != null)\n                {"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAudioGenEditor.cs",
      "Content": "// Invalidate AI code gen cache so it re-indexes the audio library\n                var aiCodeGen = FindObjectOfType<SatieAICodeGen>();\n                if (aiCodeGen != null)\n                {\n                    aiCodeGen.InvalidateAudioCache();\n                    Debug.Log(\"[AudioGen] Notified AI Code Gen to re-index audio library\");\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            Debug.LogError($\"Error saving audio: {e.Message}\");\n            EditorUtility.DisplayDialog(\"Save Error\", $\"Error: {e.Message}\", \"OK\");\n        }\n    }\n\n    private async void CheckServerHealth()\n    {\n        try\n        {\n            bool isHealthy = await audioGen.CheckServerHealth();\n\n            if (isHealthy)\n            {\n                EditorUtility.DisplayDialog(\"Server Health\",\n                    \"Audio generation server is running and healthy!\", \"OK\");\n            }\n            else\n            {\n                EditorUtility.DisplayDialog(\"Server Health\",\n                    \"Could not connect to audio generation server.\\n\" +\n                    \"Please ensure the server is running:\\n\" +"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieAudioGenEditor.cs",
      "Content": "{\n                EditorUtility.DisplayDialog(\"Server Health\",\n                    \"Could not connect to audio generation server.\\n\" +\n                    \"Please ensure the server is running:\\n\" +\n                    \"python audio_generation_server.py\", \"OK\");\n            }\n        }\n        catch (Exception e)\n        {\n            EditorUtility.DisplayDialog(\"Health Check Error\",\n                $\"Error: {e.Message}\", \"OK\");\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieRuntimeEditor.cs",
      "Content": "using System;\nusing System.IO;\nusing UnityEngine;\nusing UnityEditor;\nusing Satie;\n\n[CustomEditor(typeof(SatieRuntime))]\npublic class SatieRuntimeEditor : Editor\n{\n    private SatieRuntime runtime;\n    private SerializedProperty scriptFileProp;\n\n    // Component management\n    private bool showComponentSetup = false;\n    private bool hasAICodeGen = false;\n    private bool hasAudioGen = false;\n    private bool hasSpatialAudio = false;\n\n    // UI state\n    private bool showScriptPreview = false;\n\n    // UI styles\n    private GUIStyle headerStyle;\n    private GUIStyle previewStyle;\n\n    void OnEnable()\n    {\n        runtime = (SatieRuntime)target;\n        scriptFileProp = serializedObject.FindProperty(\"scriptFile\");\n\n        CheckComponents();\n    }\n\n    public override void OnInspectorGUI()\n    {\n        serializedObject.Update();\n        InitStyles();\n\n        DrawHeader();\n        DrawScriptConfiguration();\n\n        if (runtime.ScriptFile != null)\n        {\n            DrawScriptPreview();\n        }\n\n        DrawComponentSetup();\n\n        serializedObject.ApplyModifiedProperties();\n    }\n\n    private void InitStyles()\n    {\n        if (headerStyle == null)\n        {"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieRuntimeEditor.cs",
      "Content": "rawScriptPreview();\n        }\n\n        DrawComponentSetup();\n\n        serializedObject.ApplyModifiedProperties();\n    }\n\n    private void InitStyles()\n    {\n        if (headerStyle == null)\n        {\n            headerStyle = new GUIStyle(EditorStyles.boldLabel)\n            {\n                fontSize = 14,\n                normal = { textColor = EditorGUIUtility.isProSkin ? Color.white : Color.black }\n            };\n        }\n\n        if (previewStyle == null)\n        {\n            previewStyle = new GUIStyle(EditorStyles.textArea)\n            {\n                wordWrap = false,\n                fontSize = 11,\n                fontStyle = FontStyle.Normal\n            };\n        }\n    }\n\n    private void DrawHeader()\n    {\n        EditorGUILayout.LabelField(\"Satie Runtime\", headerStyle);\n        EditorGUILayout.LabelField(\"Executes .sp scripts with spatial audio support\", EditorStyles.miniLabel);\n        EditorGUILayout.Space(10);\n    }\n\n    private void DrawComponentSetup()\n    {\n        Color bgColor = GUI.backgroundColor;\n\n        // Check if any components are missing\n        bool anyMissing = !hasAICodeGen || !hasAudioGen || !hasSpatialAudio;\n\n        if (anyMissing)\n        {"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieRuntimeEditor.cs",
      "Content": "Color bgColor = GUI.backgroundColor;\n\n        // Check if any components are missing\n        bool anyMissing = !hasAICodeGen || !hasAudioGen || !hasSpatialAudio;\n\n        if (anyMissing)\n        {\n            GUI.backgroundColor = new Color(1f, 0.8f, 0.2f, 0.3f); // Warning color\n        }\n        else\n        {\n            GUI.backgroundColor = new Color(0.2f, 0.8f, 0.2f, 0.3f); // Success color\n        }\n\n        EditorGUILayout.BeginVertical(EditorStyles.helpBox);\n        GUI.backgroundColor = bgColor;\n\n        showComponentSetup = EditorGUILayout.Foldout(showComponentSetup,\n            anyMissing ? \"\u26a0 Component Setup (Missing Components)\" : \"\u2713 Component Setup (Complete)\", true);\n\n        if (showComponentSetup)\n        {\n            EditorGUI.indentLevel++;\n\n            DrawComponentStatus(\"AI Code Generation\", hasAICodeGen, typeof(SatieAICodeGen));\n            DrawComponentStatus(\"Audio Generation\", hasAudioGen, typeof(SatieAudioGen));\n            DrawComponentStatus(\"Spatial Audio\", hasSpatialAudio, typeof(SatieSpatialAudio));\n\n            if (anyMissing)\n            {\n                EditorGUILayout.Space(5);\n                EditorGUILayout.HelpBox("
    },
    {
      "Source": "Assets/Scripts/Editor/SatieRuntimeEditor.cs",
      "Content": "onentStatus(\"Spatial Audio\", hasSpatialAudio, typeof(SatieSpatialAudio));\n\n            if (anyMissing)\n            {\n                EditorGUILayout.Space(5);\n                EditorGUILayout.HelpBox(\n                    \"For full functionality, add the missing components above. \" +\n                    \"Each component has its own editor interface for configuration.\",\n                    MessageType.Info);\n\n                if (GUILayout.Button(\"Add All Missing Components\", GUILayout.Height(25)))\n                {\n                    AddMissingComponents();\n                }\n            }\n            else\n            {\n                EditorGUILayout.Space(5);\n                EditorGUILayout.HelpBox(\n                    \"All components are present! Use their respective inspector sections to configure AI, Audio generation, and Spatial Audio.\",\n                    MessageType.Info);\n            }\n\n            EditorGUI.indentLevel--;\n        }\n\n        EditorGUILayout.EndVertical();\n        EditorGUILayout.Space(5);\n    }\n\n    private void DrawComponentStatus(string componentName, bool hasComponent, System.Type componentType)\n    {\n        EditorGUILayout.BeginHorizontal();"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieRuntimeEditor.cs",
      "Content": "();\n        EditorGUILayout.Space(5);\n    }\n\n    private void DrawComponentStatus(string componentName, bool hasComponent, System.Type componentType)\n    {\n        EditorGUILayout.BeginHorizontal();\n\n        string statusIcon = hasComponent ? \"\u2713\" : \"\u2717\";\n        Color statusColor = hasComponent ? Color.green : Color.red;\n\n        Color originalColor = GUI.color;\n        GUI.color = statusColor;\n        EditorGUILayout.LabelField(statusIcon, GUILayout.Width(20));\n        GUI.color = originalColor;\n\n        EditorGUILayout.LabelField(componentName, GUILayout.ExpandWidth(true));\n\n        if (!hasComponent)\n        {\n            if (GUILayout.Button(\"Add\", GUILayout.Width(50)))\n            {\n                runtime.gameObject.AddComponent(componentType);\n                CheckComponents();\n            }\n        }\n        else\n        {\n            EditorGUILayout.LabelField(\"Present\", EditorStyles.miniLabel, GUILayout.Width(50));\n        }\n\n        EditorGUILayout.EndHorizontal();\n    }\n\n    private void DrawScriptConfiguration()\n    {\n        EditorGUILayout.LabelField(\"Script Configuration\", EditorStyles.boldLabel);"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieRuntimeEditor.cs",
      "Content": "(50));\n        }\n\n        EditorGUILayout.EndHorizontal();\n    }\n\n    private void DrawScriptConfiguration()\n    {\n        EditorGUILayout.LabelField(\"Script Configuration\", EditorStyles.boldLabel);\n\n        EditorGUILayout.PropertyField(scriptFileProp, new GUIContent(\"Script File (.sp)\"));\n\n        if (runtime.ScriptFile == null)\n        {\n            EditorGUILayout.HelpBox(\n                \"Assign a .sp script file to execute. You can generate scripts using the AI Code Generation component.\",\n                MessageType.Info);\n        }\n\n        EditorGUILayout.Space(5);\n    }\n\n\n\n    private void DrawScriptPreview()\n    {\n        showScriptPreview = EditorGUILayout.Foldout(showScriptPreview, \"Script Preview\", true);\n\n        if (showScriptPreview)\n        {\n            EditorGUI.indentLevel++;\n\n            string scriptContent = runtime.ScriptFile.text;\n            string[] lines = scriptContent.Split('\\n');\n\n            EditorGUILayout.LabelField($\"Lines: {lines.Length}\", EditorStyles.miniLabel);\n\n            EditorGUILayout.BeginVertical(\"box\");\n            Vector2 scrollPos = Vector2.zero;"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieRuntimeEditor.cs",
      "Content": "plit('\\n');\n\n            EditorGUILayout.LabelField($\"Lines: {lines.Length}\", EditorStyles.miniLabel);\n\n            EditorGUILayout.BeginVertical(\"box\");\n            Vector2 scrollPos = Vector2.zero;\n            scrollPos = EditorGUILayout.BeginScrollView(scrollPos, GUILayout.MaxHeight(150));\n\n            EditorGUILayout.TextArea(scriptContent, previewStyle);\n\n            EditorGUILayout.EndScrollView();\n            EditorGUILayout.EndVertical();\n\n            EditorGUI.indentLevel--;\n        }\n    }\n\n    private void CheckComponents()\n    {\n        if (runtime == null) return;\n\n        hasAICodeGen = runtime.GetComponent<SatieAICodeGen>() != null;\n        hasAudioGen = runtime.GetComponent<SatieAudioGen>() != null;\n        hasSpatialAudio = runtime.GetComponent<SatieSpatialAudio>() != null;\n    }\n\n    private void AddMissingComponents()\n    {\n        if (!hasAICodeGen)\n        {\n            runtime.gameObject.AddComponent<SatieAICodeGen>();\n            Debug.Log(\"[Satie] Added SatieAICodeGen component\");\n        }\n\n        if (!hasAudioGen)\n        {\n            runtime.gameObject.AddComponent<SatieAudioGen>();\n            Debug.Log(\"[Satie] Added SatieAudioGen component\");"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieRuntimeEditor.cs",
      "Content": "atieAICodeGen component\");\n        }\n\n        if (!hasAudioGen)\n        {\n            runtime.gameObject.AddComponent<SatieAudioGen>();\n            Debug.Log(\"[Satie] Added SatieAudioGen component\");\n        }\n\n        if (!hasSpatialAudio)\n        {\n            runtime.gameObject.AddComponent<SatieSpatialAudio>();\n            Debug.Log(\"[Satie] Added SatieSpatialAudio component\");\n        }\n\n        CheckComponents();\n        EditorUtility.SetDirty(runtime);\n    }\n\n    void OnDisable()\n    {\n        // Clean up any preview resources\n    }\n}"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieSpatialAudioEditor.cs",
      "Content": "using UnityEngine;\nusing UnityEditor;\nusing Satie;\n\n[CustomEditor(typeof(SatieSpatialAudio))]\npublic class SatieSpatialAudioEditor : Editor\n{\n    private SatieSpatialAudio spatialAudio;\n\n    // Foldouts\n    private bool showStatus = true;\n    private bool showAdvancedFeatures = false;\n    private bool showDefaultSettings = false;\n\n    void OnEnable()\n    {\n        spatialAudio = (SatieSpatialAudio)target;\n    }\n\n    public override void OnInspectorGUI()\n    {\n        serializedObject.Update();\n\n        EditorGUILayout.LabelField(\"Spatial Audio Configuration\", EditorStyles.boldLabel);\n        EditorGUILayout.Space(5);\n\n        // Basic settings (first)\n        DrawBasicSettings();\n\n        // Default spatial settings\n        DrawDefaultSettings();\n\n        // Advanced Steam Audio features\n        DrawAdvancedFeatures();\n\n        EditorGUILayout.Space(10);\n        EditorGUILayout.LabelField(\"\", GUI.skin.horizontalSlider);\n        EditorGUILayout.Space(5);\n\n        // Status section\n        DrawStatusSection();\n\n        EditorGUILayout.Space(10);\n\n        // Action buttons (last)\n        DrawActionButtons();\n\n        serializedObject.ApplyModifiedProperties();\n    }"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieSpatialAudioEditor.cs",
      "Content": "tus section\n        DrawStatusSection();\n\n        EditorGUILayout.Space(10);\n\n        // Action buttons (last)\n        DrawActionButtons();\n\n        serializedObject.ApplyModifiedProperties();\n    }\n\n    private void DrawStatusSection()\n    {\n        showStatus = EditorGUILayout.Foldout(showStatus, \"Spatial Audio Status\", true);\n\n        if (showStatus)\n        {\n            EditorGUI.indentLevel++;\n\n            var status = spatialAudio.GetStatus();\n\n            // Overall status\n            string overallStatus = status.IsFullyConfigured ? \"\u2713 Fully Configured\" : \"\u26a0 Needs Configuration\";\n            Color statusColor = status.IsFullyConfigured ? Color.green : Color.yellow;\n\n            Color originalColor = GUI.color;\n            GUI.color = statusColor;\n            EditorGUILayout.LabelField(\"Overall Status:\", overallStatus, EditorStyles.boldLabel);\n            GUI.color = originalColor;\n\n            EditorGUILayout.Space(3);\n\n            // Individual status items\n            DrawStatusItem(\"HRTF Enabled\", status.useHRTF, status.useHRTF ? \"Enabled\" : \"Disabled\");"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieSpatialAudioEditor.cs",
      "Content": "or = originalColor;\n\n            EditorGUILayout.Space(3);\n\n            // Individual status items\n            DrawStatusItem(\"HRTF Enabled\", status.useHRTF, status.useHRTF ? \"Enabled\" : \"Disabled\");\n            DrawStatusItem(\"Steam Audio Available\", status.steamAudioAvailable, status.steamAudioAvailable ? \"Available\" : \"Not Available\");\n            DrawStatusItem(\"Steam Audio Configured\", status.steamAudioConfigured, status.steamAudioConfigured ? \"Configured\" : \"Not Configured\");\n            DrawStatusItem(\"Main Camera Found\", status.mainCameraFound, status.mainCameraFound ? \"Found\" : \"Missing\");\n            DrawStatusItem(\"Audio Listener Found\", status.audioListenerFound, status.audioListenerFound ? \"Found\" : \"Missing\");\n\n            if (!status.steamAudioAvailable && status.useHRTF)\n            {\n                EditorGUILayout.Space(5);\n                EditorGUILayout.HelpBox(\n                    \"Steam Audio is not available but HRTF is enabled. To enable Steam Audio:\\n\" +\n                    \"1. Add 'STEAMAUDIO_ENABLED' to Scripting Define Symbols\\n\" +\n                    \"2. Set Project Settings > Audio > Spatializer Plugin to 'Steam Audio Spatializer'\","
    },
    {
      "Source": "Assets/Scripts/Editor/SatieSpatialAudioEditor.cs",
      "Content": "Audio:\\n\" +\n                    \"1. Add 'STEAMAUDIO_ENABLED' to Scripting Define Symbols\\n\" +\n                    \"2. Set Project Settings > Audio > Spatializer Plugin to 'Steam Audio Spatializer'\",\n                    MessageType.Warning);\n            }\n\n            if (!status.IsFullyConfigured)\n            {\n                EditorGUILayout.Space(5);\n                EditorGUILayout.HelpBox(\n                    \"Some spatial audio components are missing. Use the 'Setup Steam Audio' button below to automatically configure them.\",\n                    MessageType.Info);\n            }\n\n            EditorGUI.indentLevel--;\n        }\n    }\n\n    private void DrawStatusItem(string label, bool condition, string value)\n    {\n        EditorGUILayout.BeginHorizontal();\n\n        Color statusColor = condition ? Color.green : Color.red;\n        string statusIcon = condition ? \"\u2713\" : \"\u2717\";\n\n        Color originalColor = GUI.color;\n        GUI.color = statusColor;\n        EditorGUILayout.LabelField(statusIcon, GUILayout.Width(20));\n        GUI.color = originalColor;\n\n        EditorGUILayout.LabelField(label, GUILayout.Width(150));\n        EditorGUILayout.LabelField(value, EditorStyles.miniLabel);"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieSpatialAudioEditor.cs",
      "Content": "tusIcon, GUILayout.Width(20));\n        GUI.color = originalColor;\n\n        EditorGUILayout.LabelField(label, GUILayout.Width(150));\n        EditorGUILayout.LabelField(value, EditorStyles.miniLabel);\n\n        EditorGUILayout.EndHorizontal();\n    }\n\n    private void DrawBasicSettings()\n    {\n        EditorGUILayout.LabelField(\"Basic Settings\", EditorStyles.boldLabel);\n\n        EditorGUILayout.PropertyField(serializedObject.FindProperty(\"useHRTF\"),\n            new GUIContent(\"Enable HRTF\", \"Use Head-Related Transfer Function for realistic 3D audio positioning\"));\n\n        EditorGUILayout.PropertyField(serializedObject.FindProperty(\"autoSetupSteamAudio\"),\n            new GUIContent(\"Auto Setup Steam Audio\", \"Automatically create Steam Audio components when needed\"));\n\n        EditorGUILayout.Space(5);\n    }\n\n    private void DrawDefaultSettings()\n    {\n        showDefaultSettings = EditorGUILayout.Foldout(showDefaultSettings, \"Default 3D Audio Settings\", true);\n\n        if (showDefaultSettings)\n        {\n            EditorGUI.indentLevel++;\n\n            SerializedProperty defaultSettings = serializedObject.FindProperty(\"defaultSpatialSettings\");"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieSpatialAudioEditor.cs",
      "Content": "s\", true);\n\n        if (showDefaultSettings)\n        {\n            EditorGUI.indentLevel++;\n\n            SerializedProperty defaultSettings = serializedObject.FindProperty(\"defaultSpatialSettings\");\n\n            EditorGUILayout.PropertyField(defaultSettings.FindPropertyRelative(\"minDistance\"),\n                new GUIContent(\"Min Distance\", \"Distance where audio begins to fade\"));\n\n            EditorGUILayout.PropertyField(defaultSettings.FindPropertyRelative(\"maxDistance\"),\n                new GUIContent(\"Max Distance\", \"Distance where audio is completely silent\"));\n\n            EditorGUILayout.PropertyField(defaultSettings.FindPropertyRelative(\"dopplerLevel\"),\n                new GUIContent(\"Doppler Level\", \"Strength of doppler effect\"));\n\n            EditorGUILayout.PropertyField(defaultSettings.FindPropertyRelative(\"spread\"),\n                new GUIContent(\"Spread\", \"Spread angle for 3D sound (0 = point source, better for HRTF)\"));\n\n            EditorGUILayout.PropertyField(defaultSettings.FindPropertyRelative(\"rolloffMode\"),\n                new GUIContent(\"Rolloff Mode\", \"How audio fades with distance\"));\n\n            EditorGUI.indentLevel--;\n        }"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieSpatialAudioEditor.cs",
      "Content": "t.PropertyField(defaultSettings.FindPropertyRelative(\"rolloffMode\"),\n                new GUIContent(\"Rolloff Mode\", \"How audio fades with distance\"));\n\n            EditorGUI.indentLevel--;\n        }\n\n        EditorGUILayout.Space(5);\n    }\n\n    private void DrawAdvancedFeatures()\n    {\n        showAdvancedFeatures = EditorGUILayout.Foldout(showAdvancedFeatures, \"Advanced Steam Audio Features\", true);\n\n        if (showAdvancedFeatures)\n        {\n            EditorGUI.indentLevel++;\n\n            EditorGUILayout.HelpBox(\n                \"These features provide enhanced realism but impact performance. Enable with caution.\",\n                MessageType.Info);\n\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"enableOcclusion\"),\n                new GUIContent(\"Enable Occlusion\", \"Block sound when objects are between source and listener\"));\n\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"enableTransmission\"),\n                new GUIContent(\"Enable Transmission\", \"Allow sound to pass through objects with attenuation\"));\n\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"enableReflections\"),"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieSpatialAudioEditor.cs",
      "Content": "new GUIContent(\"Enable Transmission\", \"Allow sound to pass through objects with attenuation\"));\n\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"enableReflections\"),\n                new GUIContent(\"Enable Reflections\", \"Add realistic reverb based on environment geometry\"));\n\n            if (spatialAudio.EnableOcclusion || spatialAudio.EnableTransmission || spatialAudio.EnableReflections)\n            {\n                EditorGUILayout.Space(3);\n                EditorGUILayout.HelpBox(\n                    \"Advanced features are enabled. Monitor performance carefully, especially with many audio sources.\",\n                    MessageType.Warning);\n            }\n\n            EditorGUI.indentLevel--;\n        }\n\n        EditorGUILayout.Space(5);\n    }\n\n    private void DrawActionButtons()\n    {\n        EditorGUILayout.LabelField(\"Actions\", EditorStyles.boldLabel);\n\n        EditorGUILayout.BeginHorizontal();\n\n        if (GUILayout.Button(\"Setup Steam Audio\", GUILayout.Height(25)))\n        {\n            SetupSteamAudio();\n        }\n\n        if (GUILayout.Button(\"Check Configuration\", GUILayout.Height(25)))\n        {\n            CheckConfiguration();"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieSpatialAudioEditor.cs",
      "Content": "dio\", GUILayout.Height(25)))\n        {\n            SetupSteamAudio();\n        }\n\n        if (GUILayout.Button(\"Check Configuration\", GUILayout.Height(25)))\n        {\n            CheckConfiguration();\n        }\n\n        EditorGUILayout.EndHorizontal();\n\n        if (!spatialAudio.UseHRTF)\n        {\n            EditorGUILayout.Space(5);\n            EditorGUILayout.HelpBox(\n                \"HRTF is disabled. Audio will use Unity's basic 3D positioning without advanced spatial effects.\",\n                MessageType.Info);\n        }\n    }\n\n    private void SetupSteamAudio()\n    {\n        try\n        {\n            spatialAudio.SetupSteamAudio();\n\n            // Refresh status\n            Repaint();\n\n            EditorUtility.DisplayDialog(\"Steam Audio Setup\",\n                \"Steam Audio setup completed. Check the status section above for results.\", \"OK\");\n        }\n        catch (System.Exception e)\n        {\n            EditorUtility.DisplayDialog(\"Steam Audio Setup Failed\",\n                $\"Failed to setup Steam Audio: {e.Message}\", \"OK\");\n        }\n    }\n\n    private void CheckConfiguration()\n    {\n        var status = spatialAudio.GetStatus();"
    },
    {
      "Source": "Assets/Scripts/Editor/SatieSpatialAudioEditor.cs",
      "Content": "m Audio Setup Failed\",\n                $\"Failed to setup Steam Audio: {e.Message}\", \"OK\");\n        }\n    }\n\n    private void CheckConfiguration()\n    {\n        var status = spatialAudio.GetStatus();\n\n        string message = \"Spatial Audio Configuration Report:\\n\\n\";\n\n        message += $\"HRTF Enabled: {(status.useHRTF ? \"Yes\" : \"No\")}\\n\";\n        message += $\"Steam Audio Available: {(status.steamAudioAvailable ? \"Yes\" : \"No\")}\\n\";\n        message += $\"Steam Audio Configured: {(status.steamAudioConfigured ? \"Yes\" : \"No\")}\\n\";\n        message += $\"Main Camera Found: {(status.mainCameraFound ? \"Yes\" : \"No\")}\\n\";\n        message += $\"Audio Listener Found: {(status.audioListenerFound ? \"Yes\" : \"No\")}\\n\\n\";\n\n        if (status.IsFullyConfigured)\n        {\n            message += \"\u2713 Configuration is complete and ready for use.\";\n        }\n        else\n        {\n            message += \"\u26a0 Configuration needs attention. See status section for details.\";\n        }\n\n        EditorUtility.DisplayDialog(\"Configuration Check\", message, \"OK\");\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/AudioEngineAmbisonicSource.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    public abstract class AudioEngineAmbisonicSource\n    {\n        public virtual void Initialize(GameObject gameObject)\n        { }\n\n        public virtual void Destroy()\n        { }\n\n        public virtual void UpdateParameters(SteamAudioAmbisonicSource ambisonicSource)\n        { }\n\n        public virtual void GetParameters(SteamAudioAmbisonicSource ambisonicSource)\n        { }\n\n        public static AudioEngineAmbisonicSource Create(AudioEngineType type)\n        {\n            switch (type)\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/AudioEngineAmbisonicSource.cs",
      "Content": "d GetParameters(SteamAudioAmbisonicSource ambisonicSource)\n        { }\n\n        public static AudioEngineAmbisonicSource Create(AudioEngineType type)\n        {\n            switch (type)\n            {\n            case AudioEngineType.Unity:\n                return new UnityAudioEngineAmbisonicSource();\n            default:\n                return null;\n            }\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/AudioEngineSource.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n#if STEAMAUDIO_ENABLED\n\nusing System;\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    public abstract class AudioEngineSource\n    {\n        public virtual void Initialize(GameObject gameObject)\n        { }\n\n        public virtual void Destroy()\n        { }\n\n        public virtual void UpdateParameters(SteamAudioSource source)\n        { }\n\n        public virtual void GetParameters(SteamAudioSource source)\n        { }\n\n        public static AudioEngineSource Create(AudioEngineType type)\n        {\n            switch (type)\n            {\n            case AudioEngineType.Unity:"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/AudioEngineSource.cs",
      "Content": "rs(SteamAudioSource source)\n        { }\n\n        public static AudioEngineSource Create(AudioEngineType type)\n        {\n            switch (type)\n            {\n            case AudioEngineType.Unity:\n                return new UnityAudioEngineSource();\n            case AudioEngineType.FMODStudio:\n                return CreateFMODStudioAudioEngineSource();\n            case AudioEngineType.Wwise:\n                return CreateWwiseAudioEngineSource();\n            default:\n                return null;\n            }\n        }\n\n        private static AudioEngineSource CreateFMODStudioAudioEngineSource()\n        {\n            var type = Type.GetType(\"SteamAudio.FMODStudioAudioEngineSource,SteamAudioFMODStudio\");\n            return (type != null) ? (AudioEngineSource) Activator.CreateInstance(type) : null;\n        }\n\n        private static AudioEngineSource CreateWwiseAudioEngineSource()\n        {\n            var type = Type.GetType(\"SteamAudio.WwiseAudioEngineSource,SteamAudioWwiseUnity\");\n            if (type == null)\n                return null;\n\n            return (AudioEngineSource) Activator.CreateInstance(type);\n        }\n    }\n}\n\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/AudioEngineState.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n#if STEAMAUDIO_ENABLED\n\nusing System;\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    public abstract class AudioEngineState\n    {\n        public virtual void Initialize(IntPtr context, IntPtr defaultHRTF, SimulationSettings simulationSettings, PerspectiveCorrection correction)\n        { }\n\n        public virtual void Destroy()\n        { }\n\n        public virtual void SetHRTF(IntPtr hrtf)\n        { }\n\n        public virtual void SetPerspectiveCorrection(PerspectiveCorrection correction)\n        { }\n\n        public virtual void SetReverbSource(Source reverbSource)\n        { }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/AudioEngineState.cs",
      "Content": "tr hrtf)\n        { }\n\n        public virtual void SetPerspectiveCorrection(PerspectiveCorrection correction)\n        { }\n\n        public virtual void SetReverbSource(Source reverbSource)\n        { }\n\n        public static AudioEngineState Create(AudioEngineType type)\n        {\n            switch (type)\n            {\n            case AudioEngineType.Unity:\n                return new UnityAudioEngineState();\n            case AudioEngineType.FMODStudio:\n                return CreateFMODStudioAudioEngineState();\n            case AudioEngineType.Wwise:\n                return CreateWwiseAudioEngineState();\n            default:\n                return null;\n            }\n        }\n\n        private static AudioEngineState CreateFMODStudioAudioEngineState()\n        {\n            var type = Type.GetType(\"SteamAudio.FMODStudioAudioEngineState,SteamAudioFMODStudio\");\n            return (type != null) ? (AudioEngineState) Activator.CreateInstance(type) : null;\n        }\n\n        private static AudioEngineState CreateWwiseAudioEngineState()\n        {\n            var type = Type.GetType(\"SteamAudio.WwiseAudioEngineState,SteamAudioWwiseUnity\");\n            if (type == null)"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/AudioEngineState.cs",
      "Content": "private static AudioEngineState CreateWwiseAudioEngineState()\n        {\n            var type = Type.GetType(\"SteamAudio.WwiseAudioEngineState,SteamAudioWwiseUnity\");\n            if (type == null)\n                return null;\n\n            return (AudioEngineState) Activator.CreateInstance(type);\n        }\n\n        public virtual void SetHRTFDisabled(bool disabled) \n        { }\n    }\n\n    public abstract class AudioEngineStateHelpers\n    {\n        public abstract Transform GetListenerTransform();\n\n        public abstract SteamAudio.AudioSettings GetAudioSettings();\n\n        public static AudioEngineStateHelpers Create(AudioEngineType type)\n        {\n            switch (type)\n            {\n                case AudioEngineType.Unity:\n                    return new UnityAudioEngineStateHelpers();\n                case AudioEngineType.FMODStudio:\n                    return CreateFMODStudioAudioEngineStateHelpers();\n                case AudioEngineType.Wwise:\n                    return CreateWwiseAudioEngineStateHelpers();\n                default:\n                    return null;\n            }\n        }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/AudioEngineState.cs",
      "Content": "pers();\n                case AudioEngineType.Wwise:\n                    return CreateWwiseAudioEngineStateHelpers();\n                default:\n                    return null;\n            }\n        }\n\n        private static AudioEngineStateHelpers CreateFMODStudioAudioEngineStateHelpers()\n        {\n            var type = Type.GetType(\"SteamAudio.FMODStudioAudioEngineStateHelpers,SteamAudioFMODStudio\");\n            return (type != null) ? (AudioEngineStateHelpers) Activator.CreateInstance(type) : null;\n        }\n\n        private static AudioEngineStateHelpers CreateWwiseAudioEngineStateHelpers()\n        {\n            var type = Type.GetType(\"SteamAudio.WwiseAudioEngineStateHelpers,SteamAudioWwiseUnity\");\n            if (type == null)\n                return null;\n\n            return (AudioEngineStateHelpers) Activator.CreateInstance(type);\n        }\n    }\n}\n\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n#if STEAMAUDIO_ENABLED\n\nusing AOT;\nusing System;\nusing System.Runtime.InteropServices;\nusing System.Threading;\nusing UnityEngine;\nusing UnityEngine.SceneManagement;\n#if UNITY_EDITOR\nusing UnityEditor;\nusing UnityEditor.SceneManagement;\n#endif\n\nnamespace SteamAudio\n{\n    public enum BakeStatus\n    {\n        Ready,\n        InProgress,\n        Complete\n    }\n\n    public struct BakedDataTask\n    {\n        public GameObject gameObject;\n        public MonoBehaviour component;\n        public string name;\n        public BakedDataIdentifier identifier;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "e\n    }\n\n    public struct BakedDataTask\n    {\n        public GameObject gameObject;\n        public MonoBehaviour component;\n        public string name;\n        public BakedDataIdentifier identifier;\n        public SteamAudioProbeBatch[] probeBatches;\n        public string[] probeBatchNames;\n        public SerializedData[] probeBatchAssets;\n        public SteamAudioReverbDataPoint probe;\n        public UnityEngine.Vector3 probePosition;\n    }\n\n    public static class Baker\n    {\n        static BakeStatus sStatus = BakeStatus.Ready;\n#if UNITY_EDITOR\n        static float sProgress = 0.0f;\n        static int sProgressId = -1;\n        static bool sShowModalProgressBar = false;\n#endif\n        static ProgressCallback sProgressCallback = null;\n        static IntPtr sProgressCallbackPointer = IntPtr.Zero;\n        static GCHandle sProgressCallbackHandle;\n        static Thread sThread;\n\n        static int sNumSubTasks = 0;\n        static int sNumSubTasksCompleted = 0;\n\n        static bool sCancel = false;\n        static BakedDataTask[] sTasks = null;\n\n        public static void BeginBake(BakedDataTask[] tasks, bool showModalProgressBar = false)\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "eted = 0;\n\n        static bool sCancel = false;\n        static BakedDataTask[] sTasks = null;\n\n        public static void BeginBake(BakedDataTask[] tasks, bool showModalProgressBar = false)\n        {\n            SteamAudioManager.Initialize(ManagerInitReason.Baking);\n\n            if (SteamAudioManager.GetSceneType() == SceneType.Custom)\n            {\n                Debug.LogError(\"Baking is not supported when using Unity's built-in ray tracer. Click Steam Audio > Settings and switch to a different ray tracer.\");\n                return;\n            }\n\n            SteamAudioManager.LoadScene(SceneManager.GetActiveScene(), SteamAudioManager.Context, false);\n\n            SteamAudioStaticMesh staticMeshComponent = null;\n            var rootObjects = SceneManager.GetActiveScene().GetRootGameObjects();\n            foreach (var rootObject in rootObjects)\n            {\n                staticMeshComponent = rootObject.GetComponentInChildren<SteamAudioStaticMesh>();\n                if (staticMeshComponent)\n                    break;\n            }\n\n            if (staticMeshComponent == null || staticMeshComponent.asset == null)\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "mAudioStaticMesh>();\n                if (staticMeshComponent)\n                    break;\n            }\n\n            if (staticMeshComponent == null || staticMeshComponent.asset == null)\n            {\n                Debug.LogError(string.Format(\"Scene {0} has not been exported. Click Steam Audio > Export Active Scene to do so.\", SceneManager.GetActiveScene().name));\n                return;\n            }\n\n            var staticMesh = new StaticMesh(SteamAudioManager.Context, SteamAudioManager.CurrentScene, staticMeshComponent.asset);\n            staticMesh.AddToScene(SteamAudioManager.CurrentScene);\n\n            SteamAudioManager.CurrentScene.Commit();\n\n            staticMesh.Release();\n\n            sTasks = tasks;\n            sStatus = BakeStatus.InProgress;\n\n            sProgressCallback = new ProgressCallback(AdvanceProgress);\n\n#if (UNITY_EDITOR_WIN || UNITY_STANDALONE_WIN)\n            sProgressCallbackPointer = Marshal.GetFunctionPointerForDelegate(sProgressCallback);\n            sProgressCallbackHandle = GCHandle.Alloc(sProgressCallbackPointer);\n            GC.Collect();\n#endif\n\n#if UNITY_EDITOR\n            EditorApplication.update += InEditorUpdate;\n#endif\n\n#if UNITY_EDITOR"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "sProgressCallbackHandle = GCHandle.Alloc(sProgressCallbackPointer);\n            GC.Collect();\n#endif\n\n#if UNITY_EDITOR\n            EditorApplication.update += InEditorUpdate;\n#endif\n\n#if UNITY_EDITOR\n            sShowModalProgressBar = showModalProgressBar;\n            sProgressId = Progress.Start(\"Baking\");\n#endif\n\n            sThread = new Thread(BakeThread);\n            sThread.Start();\n        }\n\n        public static void EndBake()\n        {\n            if (sThread != null)\n            {\n                sThread.Join();\n            }\n\n            SerializedObject.FlushAllWrites();\n            SteamAudioReverbDataPoint.FlushAllWrites();\n#if UNITY_EDITOR\n            UnityEditor.AssetDatabase.SaveAssets();\n            UnityEditor.AssetDatabase.Refresh();\n#endif\n\n#if (UNITY_EDITOR_WIN || UNITY_STANDALONE_WIN)\n            if (sProgressCallbackHandle.IsAllocated)\n            {\n                sProgressCallbackHandle.Free();\n            }\n#endif\n\n            SteamAudioManager.ShutDown();\n            UnityEngine.Object.DestroyImmediate(SteamAudioManager.Singleton.gameObject);\n\n#if UNITY_EDITOR\n            sProgress = 0.0f;\n#endif\n            sNumSubTasks = 0;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "mAudioManager.ShutDown();\n            UnityEngine.Object.DestroyImmediate(SteamAudioManager.Singleton.gameObject);\n\n#if UNITY_EDITOR\n            sProgress = 0.0f;\n#endif\n            sNumSubTasks = 0;\n            sNumSubTasksCompleted = 0;\n\n            sStatus = BakeStatus.Ready;\n\n#if UNITY_EDITOR\n            EditorApplication.update -= InEditorUpdate;\n#endif\n\n#if UNITY_EDITOR\n            Progress.Remove(sProgressId);\n            sShowModalProgressBar = false;\n#endif\n        }\n\n        public static bool IsBakeActive()\n        {\n            return (sStatus != BakeStatus.Ready);\n        }\n\n        public static bool DrawProgressBar()\n        {\n#if UNITY_EDITOR\n            if (sStatus != BakeStatus.InProgress)\n                return false;\n\n            var progress = Progress.GetProgress(sProgressId);\n            var description = Progress.GetDescription(sProgressId);\n            EditorGUI.ProgressBar(EditorGUILayout.GetControlRect(), progress, description);\n            if (GUILayout.Button(\"Cancel\"))\n            {\n                CancelBake();\n                return false;\n            }\n#endif\n            return true;\n        }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "progress, description);\n            if (GUILayout.Button(\"Cancel\"))\n            {\n                CancelBake();\n                return false;\n            }\n#endif\n            return true;\n        }\n\n        static void UpdateBakeProgress(int taskIndex, int numTasks, string taskName, int subTaskIndex = 0, int numSubTasks = 1, string subTaskName = null)\n        {\n#if UNITY_EDITOR\n            var progress = ((sNumSubTasksCompleted + sProgress) / Mathf.Max(sNumSubTasks, 1)) + .01f; // Adding an offset because progress bar when it is exact 0 has some non-zero progress.\n\n            var progressString = string.Format(\"Task {0} / {1} [{2}]\", taskIndex + 1, numTasks, taskName);\n            if (subTaskName != null)\n            {\n                progressString += string.Format(\", Probe Batch {0} / {1} [{2}]\", subTaskIndex + 1, numSubTasks, subTaskName);\n            }\n\n            var progressPercent = Mathf.FloorToInt(Mathf.Min(progress * 100.0f, 100.0f));\n            progressString += string.Format(\" ({0}% complete)\", progressPercent);\n\n            Progress.Report(sProgressId, progress, progressString);\n#endif\n        }\n\n        public static void CancelBake()\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "sString += string.Format(\" ({0}% complete)\", progressPercent);\n\n            Progress.Report(sProgressId, progress, progressString);\n#endif\n        }\n\n        public static void CancelBake()\n        {\n            // Ensures partial baked data is not serialized and that bake is properly canceled for multiple\n            // probe boxes.\n            sCancel = true;\n            API.iplReflectionsBakerCancelBake(SteamAudioManager.Context.Get());\n#if UNITY_EDITOR\n            EditorUtility.ClearProgressBar();\n#endif\n            EndBake();\n            sCancel = false;\n        }\n\n        [MonoPInvokeCallback(typeof(ProgressCallback))]\n        static void AdvanceProgress(float progress, IntPtr userData)\n        {\n#if UNITY_EDITOR\n            sProgress = progress;\n#endif\n        }\n\n        static void InEditorUpdate()\n        {\n#if UNITY_EDITOR\n            if (sShowModalProgressBar && sProgressId >= 0)\n            {\n                var progress = Progress.GetProgress(sProgressId);\n                var description = Progress.GetDescription(sProgressId);\n                if (EditorUtility.DisplayCancelableProgressBar(\"Baking\", description, progress))\n                {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "ProgressId);\n                var description = Progress.GetDescription(sProgressId);\n                if (EditorUtility.DisplayCancelableProgressBar(\"Baking\", description, progress))\n                {\n                    CancelBake();\n                    return;\n                }\n            }\n\n            if (sStatus == BakeStatus.Complete)\n            {\n                EditorUtility.ClearProgressBar();\n                EndBake();\n                EditorSceneManager.MarkSceneDirty(SceneManager.GetActiveScene());\n            }\n#endif\n        }\n\n        static void BakeThread()\n        {\n            sNumSubTasks = 0;\n            sNumSubTasksCompleted = 0;\n            for (var i = 0; i < sTasks.Length; i++)\n            {\n                if (sTasks[i].probeBatches != null)\n                {\n                    sNumSubTasks += sTasks[i].probeBatches.Length;\n                }\n                else\n                {\n                    sNumSubTasks++;\n                }\n            }\n\n            for (var i = 0; i < sTasks.Length; ++i)\n            {\n                var taskName = \"\";\n                if (sTasks[i].identifier.type == BakedDataType.Pathing)\n                {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "}\n\n            for (var i = 0; i < sTasks.Length; ++i)\n            {\n                var taskName = \"\";\n                if (sTasks[i].identifier.type == BakedDataType.Pathing)\n                {\n                    taskName = string.Format(\"{0} (Pathing)\", sTasks[i].name);\n                }\n                else if (sTasks[i].identifier.variation == BakedDataVariation.Reverb)\n                {\n                    taskName = string.Format(\"{0} (Reverb)\", sTasks[i].name);\n                }\n                else\n                {\n                    taskName = string.Format(\"{0} (Reflections)\", sTasks[i].name);\n                }\n\n                Debug.Log(string.Format(\"START: Baking effect for {0}.\", taskName));\n\n                if (sTasks[i].probeBatches != null)\n                {\n                    var probeBatches = sTasks[i].probeBatches;\n\n                    for (var j = 0; j < probeBatches.Length; ++j)\n                    {\n                        if (sCancel)\n                            return;\n\n                        if (probeBatches[j] == null)\n                        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "robeBatches.Length; ++j)\n                    {\n                        if (sCancel)\n                            return;\n\n                        if (probeBatches[j] == null)\n                        {\n                            Debug.LogWarning(string.Format(\"{0}: Probe Batch at index {1} is null, skipping.\", taskName, j));\n                            continue;\n                        }\n\n                        if (probeBatches[j].GetNumProbes() == 0)\n                        {\n                            Debug.LogWarning(string.Format(\"{0}: Probe Batch {1} has no probes, skipping.\", taskName, sTasks[i].probeBatchNames[j]));\n                            continue;\n                        }\n\n                        var probeBatch = new ProbeBatch(SteamAudioManager.Context, sTasks[i].probeBatchAssets[j]);\n\n                        var simulationSettings = SteamAudioManager.GetSimulationSettings(true);\n\n                        if (sTasks[i].identifier.type == BakedDataType.Reflections)\n                        {\n                            var bakeParams = new ReflectionsBakeParams { };\n                            bakeParams.scene = SteamAudioManager.CurrentScene.Get();"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "Reflections)\n                        {\n                            var bakeParams = new ReflectionsBakeParams { };\n                            bakeParams.scene = SteamAudioManager.CurrentScene.Get();\n                            bakeParams.probeBatch = probeBatch.Get();\n                            bakeParams.sceneType = simulationSettings.sceneType;\n                            bakeParams.identifier = sTasks[i].identifier;\n                            bakeParams.flags = 0;\n                            bakeParams.numRays = simulationSettings.maxNumRays;\n                            bakeParams.numDiffuseSamples = simulationSettings.numDiffuseSamples;\n                            bakeParams.numBounces = SteamAudioSettings.Singleton.bakingBounces;\n                            bakeParams.simulatedDuration = simulationSettings.maxDuration;\n                            bakeParams.savedDuration = simulationSettings.maxDuration;\n                            bakeParams.order = simulationSettings.maxOrder;\n                            bakeParams.numThreads = simulationSettings.numThreads;\n                            bakeParams.rayBatchSize = simulationSettings.rayBatchSize;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "simulationSettings.maxOrder;\n                            bakeParams.numThreads = simulationSettings.numThreads;\n                            bakeParams.rayBatchSize = simulationSettings.rayBatchSize;\n                            bakeParams.irradianceMinDistance = SteamAudioSettings.Singleton.bakingIrradianceMinDistance;\n                            bakeParams.bakeBatchSize = 1;\n\n                            if (SteamAudioSettings.Singleton.bakeConvolution)\n                                bakeParams.flags = bakeParams.flags | ReflectionsBakeFlags.BakeConvolution;\n\n                            if (SteamAudioSettings.Singleton.bakeParametric)\n                                bakeParams.flags = bakeParams.flags | ReflectionsBakeFlags.BakeParametric;\n\n                            if (simulationSettings.sceneType == SceneType.RadeonRays)\n                            {\n                                bakeParams.openCLDevice = SteamAudioManager.OpenCLDevice;\n                                bakeParams.radeonRaysDevice = SteamAudioManager.RadeonRaysDevice;\n                                bakeParams.bakeBatchSize = SteamAudioSettings.Singleton.bakingBatchSize;\n                            }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "keParams.radeonRaysDevice = SteamAudioManager.RadeonRaysDevice;\n                                bakeParams.bakeBatchSize = SteamAudioSettings.Singleton.bakingBatchSize;\n                            }\n\n                            API.iplReflectionsBakerBake(SteamAudioManager.Context.Get(), ref bakeParams, sProgressCallback, IntPtr.Zero);\n                        }\n                        else\n                        {\n                            var bakeParams = new PathBakeParams { };\n                            bakeParams.scene = SteamAudioManager.CurrentScene.Get();\n                            bakeParams.probeBatch = probeBatch.Get();\n                            bakeParams.identifier = sTasks[i].identifier;\n                            bakeParams.numSamples = SteamAudioSettings.Singleton.bakingVisibilitySamples;\n                            bakeParams.radius = SteamAudioSettings.Singleton.bakingVisibilityRadius;\n                            bakeParams.threshold = SteamAudioSettings.Singleton.bakingVisibilityThreshold;\n                            bakeParams.visRange = SteamAudioSettings.Singleton.bakingVisibilityRange;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "bakeParams.threshold = SteamAudioSettings.Singleton.bakingVisibilityThreshold;\n                            bakeParams.visRange = SteamAudioSettings.Singleton.bakingVisibilityRange;\n                            bakeParams.pathRange = SteamAudioSettings.Singleton.bakingPathRange;\n                            bakeParams.numThreads = SteamAudioManager.Singleton.NumThreadsForCPUCorePercentage(SteamAudioSettings.Singleton.bakedPathingCPUCoresPercentage);\n\n                            API.iplPathBakerBake(SteamAudioManager.Context.Get(), ref bakeParams, sProgressCallback, IntPtr.Zero);\n                        }\n\n                        if (sCancel)\n                        {\n                            Debug.Log(\"CANCELLED: Baking.\");\n                            return;\n                        }\n\n                        // Don't flush the writes to disk just yet, because we can only do it from the main thread.\n                        probeBatches[j].probeDataSize = probeBatch.Save(sTasks[i].probeBatchAssets[j], false);\n\n                        var dataSize = (int)probeBatch.GetDataSize(sTasks[i].identifier);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "probeBatches[j].probeDataSize = probeBatch.Save(sTasks[i].probeBatchAssets[j], false);\n\n                        var dataSize = (int)probeBatch.GetDataSize(sTasks[i].identifier);\n                        probeBatches[j].AddOrUpdateLayer(sTasks[i].gameObject, sTasks[i].identifier, dataSize);\n\n                        if (sTasks[i].identifier.type == BakedDataType.Reflections)\n                        {\n                            switch (sTasks[i].identifier.variation)\n                            {\n                                case BakedDataVariation.Reverb:\n                                    (sTasks[i].component as SteamAudioListener).UpdateBakedDataStatistics();\n                                    break;\n\n                                case BakedDataVariation.StaticSource:\n                                    (sTasks[i].component as SteamAudioBakedSource).UpdateBakedDataStatistics();\n                                    break;\n\n                                case BakedDataVariation.StaticListener:\n                                    (sTasks[i].component as SteamAudioBakedListener).UpdateBakedDataStatistics();\n                                    break;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "case BakedDataVariation.StaticListener:\n                                    (sTasks[i].component as SteamAudioBakedListener).UpdateBakedDataStatistics();\n                                    break;\n                            }\n                        }\n\n                        sNumSubTasksCompleted++;\n                        UpdateBakeProgress(i, sTasks.Length, taskName, j, sTasks[i].probeBatches.Length, sTasks[i].probeBatchNames[j]);\n                    }\n                }\n\n                if (sTasks[i].probe != null)\n                { \n                    var probe = sTasks[i].probe;\n                    var probePosition = sTasks[i].probePosition;\n\n                    if (sCancel)\n                        return;\n\n                    var probeBatch = new ProbeBatch(SteamAudioManager.Context);\n                    SteamAudio.Sphere sphere = new SteamAudio.Sphere { center = Common.ConvertVector(probePosition), radius = 10.0f };\n                    probeBatch.AddProbe(sphere);\n                    probeBatch.Commit();\n\n                    var simulationSettings = SteamAudioManager.GetSimulationSettings(true);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "adius = 10.0f };\n                    probeBatch.AddProbe(sphere);\n                    probeBatch.Commit();\n\n                    var simulationSettings = SteamAudioManager.GetSimulationSettings(true);\n                    simulationSettings.maxDuration = probe.reverbDuration;\n                    simulationSettings.maxOrder = probe.ambisonicOrder;\n\n                    if (sTasks[i].identifier.type == BakedDataType.Reflections)\n                    {\n                        var bakeParams = new ReflectionsBakeParams { };\n                        bakeParams.scene = SteamAudioManager.CurrentScene.Get();\n                        bakeParams.probeBatch = probeBatch.Get();\n                        bakeParams.sceneType = simulationSettings.sceneType;\n                        bakeParams.identifier = sTasks[i].identifier;\n                        bakeParams.flags = 0;\n                        bakeParams.numRays = simulationSettings.maxNumRays;\n                        bakeParams.numDiffuseSamples = simulationSettings.numDiffuseSamples;\n                        bakeParams.numBounces = SteamAudioSettings.Singleton.bakingBounces;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "gs.maxNumRays;\n                        bakeParams.numDiffuseSamples = simulationSettings.numDiffuseSamples;\n                        bakeParams.numBounces = SteamAudioSettings.Singleton.bakingBounces;\n                        bakeParams.simulatedDuration = simulationSettings.maxDuration;\n                        bakeParams.savedDuration = simulationSettings.maxDuration;\n                        bakeParams.order = simulationSettings.maxOrder;\n                        bakeParams.numThreads = simulationSettings.numThreads;\n                        bakeParams.rayBatchSize = simulationSettings.rayBatchSize;\n                        bakeParams.irradianceMinDistance = SteamAudioSettings.Singleton.bakingIrradianceMinDistance;\n                        bakeParams.bakeBatchSize = 1;\n\n                        bakeParams.flags = bakeParams.flags | ReflectionsBakeFlags.BakeConvolution;\n                        bakeParams.flags = bakeParams.flags | ReflectionsBakeFlags.BakeParametric;\n\n                        if (simulationSettings.sceneType == SceneType.RadeonRays)\n                        {\n                            bakeParams.openCLDevice = SteamAudioManager.OpenCLDevice;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "ric;\n\n                        if (simulationSettings.sceneType == SceneType.RadeonRays)\n                        {\n                            bakeParams.openCLDevice = SteamAudioManager.OpenCLDevice;\n                            bakeParams.radeonRaysDevice = SteamAudioManager.RadeonRaysDevice;\n                            bakeParams.bakeBatchSize = SteamAudioSettings.Singleton.bakingBatchSize;\n                        }\n\n                        API.iplReflectionsBakerBake(SteamAudioManager.Context.Get(), ref bakeParams, sProgressCallback, IntPtr.Zero);\n\n                        if (probe.reverbData.reverbTimes.Length != 3)\n                        {\n                            probe.reverbData.reverbTimes = new float[3];\n                            probe.reverbData.reverbTimes[0] = .0f;\n                            probe.reverbData.reverbTimes[1] = .0f;\n                            probe.reverbData.reverbTimes[2] = .0f;\n                        }\n\n                        // Get Energy Field and Impulse Response\n                        {\n                            // Energy Field\n                            EnergyFieldSettings energyFieldSettings;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "// Get Energy Field and Impulse Response\n                        {\n                            // Energy Field\n                            EnergyFieldSettings energyFieldSettings;\n                            energyFieldSettings.duration = bakeParams.savedDuration;\n                            energyFieldSettings.order = bakeParams.order;\n\n                            IntPtr energyField;\n                            API.iplEnergyFieldCreate(SteamAudioManager.Context.Get(), ref energyFieldSettings, out energyField);\n\n                            API.iplProbeBatchGetEnergyField(probeBatch.Get(), ref sTasks[i].identifier, 0, energyField);\n                            API.iplProbeBatchGetReverb(probeBatch.Get(), ref sTasks[i].identifier, 0, probe.reverbData.reverbTimes);\n                            probe.UpdateEnergyField(energyField);\n\n                            // Create Reconstructor\n                            ReconstructorSettings reconstructorSettings;\n                            reconstructorSettings.maxDuration = bakeParams.savedDuration;\n                            reconstructorSettings.maxOrder = bakeParams.order;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "ettings reconstructorSettings;\n                            reconstructorSettings.maxDuration = bakeParams.savedDuration;\n                            reconstructorSettings.maxOrder = bakeParams.order;\n                            reconstructorSettings.samplingRate = probe.sampleRate;\n\n                            IntPtr irConstructor;\n                            API.iplReconstructorCreate(SteamAudioManager.Context.Get(), ref reconstructorSettings, out irConstructor);\n\n                            // Create Impulse Response\n                            ImpulseResponseSettings irSettings;\n                            irSettings.duration = bakeParams.savedDuration;\n                            irSettings.order = bakeParams.order;\n                            irSettings.samplingRate = probe.sampleRate;\n\n                            IntPtr ir;\n                            API.iplImpulseResponseCreate(SteamAudioManager.Context.Get(), ref irSettings, out ir);\n\n                            // Reconstruct Impulse Response\n                            ReconstructorInputs reconstructorInputs;\n                            reconstructorInputs.energyField = energyField;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "// Reconstruct Impulse Response\n                            ReconstructorInputs reconstructorInputs;\n                            reconstructorInputs.energyField = energyField;\n\n                            ReconstructorSharedInputs reconstructorSharedInputs;\n                            reconstructorSharedInputs.duration = bakeParams.savedDuration;\n                            reconstructorSharedInputs.order = bakeParams.order;\n\n                            ReconstructorOutputs reconstructorOutputs;\n                            reconstructorOutputs.impulseResponse = ir;\n\n                            API.iplReconstructorReconstruct(irConstructor, 1, ref reconstructorInputs, ref reconstructorSharedInputs, ref reconstructorOutputs);\n                            probe.UpdateImpulseResponse(ir);\n\n                            API.iplImpulseResponseRelease(ref ir);\n                            API.iplReconstructorRelease(ref irConstructor);\n                            API.iplEnergyFieldRelease(ref energyField);\n                            probe.WriteReverbDataToFile(flush: false);\n                        }\n\n                        probeBatch.Release();\n                    }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Baker.cs",
      "Content": "rgyFieldRelease(ref energyField);\n                            probe.WriteReverbDataToFile(flush: false);\n                        }\n\n                        probeBatch.Release();\n                    }\n\n                    if (sCancel)\n                    {\n                        Debug.Log(\"CANCELLED: Baking.\");\n                        return;\n                    }\n\n                    sNumSubTasksCompleted++;\n                    UpdateBakeProgress(i, sTasks.Length, taskName);\n                }\n\n                Debug.Log(string.Format(\"COMPLETED: Baking effect for {0}.\", taskName));\n            }\n\n            sStatus = BakeStatus.Complete;\n        }\n    }\n}\n\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Common.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing System;\nusing System.IO;\nusing System.Text;\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    public static class Common\n    {\n        public static Vector3 ConvertVector(UnityEngine.Vector3 point)\n        {\n            Vector3 convertedPoint;\n            convertedPoint.x = point.x;\n            convertedPoint.y = point.y;\n            convertedPoint.z = -point.z;\n\n            return convertedPoint;\n        }\n\n        public static UnityEngine.Vector3 ConvertVector(Vector3 point)\n        {\n            UnityEngine.Vector3 convertedPoint;\n            convertedPoint.x = point.x;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Common.cs",
      "Content": "urn convertedPoint;\n        }\n\n        public static UnityEngine.Vector3 ConvertVector(Vector3 point)\n        {\n            UnityEngine.Vector3 convertedPoint;\n            convertedPoint.x = point.x;\n            convertedPoint.y = point.y;\n            convertedPoint.z = -point.z;\n\n            return convertedPoint;\n        }\n\n        public static Matrix4x4 ConvertTransform(Transform transform)\n        {\n            UnityEngine.Matrix4x4 flipZ = UnityEngine.Matrix4x4.Scale(new UnityEngine.Vector3(1, 1, -1));\n            UnityEngine.Matrix4x4 flippedMatrix = flipZ * transform.localToWorldMatrix * flipZ;\n\n            var matrix = new Matrix4x4();\n            matrix.m00 = flippedMatrix.m00;\n            matrix.m01 = flippedMatrix.m01;\n            matrix.m02 = flippedMatrix.m02;\n            matrix.m03 = flippedMatrix.m03;\n            matrix.m10 = flippedMatrix.m10;\n            matrix.m11 = flippedMatrix.m11;\n            matrix.m12 = flippedMatrix.m12;\n            matrix.m13 = flippedMatrix.m13;\n            matrix.m20 = flippedMatrix.m20;\n            matrix.m21 = flippedMatrix.m21;\n            matrix.m22 = flippedMatrix.m22;\n            matrix.m23 = flippedMatrix.m23;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Common.cs",
      "Content": "13 = flippedMatrix.m13;\n            matrix.m20 = flippedMatrix.m20;\n            matrix.m21 = flippedMatrix.m21;\n            matrix.m22 = flippedMatrix.m22;\n            matrix.m23 = flippedMatrix.m23;\n            matrix.m30 = flippedMatrix.m30;\n            matrix.m31 = flippedMatrix.m31;\n            matrix.m32 = flippedMatrix.m32;\n            matrix.m33 = flippedMatrix.m33;\n\n            return matrix;\n        }\n\n        public static Matrix4x4 TransposeMatrix(Matrix4x4 inMatrix)\n        {\n            var outMatrix = new Matrix4x4();\n\n            outMatrix.m00 = inMatrix.m00;\n            outMatrix.m01 = inMatrix.m10;\n            outMatrix.m02 = inMatrix.m20;\n            outMatrix.m03 = inMatrix.m30;\n            outMatrix.m10 = inMatrix.m01;\n            outMatrix.m11 = inMatrix.m11;\n            outMatrix.m12 = inMatrix.m21;\n            outMatrix.m13 = inMatrix.m31;\n            outMatrix.m20 = inMatrix.m02;\n            outMatrix.m21 = inMatrix.m12;\n            outMatrix.m22 = inMatrix.m22;\n            outMatrix.m23 = inMatrix.m32;\n            outMatrix.m30 = inMatrix.m03;\n            outMatrix.m31 = inMatrix.m13;\n            outMatrix.m32 = inMatrix.m23;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Common.cs",
      "Content": "outMatrix.m22 = inMatrix.m22;\n            outMatrix.m23 = inMatrix.m32;\n            outMatrix.m30 = inMatrix.m03;\n            outMatrix.m31 = inMatrix.m13;\n            outMatrix.m32 = inMatrix.m23;\n            outMatrix.m33 = inMatrix.m33;\n\n            return outMatrix;\n        }\n\n        public static Matrix4x4 TransformMatrix(UnityEngine.Matrix4x4 inMatrix)\n        {\n            var outMatrix = new Matrix4x4();\n\n            outMatrix.m00 = inMatrix.m00;\n            outMatrix.m01 = inMatrix.m01;\n            outMatrix.m02 = inMatrix.m02;\n            outMatrix.m03 = inMatrix.m03;\n            outMatrix.m10 = inMatrix.m10;\n            outMatrix.m11 = inMatrix.m11;\n            outMatrix.m12 = inMatrix.m12;\n            outMatrix.m13 = inMatrix.m13;\n            outMatrix.m20 = inMatrix.m20;\n            outMatrix.m21 = inMatrix.m21;\n            outMatrix.m22 = inMatrix.m22;\n            outMatrix.m23 = inMatrix.m23;\n            outMatrix.m30 = inMatrix.m30;\n            outMatrix.m31 = inMatrix.m31;\n            outMatrix.m32 = inMatrix.m32;\n            outMatrix.m33 = inMatrix.m33;\n\n            return outMatrix;\n        }\n\n        public static byte[] ConvertString(string s)\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Common.cs",
      "Content": "atrix.m31;\n            outMatrix.m32 = inMatrix.m32;\n            outMatrix.m33 = inMatrix.m33;\n\n            return outMatrix;\n        }\n\n        public static byte[] ConvertString(string s)\n        {\n            return Encoding.UTF8.GetBytes(s + Char.MinValue);\n        }\n\n        public static string GetStreamingAssetsFileName(string fileName)\n        {\n            var streamingAssetsFileName = Path.Combine(Application.streamingAssetsPath, fileName);\n\n#if UNITY_ANDROID && !UNITY_EDITOR\n            var tempFileName = Path.Combine(Application.temporaryCachePath, fileName);\n\n            if (File.Exists(tempFileName))\n            {\n                File.Delete(tempFileName);\n            }\n\n            try\n            {\n                var streamingAssetLoader = new WWW(streamingAssetsFileName);\n                while (!streamingAssetLoader.isDone)\n                {\n                }\n\n                if (string.IsNullOrEmpty(streamingAssetLoader.error))\n                {\n                    using (var dataWriter = new BinaryWriter(new FileStream(tempFileName, FileMode.Create)))\n                    {\n                        dataWriter.Write(streamingAssetLoader.bytes);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Common.cs",
      "Content": "using (var dataWriter = new BinaryWriter(new FileStream(tempFileName, FileMode.Create)))\n                    {\n                        dataWriter.Write(streamingAssetLoader.bytes);\n                        dataWriter.Close();\n                    }\n                }\n                else\n                {\n                    Debug.LogError(streamingAssetLoader.error);\n                }\n            }\n            catch (Exception exception)\n            {\n                Debug.LogError(exception.ToString());\n            }\n\n            return tempFileName;\n#else\n            return streamingAssetsFileName;\n#endif\n        }\n\n        public static string HumanReadableDataSize(int dataSize)\n        {\n            if (dataSize < 1e3)\n            {\n                return dataSize.ToString() + \" bytes\";\n            }\n            else if (dataSize < 1e6)\n            {\n                return (dataSize / 1e3f).ToString(\"0.0\") + \" kB\";\n            }\n            else if (dataSize < 1e9)\n            {\n                return (dataSize / 1e6f).ToString(\"0.0\") + \" MB\";\n            }\n            else\n            {\n                return (dataSize / 1e9f).ToString(\"0.0\") + \" GB\";"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Common.cs",
      "Content": "e < 1e9)\n            {\n                return (dataSize / 1e6f).ToString(\"0.0\") + \" MB\";\n            }\n            else\n            {\n                return (dataSize / 1e9f).ToString(\"0.0\") + \" GB\";\n            }\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Context.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing AOT;\nusing System;\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    public class Context\n    {\n        IntPtr mContext = IntPtr.Zero;\n\n        public Context()\n        {\n            var contextSettings = new ContextSettings { };\n            contextSettings.version = Constants.kVersion;\n            contextSettings.logCallback = LogMessage;\n            contextSettings.simdLevel = SIMDLevel.AVX2;\n\n            if (SteamAudioSettings.Singleton.EnableValidation)\n            {\n                contextSettings.flags = contextSettings.flags | ContextFlags.Validation;\n            }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Context.cs",
      "Content": "= SIMDLevel.AVX2;\n\n            if (SteamAudioSettings.Singleton.EnableValidation)\n            {\n                contextSettings.flags = contextSettings.flags | ContextFlags.Validation;\n            }\n\n            var status = API.iplContextCreate(ref contextSettings, out mContext);\n            if (status != Error.Success)\n                throw new Exception(string.Format(\"Unable to create context. [{0}]\", status));\n        }\n\n        public Context(Context context)\n        {\n            mContext = API.iplContextRetain(context.Get());\n        }\n\n        ~Context()\n        {\n            Release();\n        }\n\n        public void Release()\n        {\n            API.iplContextRelease(ref mContext);\n        }\n\n        public IntPtr Get()\n        {\n            return mContext;\n        }\n\n        [MonoPInvokeCallback(typeof(LogCallback))]\n        public static void LogMessage(LogLevel level, string message)\n        {\n            switch (level)\n            {\n            case LogLevel.Info:\n            case LogLevel.Debug:\n                Debug.Log(message);\n                break;\n            case LogLevel.Warning:\n                Debug.LogWarning(message);\n                break;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Context.cs",
      "Content": ".Info:\n            case LogLevel.Debug:\n                Debug.Log(message);\n                break;\n            case LogLevel.Warning:\n                Debug.LogWarning(message);\n                break;\n            case LogLevel.Error:\n                Debug.LogError(message);\n                break;\n            default:\n                break;\n            }\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/EmbreeDevice.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing System;\n\nnamespace SteamAudio\n{\n    public class EmbreeDevice\n    {\n        IntPtr mEmbreeDevice = IntPtr.Zero;\n\n        public EmbreeDevice(Context context)\n        {\n            var embreeDeviceSettings = new EmbreeDeviceSettings { };\n\n            var status = API.iplEmbreeDeviceCreate(context.Get(), ref embreeDeviceSettings, out mEmbreeDevice);\n            if (status != Error.Success)\n                throw new Exception(string.Format(\"Unable to create Embree device. [{0}]\", status));\n        }\n\n        public EmbreeDevice(EmbreeDevice embreeDevice)\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/EmbreeDevice.cs",
      "Content": "atus != Error.Success)\n                throw new Exception(string.Format(\"Unable to create Embree device. [{0}]\", status));\n        }\n\n        public EmbreeDevice(EmbreeDevice embreeDevice)\n        {\n            mEmbreeDevice = API.iplEmbreeDeviceRetain(embreeDevice.mEmbreeDevice);\n        }\n\n        ~EmbreeDevice()\n        {\n            Release();\n        }\n\n        public void Release()\n        {\n            API.iplEmbreeDeviceRelease(ref mEmbreeDevice);\n        }\n\n        public IntPtr Get()\n        {\n            return mEmbreeDevice;\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/HRTF.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing System;\nusing System.Runtime.InteropServices;\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    public class HRTF\n    {\n        IntPtr mHRTF = IntPtr.Zero;\n\n        public HRTF(Context context, AudioSettings audioSettings, string sofaFileName, byte[] sofaFileData, float gaindB, HRTFNormType normType)\n        {\n            IntPtr sofaData = IntPtr.Zero;\n\n            var hrtfSettings = new HRTFSettings { };\n            if (sofaFileData != null && sofaFileData.Length > 0)\n            {\n                hrtfSettings.type = HRTFType.SOFA;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/HRTF.cs",
      "Content": "= IntPtr.Zero;\n\n            var hrtfSettings = new HRTFSettings { };\n            if (sofaFileData != null && sofaFileData.Length > 0)\n            {\n                hrtfSettings.type = HRTFType.SOFA;\n\n                sofaData = Marshal.AllocHGlobal(sofaFileData.Length);\n                Marshal.Copy(sofaFileData, 0, sofaData, sofaFileData.Length);\n\n                hrtfSettings.sofaFileData = sofaData;\n                hrtfSettings.sofaFileDataSize = sofaFileData.Length;\n            }\n            else if (sofaFileName != null)\n            {\n                hrtfSettings.type = HRTFType.SOFA;\n                hrtfSettings.sofaFileName = sofaFileName;\n            }\n            else\n            {\n                hrtfSettings.type = HRTFType.Default;\n            }\n\n            hrtfSettings.volume = dBToGain(gaindB);\n            hrtfSettings.normType = normType;\n\n            var status = API.iplHRTFCreate(context.Get(), ref audioSettings, ref hrtfSettings, out mHRTF);\n            if (status != Error.Success)\n            {\n                Debug.LogError(string.Format(\"Unable to load HRTF: {0}. [{1}]\", (sofaFileName != null) ? sofaFileName : \"default\", status));"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/HRTF.cs",
      "Content": "F);\n            if (status != Error.Success)\n            {\n                Debug.LogError(string.Format(\"Unable to load HRTF: {0}. [{1}]\", (sofaFileName != null) ? sofaFileName : \"default\", status));\n                mHRTF = IntPtr.Zero;\n            }\n            else\n            {\n                Debug.Log(string.Format(\"Loaded HRTF: {0}.\", (sofaFileName != null) ? sofaFileName : \"default\"));\n            }\n\n            if (sofaData != IntPtr.Zero)\n            {\n                Marshal.FreeHGlobal(sofaData);\n            }\n        }\n\n        public HRTF(HRTF hrtf)\n        {\n            mHRTF = API.iplHRTFRetain(hrtf.Get());\n        }\n\n        ~HRTF()\n        {\n            Release();\n        }\n\n        public void Release()\n        {\n            API.iplHRTFRelease(ref mHRTF);\n        }\n\n        public IntPtr Get()\n        {\n            return mHRTF;\n        }\n\n        private float dBToGain(float gaindB)\n        {\n            const float kMinDBLevel = -90.0f;\n\n            if (gaindB <= kMinDBLevel)\n                return 0.0f;\n\n            return  (float) Math.Pow(10.0, (double) gaindB * (1.0 / 20.0));\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/InstancedMesh.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n#if STEAMAUDIO_ENABLED\n\nusing System;\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    public class InstancedMesh\n    {\n        IntPtr mInstancedMesh = IntPtr.Zero;\n\n        public InstancedMesh(Scene scene, Scene subScene, Transform transform)\n        {\n            var instancedMeshSettings = new InstancedMeshSettings { };\n            instancedMeshSettings.subScene = subScene.Get();\n            instancedMeshSettings.transform = Common.ConvertTransform(transform);\n\n            var status = API.iplInstancedMeshCreate(scene.Get(), ref instancedMeshSettings, out mInstancedMesh);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/InstancedMesh.cs",
      "Content": "();\n            instancedMeshSettings.transform = Common.ConvertTransform(transform);\n\n            var status = API.iplInstancedMeshCreate(scene.Get(), ref instancedMeshSettings, out mInstancedMesh);\n            if (status != Error.Success)\n                throw new Exception(string.Format(\"Unable to create instanced mesh ({0}). [{1}]\", transform.gameObject.name, status));\n        }\n\n        public InstancedMesh(InstancedMesh instancedMesh)\n        {\n            mInstancedMesh = API.iplInstancedMeshRetain(instancedMesh.mInstancedMesh);\n        }\n\n        ~InstancedMesh()\n        {\n            Release();\n        }\n\n        public void Release()\n        {\n            API.iplInstancedMeshRelease(ref mInstancedMesh);\n        }\n\n        public IntPtr Get()\n        {\n            return mInstancedMesh;\n        }\n\n        public void AddToScene(Scene scene)\n        {\n            API.iplInstancedMeshAdd(mInstancedMesh, scene.Get());\n            scene.NotifyAddObject();\n        }\n\n        public void RemoveFromScene(Scene scene)\n        {\n            API.iplInstancedMeshRemove(mInstancedMesh, scene.Get());\n            scene.NotifyRemoveObject();\n        }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/InstancedMesh.cs",
      "Content": "Object();\n        }\n\n        public void RemoveFromScene(Scene scene)\n        {\n            API.iplInstancedMeshRemove(mInstancedMesh, scene.Get());\n            scene.NotifyRemoveObject();\n        }\n\n        public void UpdateTransform(Scene scene, Transform transform)\n        {\n            API.iplInstancedMeshUpdateTransform(mInstancedMesh, scene.Get(), Common.ConvertTransform(transform));\n        }\n    }\n}\n\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/OpenCLDevice.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing System;\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    public class OpenCLDevice\n    {\n        IntPtr mOpenCLDevice = IntPtr.Zero;\n\n        public OpenCLDevice(Context context, OpenCLDeviceType deviceType, int numCUsToReserve, float fractionCUsForIRUpdate,\n            bool requiresTAN)\n        {\n            var deviceSettings = new OpenCLDeviceSettings { };\n            deviceSettings.type = deviceType;\n            deviceSettings.numCUsToReserve = numCUsToReserve;\n            deviceSettings.fractionCUsForIRUpdate = fractionCUsForIRUpdate;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/OpenCLDevice.cs",
      "Content": "ceSettings { };\n            deviceSettings.type = deviceType;\n            deviceSettings.numCUsToReserve = numCUsToReserve;\n            deviceSettings.fractionCUsForIRUpdate = fractionCUsForIRUpdate;\n            deviceSettings.requiresTAN = requiresTAN ? Bool.True : Bool.False;\n\n            var deviceList = IntPtr.Zero;\n            var status = API.iplOpenCLDeviceListCreate(context.Get(), ref deviceSettings, out deviceList);\n            if (status != Error.Success)\n                throw new Exception(string.Format(\"Unable to enumerate OpenCL devices. [{0}]\", status));\n\n            var numDevices = API.iplOpenCLDeviceListGetNumDevices(deviceList);\n            if (numDevices <= 0)\n            {\n                API.iplOpenCLDeviceListRelease(ref deviceList);\n\n                // If we explicitly requested a device that supports TAN, or if we didn't ask for CU\n                // reservation, but still didn't find any devices, stop.\n                if (requiresTAN || numCUsToReserve == 0)\n                    throw new Exception(string.Format(\"No OpenCL devices found.\"));\n\n                Debug.LogWarning(\"No OpenCL devices found that match the provided parameters, attempting to \" +"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/OpenCLDevice.cs",
      "Content": "0)\n                    throw new Exception(string.Format(\"No OpenCL devices found.\"));\n\n                Debug.LogWarning(\"No OpenCL devices found that match the provided parameters, attempting to \" +\n                    \"initialize without CU reservation.\");\n\n                deviceSettings.numCUsToReserve = 0;\n                deviceSettings.fractionCUsForIRUpdate = 0.0f;\n                status = API.iplOpenCLDeviceListCreate(context.Get(), ref deviceSettings, out deviceList);\n                if (status != Error.Success)\n                    throw new Exception(string.Format(\"Unable to enumerate OpenCL devices. [{0}]\", status));\n\n                numDevices = API.iplOpenCLDeviceListGetNumDevices(deviceList);\n                if (numDevices <= 0)\n                    throw new Exception(string.Format(\"No OpenCL devices found.\"));\n            }\n\n            status = API.iplOpenCLDeviceCreate(context.Get(), deviceList, 0, out mOpenCLDevice);\n            if (status != Error.Success)\n            {\n                API.iplOpenCLDeviceListRelease(ref deviceList);\n                throw new Exception(string.Format(\"Unable to create OpenCL device. [{0}]\", status));\n            }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/OpenCLDevice.cs",
      "Content": "cess)\n            {\n                API.iplOpenCLDeviceListRelease(ref deviceList);\n                throw new Exception(string.Format(\"Unable to create OpenCL device. [{0}]\", status));\n            }\n\n            API.iplOpenCLDeviceListRelease(ref deviceList);\n        }\n\n        public OpenCLDevice(OpenCLDevice device)\n        {\n            mOpenCLDevice = API.iplOpenCLDeviceRetain(device.mOpenCLDevice);\n        }\n\n        ~OpenCLDevice()\n        {\n            Release();\n        }\n\n        public void Release()\n        {\n            API.iplOpenCLDeviceRelease(ref mOpenCLDevice);\n        }\n\n        public IntPtr Get()\n        {\n            return mOpenCLDevice;\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/ProbeBatch.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n#if STEAMAUDIO_ENABLED\n\nusing System;\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    public class ProbeArray\n    {\n        IntPtr mProbeArray = IntPtr.Zero;\n\n        public ProbeArray(Context context)\n        {\n            API.iplProbeArrayCreate(context.Get(), out mProbeArray);\n        }\n\n        public ProbeArray(ProbeArray probeArray)\n        {\n            mProbeArray = API.iplProbeArrayRetain(probeArray.mProbeArray);\n        }\n\n        ~ProbeArray()\n        {\n            Release();\n        }\n\n        public void Release()\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/ProbeBatch.cs",
      "Content": "{\n            mProbeArray = API.iplProbeArrayRetain(probeArray.mProbeArray);\n        }\n\n        ~ProbeArray()\n        {\n            Release();\n        }\n\n        public void Release()\n        {\n            API.iplProbeArrayRelease(ref mProbeArray);\n        }\n\n        public IntPtr Get()\n        {\n            return mProbeArray;\n        }\n\n        public void GenerateProbes(Scene scene, ProbeGenerationParams probeGenerationParams)\n        {\n            API.iplProbeArrayGenerateProbes(mProbeArray, scene.Get(), ref probeGenerationParams);\n        }\n\n        public int GetNumProbes()\n        {\n            return API.iplProbeArrayGetNumProbes(mProbeArray);\n        }\n\n        public Sphere GetProbe(int index)\n        {\n            return API.iplProbeArrayGetProbe(mProbeArray, index);\n        }\n    }\n\n    public class ProbeBatch\n    {\n        Context mContext = null;\n        IntPtr mProbeBatch = IntPtr.Zero;\n\n        public ProbeBatch(Context context)\n        {\n            mContext = context;\n\n            API.iplProbeBatchCreate(context.Get(), out mProbeBatch);\n        }\n\n        public ProbeBatch(Context context, SerializedData dataAsset)\n        {\n            mContext = context;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/ProbeBatch.cs",
      "Content": "ntext;\n\n            API.iplProbeBatchCreate(context.Get(), out mProbeBatch);\n        }\n\n        public ProbeBatch(Context context, SerializedData dataAsset)\n        {\n            mContext = context;\n\n            var serializedObject = new SerializedObject(context, dataAsset);\n\n            var status = API.iplProbeBatchLoad(context.Get(), serializedObject.Get(), out mProbeBatch);\n            if (status != Error.Success)\n            {\n                Debug.LogError(string.Format(\"Unable to load Probe Batch from {0}.\", dataAsset.name));\n                mProbeBatch = IntPtr.Zero;\n            }\n\n            serializedObject.Release();\n        }\n\n        public ProbeBatch(ProbeBatch probeBatch)\n        {\n            mContext = probeBatch.mContext;\n\n            mProbeBatch = API.iplProbeBatchRetain(probeBatch.mProbeBatch);\n        }\n\n        ~ProbeBatch()\n        {\n            Release();\n        }\n\n        public void Release()\n        {\n            API.iplProbeBatchRelease(ref mProbeBatch);\n\n            mContext = null;\n        }\n\n        public IntPtr Get()\n        {\n            return mProbeBatch;\n        }\n\n        public int Save(SerializedData dataAsset, bool flush = true)"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/ProbeBatch.cs",
      "Content": "eBatch);\n\n            mContext = null;\n        }\n\n        public IntPtr Get()\n        {\n            return mProbeBatch;\n        }\n\n        public int Save(SerializedData dataAsset, bool flush = true)\n        {\n            var serializedObject = new SerializedObject(mContext);\n            API.iplProbeBatchSave(mProbeBatch, serializedObject.Get());\n            var size = (int) serializedObject.GetSize();\n            serializedObject.WriteToFile(dataAsset, flush);\n            serializedObject.Release();\n            return size;\n        }\n\n        public void AddProbeArray(ProbeArray probeArray)\n        {\n            API.iplProbeBatchAddProbeArray(mProbeBatch, probeArray.Get());\n        }\n\n        public void AddProbe(Sphere probe)\n        {\n            API.iplProbeBatchAddProbe(mProbeBatch, probe);\n        }\n\n        public void Commit()\n        {\n            API.iplProbeBatchCommit(mProbeBatch);\n        }\n\n        public void RemoveData(BakedDataIdentifier identifier)\n        {\n            API.iplProbeBatchRemoveData(mProbeBatch, ref identifier);\n        }\n\n        public UIntPtr GetDataSize(BakedDataIdentifier identifier)\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/ProbeBatch.cs",
      "Content": "BakedDataIdentifier identifier)\n        {\n            API.iplProbeBatchRemoveData(mProbeBatch, ref identifier);\n        }\n\n        public UIntPtr GetDataSize(BakedDataIdentifier identifier)\n        {\n            return API.iplProbeBatchGetDataSize(mProbeBatch, ref identifier);\n        }\n    }\n}\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/RadeonRaysDevice.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing System;\n\nnamespace SteamAudio\n{\n    public class RadeonRaysDevice\n    {\n        IntPtr mRadeonRaysDevice = IntPtr.Zero;\n\n        public RadeonRaysDevice(OpenCLDevice openCLDevice)\n        {\n            var deviceSettings = new RadeonRaysDeviceSettings { };\n\n            var status = API.iplRadeonRaysDeviceCreate(openCLDevice.Get(), ref deviceSettings, out mRadeonRaysDevice);\n            if (status != Error.Success)\n                throw new Exception(string.Format(\"Unable to create Radeon Rays device. [{0}]\", status));\n        }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/RadeonRaysDevice.cs",
      "Content": "f deviceSettings, out mRadeonRaysDevice);\n            if (status != Error.Success)\n                throw new Exception(string.Format(\"Unable to create Radeon Rays device. [{0}]\", status));\n        }\n\n        public RadeonRaysDevice(RadeonRaysDevice device)\n        {\n            mRadeonRaysDevice = API.iplRadeonRaysDeviceRetain(device.mRadeonRaysDevice);\n        }\n\n        ~RadeonRaysDevice()\n        {\n            Release();\n        }\n\n        public void Release()\n        {\n            API.iplRadeonRaysDeviceRelease(ref mRadeonRaysDevice);\n        }\n\n        public IntPtr Get()\n        {\n            return mRadeonRaysDevice;\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SOFAFile.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    /*\n     * Represents a serializable object that is created when importing a .sofa file as an asset.\n     */\n    public class SOFAFile : ScriptableObject\n    {\n        // The name of the sofa file that was imported.\n        public string sofaName = \"\";\n\n        // The imported data.\n        public byte[] data = null;\n\n        // The volume correction factor in dB.\n        public float volume = 0.0f;\n\n        // Volume normalization type.\n        public HRTFNormType normType = HRTFNormType.None;\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Scene.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n#if STEAMAUDIO_ENABLED\n\nusing System;\n\nnamespace SteamAudio\n{\n    public class Scene\n    {\n        Context mContext = null;\n        IntPtr mScene = IntPtr.Zero;\n        int mNumObjects = 0;\n\n        public Scene(Context context, SceneType type, EmbreeDevice embreeDevice, RadeonRaysDevice radeonRaysDevice, ClosestHitCallback closestHitCallback, AnyHitCallback anyHitCallback)\n        {\n            mContext = context;\n\n            var sceneSettings = new SceneSettings { };\n            sceneSettings.type = type;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Scene.cs",
      "Content": "HitCallback closestHitCallback, AnyHitCallback anyHitCallback)\n        {\n            mContext = context;\n\n            var sceneSettings = new SceneSettings { };\n            sceneSettings.type = type;\n            sceneSettings.embreeDevice = (embreeDevice != null) ? embreeDevice.Get() : IntPtr.Zero;\n            sceneSettings.radeonRaysDevice = (radeonRaysDevice != null) ? radeonRaysDevice.Get() : IntPtr.Zero;\n            sceneSettings.closestHitCallback = closestHitCallback;\n            sceneSettings.anyHitCallback = anyHitCallback;\n\n            var status = API.iplSceneCreate(context.Get(), ref sceneSettings, out mScene);\n            if (status != Error.Success)\n                throw new Exception(string.Format(\"Unable to create scene [{0}]\", status.ToString()));\n        }\n\n        public Scene(Context context, SceneSettings sceneSettings, SerializedData dataAsset)\n        {\n            mContext = context;\n\n            var serializedObject = new SerializedObject(context, dataAsset);\n            var status = API.iplSceneLoad(context.Get(), ref sceneSettings, serializedObject.Get(), null, IntPtr.Zero, out mScene);\n            if (status != Error.Success)"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Scene.cs",
      "Content": "bject(context, dataAsset);\n            var status = API.iplSceneLoad(context.Get(), ref sceneSettings, serializedObject.Get(), null, IntPtr.Zero, out mScene);\n            if (status != Error.Success)\n                throw new Exception(string.Format(\"Unable to load scene [{0}]\", status.ToString()));\n\n            serializedObject.Release();\n        }\n\n        public Scene(Scene scene)\n        {\n            mContext = scene.mContext;\n\n            mScene = API.iplSceneRetain(scene.mScene);\n        }\n\n        ~Scene()\n        {\n            Release();\n        }\n\n        public void Release()\n        {\n            API.iplSceneRelease(ref mScene);\n\n            mContext = null;\n        }\n\n        public IntPtr Get()\n        {\n            return mScene;\n        }\n\n        public void Save(SerializedData dataAsset)\n        {\n            var serializedObject = new SerializedObject(mContext);\n            API.iplSceneSave(mScene, serializedObject.Get());\n            serializedObject.WriteToFile(dataAsset);\n            serializedObject.Release();\n        }\n\n        public void SaveOBJ(string fileBaseName)\n        {\n            API.iplSceneSaveOBJ(mScene, fileBaseName);\n        }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Scene.cs",
      "Content": "WriteToFile(dataAsset);\n            serializedObject.Release();\n        }\n\n        public void SaveOBJ(string fileBaseName)\n        {\n            API.iplSceneSaveOBJ(mScene, fileBaseName);\n        }\n\n        public void NotifyAddObject()\n        {\n            ++mNumObjects;\n        }\n\n        public void NotifyRemoveObject()\n        {\n            --mNumObjects;\n        }\n\n        public int GetNumObjects()\n        {\n            return mNumObjects;\n        }\n\n        public void Commit()\n        {\n            API.iplSceneCommit(mScene);\n        }\n    }\n}\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SerializedData.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEngine;\n#if UNITY_EDITOR\nusing UnityEditor;\n#endif\n\nnamespace SteamAudio\n{\n    public class SerializedData : ScriptableObject\n    {\n        [SerializeField]\n        public byte[] data;\n\n        public static SerializedData PromptForNewAsset(string defaultFileName)\n        {\n#if UNITY_EDITOR\n            var fileName = EditorUtility.SaveFilePanelInProject(\"Export\", defaultFileName, \"asset\",\n                \"Select a file to export data to.\");\n\n            if (fileName != null && fileName.Length > 0)\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SerializedData.cs",
      "Content": "= EditorUtility.SaveFilePanelInProject(\"Export\", defaultFileName, \"asset\",\n                \"Select a file to export data to.\");\n\n            if (fileName != null && fileName.Length > 0)\n            {\n                var dataAsset = ScriptableObject.CreateInstance<SerializedData>();\n                AssetDatabase.CreateAsset(dataAsset, fileName);\n                return dataAsset;\n            }\n#endif\n            return null;\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SerializedObject.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n#if STEAMAUDIO_ENABLED\n\nusing System;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\n#if UNITY_EDITOR\nusing UnityEditor;\n#endif\n\nnamespace SteamAudio\n{\n    public class SerializedObject\n    {\n        IntPtr mSerializedObject = IntPtr.Zero;\n        IntPtr mDataBuffer = IntPtr.Zero;\n\n        static List<SerializedData> sAssetsToFlush = null;\n\n        public SerializedObject(Context context)\n        {\n            var serializedObjectSettings = new SerializedObjectSettings { };"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SerializedObject.cs",
      "Content": ";\n\n        static List<SerializedData> sAssetsToFlush = null;\n\n        public SerializedObject(Context context)\n        {\n            var serializedObjectSettings = new SerializedObjectSettings { };\n\n            API.iplSerializedObjectCreate(context.Get(), ref serializedObjectSettings, out mSerializedObject);\n        }\n\n        public SerializedObject(Context context, SerializedData dataAsset)\n        {\n            var data = dataAsset.data;\n            mDataBuffer = Marshal.AllocHGlobal(data.Length);\n\n            Marshal.Copy(data, 0, mDataBuffer, data.Length);\n\n            var serializedObjectSettings = new SerializedObjectSettings { };\n            serializedObjectSettings.data = mDataBuffer;\n            serializedObjectSettings.size = (UIntPtr) data.Length;\n\n            API.iplSerializedObjectCreate(context.Get(), ref serializedObjectSettings, out mSerializedObject);\n        }\n\n        public SerializedObject(SerializedObject serializedObject)\n        {\n            mSerializedObject = API.iplSerializedObjectRetain(serializedObject.Get());\n        }\n\n        ~SerializedObject()\n        {\n            Release();\n        }\n\n        public void Release()\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SerializedObject.cs",
      "Content": "mSerializedObject = API.iplSerializedObjectRetain(serializedObject.Get());\n        }\n\n        ~SerializedObject()\n        {\n            Release();\n        }\n\n        public void Release()\n        {\n            if (mDataBuffer != IntPtr.Zero)\n            {\n                Marshal.FreeHGlobal(mDataBuffer);\n                mDataBuffer = IntPtr.Zero;\n            }\n\n            API.iplSerializedObjectRelease(ref mSerializedObject);\n        }\n\n        public IntPtr Get()\n        {\n            return mSerializedObject;\n        }\n\n        public UIntPtr GetSize()\n        {\n            return API.iplSerializedObjectGetSize(mSerializedObject);\n        }\n\n        public IntPtr GetData()\n        {\n            return API.iplSerializedObjectGetData(mSerializedObject);\n        }\n\n        public void WriteToFile(SerializedData dataAsset, bool flush = true)\n        {\n            var dataSize = GetSize();\n            var dataBuffer = GetData();\n\n            dataAsset.data = new byte[(int) dataSize];\n            Marshal.Copy(dataBuffer, dataAsset.data, 0, (int) dataSize);\n\n            if (flush)\n            {\n                FlushWrite(dataAsset);\n            }\n            else\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SerializedObject.cs",
      "Content": "ze];\n            Marshal.Copy(dataBuffer, dataAsset.data, 0, (int) dataSize);\n\n            if (flush)\n            {\n                FlushWrite(dataAsset);\n            }\n            else\n            {\n                if (sAssetsToFlush == null)\n                {\n                    sAssetsToFlush = new List<SerializedData>();\n                }\n\n                sAssetsToFlush.Add(dataAsset);\n            }\n        }\n\n        public static void FlushWrite(SerializedData dataAsset)\n        {\n#if UNITY_EDITOR\n            var assetPaths = new string[1];\n            assetPaths[0] = AssetDatabase.GetAssetPath(dataAsset);\n\n            // TODO: Deprecate older versions of Unity.\n#if UNITY_2017_3_OR_NEWER\n            AssetDatabase.ForceReserializeAssets(assetPaths);\n#endif\n#endif\n        }\n\n        public static void FlushAllWrites()\n        {\n            if (sAssetsToFlush == null)\n                return;\n\n            foreach (var dataAsset in sAssetsToFlush)\n            {\n                FlushWrite(dataAsset);\n            }\n\n            sAssetsToFlush.Clear();\n        }\n    }\n}\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Simulator.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n#if STEAMAUDIO_ENABLED\n\nusing System;\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    public class Simulator\n    {\n        IntPtr mSimulator = IntPtr.Zero;\n\n        public Simulator(Context context, SimulationSettings simulationSettings)\n        {\n            var status = API.iplSimulatorCreate(context.Get(), ref simulationSettings, out mSimulator);\n            if (status != Error.Success)\n                throw new Exception(string.Format(\"Unable to create simulator. [{0}]\", status));\n        }\n\n        public Simulator(Simulator simulator)\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Simulator.cs",
      "Content": "if (status != Error.Success)\n                throw new Exception(string.Format(\"Unable to create simulator. [{0}]\", status));\n        }\n\n        public Simulator(Simulator simulator)\n        {\n            mSimulator = API.iplSimulatorRetain(simulator.mSimulator);\n        }\n\n        ~Simulator()\n        {\n            Release();\n        }\n\n        public void Release()\n        {\n            API.iplSimulatorRelease(ref mSimulator);\n        }\n\n        public IntPtr Get()\n        {\n            return mSimulator;\n        }\n\n        public void SetScene(Scene scene)\n        {\n            API.iplSimulatorSetScene(mSimulator, scene.Get());\n        }\n\n        public void AddProbeBatch(ProbeBatch probeBatch)\n        {\n            API.iplSimulatorAddProbeBatch(mSimulator, probeBatch.Get());\n        }\n\n        public void RemoveProbeBatch(ProbeBatch probeBatch)\n        {\n            API.iplSimulatorRemoveProbeBatch(mSimulator, probeBatch.Get());\n        }\n\n        public void SetSharedInputs(SimulationFlags flags, SimulationSharedInputs sharedInputs)\n        {\n            API.iplSimulatorSetSharedInputs(mSimulator, flags, ref sharedInputs);\n        }\n\n        public void Commit()"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Simulator.cs",
      "Content": "dInputs(SimulationFlags flags, SimulationSharedInputs sharedInputs)\n        {\n            API.iplSimulatorSetSharedInputs(mSimulator, flags, ref sharedInputs);\n        }\n\n        public void Commit()\n        {\n            API.iplSimulatorCommit(mSimulator);\n        }\n\n        public void RunDirect()\n        {\n            API.iplSimulatorRunDirect(mSimulator);\n        }\n\n        public void RunReflections()\n        {\n            API.iplSimulatorRunReflections(mSimulator);\n        }\n\n        public void RunPathing()\n        {\n            API.iplSimulatorRunPathing(mSimulator);\n        }\n    }\n\n    public class Source\n    {\n        IntPtr mSource = IntPtr.Zero;\n\n        public Source(Simulator simulator, SimulationSettings simulationSettings)\n        {\n            var sourceSettings = new SourceSettings { };\n            sourceSettings.flags = simulationSettings.flags;\n\n            var status = API.iplSourceCreate(simulator.Get(), ref sourceSettings, out mSource);\n            if (status != Error.Success)\n                throw new Exception(string.Format(\"Unable to create source for simulation. [{0}]\", status));\n        }\n\n        public Source(Source source)\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/Simulator.cs",
      "Content": "if (status != Error.Success)\n                throw new Exception(string.Format(\"Unable to create source for simulation. [{0}]\", status));\n        }\n\n        public Source(Source source)\n        {\n            mSource = API.iplSourceRetain(source.mSource);\n        }\n\n        ~Source()\n        {\n            Release();\n        }\n\n        public void Release()\n        {\n            API.iplSourceRelease(ref mSource);\n        }\n\n        public IntPtr Get()\n        {\n            return mSource;\n        }\n\n        public void AddToSimulator(Simulator simulator)\n        {\n            API.iplSourceAdd(mSource, simulator.Get());\n        }\n\n        public void RemoveFromSimulator(Simulator simulator)\n        {\n            API.iplSourceRemove(mSource, simulator.Get());\n        }\n\n        public void SetInputs(SimulationFlags flags, SimulationInputs inputs)\n        {\n            API.iplSourceSetInputs(mSource, flags, ref inputs);\n        }\n\n        public SimulationOutputs GetOutputs(SimulationFlags flags)\n        {\n            var outputs = new SimulationOutputs { };\n            API.iplSourceGetOutputs(mSource, flags, ref outputs);\n            return outputs;\n        }\n    }\n}\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/StaticMesh.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n#if STEAMAUDIO_ENABLED\n\nusing System;\nusing System.Runtime.InteropServices;\n\nnamespace SteamAudio\n{\n    public class StaticMesh\n    {\n        Context mContext = null;\n        IntPtr mStaticMesh = IntPtr.Zero;\n\n        public StaticMesh(Context context, Scene scene, Vector3[] vertices, Triangle[] triangles, int[] materialIndices, Material[] materials)\n        {\n            mContext = context;\n\n            var verticesBuffer = Marshal.AllocHGlobal(vertices.Length * Marshal.SizeOf(typeof(Vector3)));"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/StaticMesh.cs",
      "Content": "gles, int[] materialIndices, Material[] materials)\n        {\n            mContext = context;\n\n            var verticesBuffer = Marshal.AllocHGlobal(vertices.Length * Marshal.SizeOf(typeof(Vector3)));\n            var trianglesBuffer = Marshal.AllocHGlobal(triangles.Length * Marshal.SizeOf(typeof(Triangle)));\n            var materialIndicesBuffer = Marshal.AllocHGlobal(materialIndices.Length * Marshal.SizeOf(typeof(int)));\n            var materialsBuffer = Marshal.AllocHGlobal(materials.Length * Marshal.SizeOf(typeof(Material)));\n\n            for (var i = 0; i < vertices.Length; ++i)\n            {\n                Marshal.StructureToPtr(vertices[i], new IntPtr(verticesBuffer.ToInt64() + i * Marshal.SizeOf(typeof(Vector3))), false);\n            }\n\n            for (var i = 0; i < triangles.Length; ++i)\n            {\n                Marshal.StructureToPtr(triangles[i], new IntPtr(trianglesBuffer.ToInt64() + i * Marshal.SizeOf(typeof(Triangle))), false);\n            }\n\n            Marshal.Copy(materialIndices, 0, materialIndicesBuffer, triangles.Length);\n\n            for (var i = 0; i < materials.Length; ++i)\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/StaticMesh.cs",
      "Content": "typeof(Triangle))), false);\n            }\n\n            Marshal.Copy(materialIndices, 0, materialIndicesBuffer, triangles.Length);\n\n            for (var i = 0; i < materials.Length; ++i)\n            {\n                Marshal.StructureToPtr(materials[i], new IntPtr(materialsBuffer.ToInt64() + i * Marshal.SizeOf(typeof(Material))), false);\n            }\n\n            var staticMeshSettings = new StaticMeshSettings { };\n            staticMeshSettings.numVertices = vertices.Length;\n            staticMeshSettings.numTriangles = triangles.Length;\n            staticMeshSettings.numMaterials = materials.Length;\n            staticMeshSettings.vertices = verticesBuffer;\n            staticMeshSettings.triangles = trianglesBuffer;\n            staticMeshSettings.materialIndices = materialIndicesBuffer;\n            staticMeshSettings.materials = materialsBuffer;\n\n            var status = API.iplStaticMeshCreate(scene.Get(), ref staticMeshSettings, out mStaticMesh);\n            if (status != Error.Success)\n            {\n                throw new Exception(string.Format(\"Unable to create static mesh for export ({0} vertices, {1} triangles, {2} materials): [{3}]\","
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/StaticMesh.cs",
      "Content": "if (status != Error.Success)\n            {\n                throw new Exception(string.Format(\"Unable to create static mesh for export ({0} vertices, {1} triangles, {2} materials): [{3}]\",\n                    staticMeshSettings.numVertices.ToString(), staticMeshSettings.numTriangles.ToString(), staticMeshSettings.numMaterials.ToString(),\n                    status.ToString()));\n            }\n\n            Marshal.FreeHGlobal(verticesBuffer);\n            Marshal.FreeHGlobal(trianglesBuffer);\n            Marshal.FreeHGlobal(materialIndicesBuffer);\n            Marshal.FreeHGlobal(materialsBuffer);\n        }\n\n        public StaticMesh(Context context, Scene scene, SerializedData dataAsset)\n        {\n            mContext = context;\n\n            var serializedObject = new SerializedObject(context, dataAsset);\n\n            var status = API.iplStaticMeshLoad(scene.Get(), serializedObject.Get(), null, IntPtr.Zero, out mStaticMesh);\n            if (status != Error.Success)\n                throw new Exception(string.Format(\"Unable to load static mesh ({0}). [{1}]\", dataAsset.name, status));\n\n            serializedObject.Release();\n        }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/StaticMesh.cs",
      "Content": "if (status != Error.Success)\n                throw new Exception(string.Format(\"Unable to load static mesh ({0}). [{1}]\", dataAsset.name, status));\n\n            serializedObject.Release();\n        }\n\n        public StaticMesh(StaticMesh staticMesh)\n        {\n            mContext = staticMesh.mContext;\n\n            mStaticMesh = API.iplStaticMeshRetain(staticMesh.mStaticMesh);\n        }\n\n        ~StaticMesh()\n        {\n            Release();\n        }\n\n        public void Release()\n        {\n            API.iplStaticMeshRelease(ref mStaticMesh);\n\n            mContext = null;\n        }\n\n        public IntPtr Get()\n        {\n            return mStaticMesh;\n        }\n\n        public void Save(SerializedData dataAsset)\n        {\n            var serializedObject = new SerializedObject(mContext);\n            API.iplStaticMeshSave(mStaticMesh, serializedObject.Get());\n            serializedObject.WriteToFile(dataAsset);\n            serializedObject.Release();\n        }\n\n        public void AddToScene(Scene scene)\n        {\n            API.iplStaticMeshAdd(mStaticMesh, scene.Get());\n            scene.NotifyAddObject();\n        }\n\n        public void RemoveFromScene(Scene scene)\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/StaticMesh.cs",
      "Content": "ddToScene(Scene scene)\n        {\n            API.iplStaticMeshAdd(mStaticMesh, scene.Get());\n            scene.NotifyAddObject();\n        }\n\n        public void RemoveFromScene(Scene scene)\n        {\n            API.iplStaticMeshRemove(mStaticMesh, scene.Get());\n            scene.NotifyRemoveObject();\n        }\n    }\n}\n\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing System;\nusing System.Runtime.InteropServices;\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    // CONSTANTS\n\n    public static class Constants\n    {\n        public const uint kVersionMajor = 4;\n        public const uint kVersionMinor = 7;\n        public const uint kVersionPatch = 0;\n        public const uint kVersion = (kVersionMajor << 16) | (kVersionMinor << 8) | kVersionPatch;\n    }\n\n    // ENUMERATIONS\n\n    public enum Bool\n    {\n        False,\n        True\n    }\n\n    public enum Error\n    {\n        Success,\n        Failure,\n        OutOfMemory,\n        Initialization\n    }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "}\n\n    // ENUMERATIONS\n\n    public enum Bool\n    {\n        False,\n        True\n    }\n\n    public enum Error\n    {\n        Success,\n        Failure,\n        OutOfMemory,\n        Initialization\n    }\n\n    public enum LogLevel\n    {\n        Info,\n        Warning,\n        Error,\n        Debug\n    }\n\n    public enum SIMDLevel\n    {\n        SSE2,\n        SSE4,\n        AVX,\n        AVX2,\n        AVX512,\n        NEON = SSE2\n    }\n\n    [Flags]\n    public enum ContextFlags\n    {\n        Validation = 1 << 0,\n        Force32Bit = 0x7fffffff\n    }\n\n    public enum OpenCLDeviceType\n    {\n        Any,\n        CPU,\n        GPU\n    }\n\n    public enum SceneType\n    {\n        Default,\n        Embree,\n        RadeonRays,\n#if UNITY_2019_2_OR_NEWER\n        [InspectorName(\"Unity\")]\n#endif\n        Custom\n    }\n\n    public enum HRTFType\n    {\n        Default,\n        SOFA\n    }\n\n    public enum HRTFNormType\n    {\n        None,\n        RMS\n    }\n\n    public enum ProbeGenerationType\n    {\n        Centroid,\n        UniformFloor\n    }\n\n    public enum BakedDataVariation\n    {\n        Reverb,\n        StaticSource,\n        StaticListener,\n        Dynamic\n    }\n\n    public enum BakedDataType\n    {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "Centroid,\n        UniformFloor\n    }\n\n    public enum BakedDataVariation\n    {\n        Reverb,\n        StaticSource,\n        StaticListener,\n        Dynamic\n    }\n\n    public enum BakedDataType\n    {\n        Reflections,\n        Pathing\n    }\n\n    [Flags]\n    public enum SimulationFlags\n    {\n        Direct = 1 << 0,\n        Reflections = 1 << 1,\n        Pathing = 1 << 2\n    }\n\n    [Flags]\n    public enum DirectSimulationFlags\n    {\n        DistanceAttenuation = 1 << 0,\n        AirAbsorption = 1 << 1,\n        Directivity = 1 << 2,\n        Occlusion = 1 << 3,\n        Transmission = 1 << 4\n    }\n\n    public enum HRTFInterpolation\n    {\n        Nearest,\n        Bilinear\n    }\n\n    public enum DistanceAttenuationModelType\n    {\n        Default,\n        InverseDistance,\n        Callback\n    }\n\n    public enum AirAbsorptionModelType\n    {\n        Default,\n        Exponential,\n        Callback\n    }\n\n    public enum OcclusionType\n    {\n        Raycast,\n        Volumetric\n    }\n\n    [Flags]\n    public enum DirectEffectFlags\n    {\n        ApplyDistanceAttenuation = 1 << 0,\n        ApplyAirAbsorption = 1 << 1,\n        ApplyDirectivity = 1 << 2,\n        ApplyOcclusion = 1 << 3,"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "[Flags]\n    public enum DirectEffectFlags\n    {\n        ApplyDistanceAttenuation = 1 << 0,\n        ApplyAirAbsorption = 1 << 1,\n        ApplyDirectivity = 1 << 2,\n        ApplyOcclusion = 1 << 3,\n        ApplyTransmission = 1 << 4\n    }\n\n    public enum TransmissionType\n    {\n        FrequencyIndependent,\n        FrequencyDependent\n    }\n\n    public enum ReflectionEffectType\n    {\n        Convolution,\n        Parametric,\n        Hybrid,\n#if UNITY_2019_2_OR_NEWER\n        [InspectorName(\"TrueAudio Next\")]\n#endif\n        TrueAudioNext\n    }\n\n    [Flags]\n    public enum ReflectionsBakeFlags\n    {\n        BakeConvolution = 1 << 0,\n        BakeParametric = 1 << 1\n    }\n\n    // CALLBACKS\n\n    [UnmanagedFunctionPointer(CallingConvention.Winapi)]\n    public delegate void ProgressCallback(float progress, IntPtr userData);\n\n    [UnmanagedFunctionPointer(CallingConvention.Winapi)]\n    public delegate void LogCallback(LogLevel level, string message);\n\n    [UnmanagedFunctionPointer(CallingConvention.Winapi)]\n    public delegate IntPtr AllocateCallback(UIntPtr size, UIntPtr alignment);\n\n    [UnmanagedFunctionPointer(CallingConvention.Winapi)]"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "age);\n\n    [UnmanagedFunctionPointer(CallingConvention.Winapi)]\n    public delegate IntPtr AllocateCallback(UIntPtr size, UIntPtr alignment);\n\n    [UnmanagedFunctionPointer(CallingConvention.Winapi)]\n    public delegate void FreeCallback(IntPtr memoryBlock);\n\n    [UnmanagedFunctionPointer(CallingConvention.Winapi)]\n    public delegate void ClosestHitCallback(ref Ray ray, float minDistance, float maxDistance, out Hit hit, IntPtr userData);\n\n    [UnmanagedFunctionPointer(CallingConvention.Winapi)]\n    public delegate void AnyHitCallback(ref Ray ray, float minDistance, float maxDistance, out byte occluded, IntPtr userData);\n\n    [UnmanagedFunctionPointer(CallingConvention.Winapi)]\n    public delegate void BatchedClosestHitCallback(int numRays, Ray[] rays, float[] minDistances, float[] maxDistances, [Out] Hit[] hits, IntPtr userData);\n\n    [UnmanagedFunctionPointer(CallingConvention.Winapi)]\n    public delegate void BatchedAnyHitCallback(int numRays, Ray[] rays, float[] minDistances, float[] maxDistances, [Out] byte[] occluded, IntPtr userData);\n\n    [UnmanagedFunctionPointer(CallingConvention.Winapi)]"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "gate void BatchedAnyHitCallback(int numRays, Ray[] rays, float[] minDistances, float[] maxDistances, [Out] byte[] occluded, IntPtr userData);\n\n    [UnmanagedFunctionPointer(CallingConvention.Winapi)]\n    public delegate float DistanceAttenuationCallback(float distance, IntPtr userData);\n\n    [UnmanagedFunctionPointer(CallingConvention.Winapi)]\n    public delegate float AirAbsorptionCallback(float distance, int band, IntPtr userData);\n\n    [UnmanagedFunctionPointer(CallingConvention.Winapi)]\n    public delegate float DirectivityCallback(Vector3 direction, IntPtr userData);\n\n    [UnmanagedFunctionPointer(CallingConvention.Winapi)]\n    public delegate void PathingVisualizationCallback(Vector3 from, Vector3 to, Bool occluded, IntPtr userData);\n\n    // STRUCTURES\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct ContextSettings\n    {\n        public uint version;\n        public LogCallback logCallback;\n        public AllocateCallback allocateCallback;\n        public FreeCallback freeCallback;\n        public SIMDLevel simdLevel;\n        public ContextFlags flags;\n    }\n\n    [Serializable]\n    [StructLayout(LayoutKind.Sequential)]\n    public struct Vector3\n    {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "c FreeCallback freeCallback;\n        public SIMDLevel simdLevel;\n        public ContextFlags flags;\n    }\n\n    [Serializable]\n    [StructLayout(LayoutKind.Sequential)]\n    public struct Vector3\n    {\n        public float x;\n        public float y;\n        public float z;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct Matrix4x4\n    {\n        public float m00;\n        public float m01;\n        public float m02;\n        public float m03;\n        public float m10;\n        public float m11;\n        public float m12;\n        public float m13;\n        public float m20;\n        public float m21;\n        public float m22;\n        public float m23;\n        public float m30;\n        public float m31;\n        public float m32;\n        public float m33;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct Box\n    {\n        public Vector3 minCoordinates;\n        public Vector3 maxCoordinates;\n    }\n\n    [Serializable]\n    [StructLayout(LayoutKind.Sequential)]\n    public struct Sphere\n    {\n        public Vector3 center;\n        public float radius;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct CoordinateSpace3\n    {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "tKind.Sequential)]\n    public struct Sphere\n    {\n        public Vector3 center;\n        public float radius;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct CoordinateSpace3\n    {\n        public Vector3 right;\n        public Vector3 up;\n        public Vector3 ahead;\n        public Vector3 origin;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct SerializedObjectSettings\n    {\n        public IntPtr data;\n        public UIntPtr size;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct EmbreeDeviceSettings { }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct OpenCLDeviceSettings\n    {\n        public OpenCLDeviceType type;\n        public int numCUsToReserve;\n        public float fractionCUsForIRUpdate;\n        public Bool requiresTAN;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct OpenCLDeviceDesc\n    {\n        public IntPtr platform;\n        public string platformName;\n        public string platformVendor;\n        public string platformVersion;\n        public IntPtr device;\n        public string deviceName;\n        public string deviceVendor;\n        public string deviceVersion;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "string platformVendor;\n        public string platformVersion;\n        public IntPtr device;\n        public string deviceName;\n        public string deviceVendor;\n        public string deviceVersion;\n        public OpenCLDeviceType type;\n        public int numConvolutionCUs;\n        public int numIRUpdateCUs;\n        public int granularity;\n        public float perfScore;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct RadeonRaysDeviceSettings { }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct TrueAudioNextDeviceSettings\n    {\n        public int frameSize;\n        public int irSize;\n        public int order;\n        public int maxSources;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct Triangle\n    {\n        public int index0;\n        public int index1;\n        public int index2;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct Material\n    {\n        public float absorptionLow;\n        public float absorptionMid;\n        public float absorptionHigh;\n        public float scattering;\n        public float transmissionLow;\n        public float transmissionMid;\n        public float transmissionHigh;\n    }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "ionMid;\n        public float absorptionHigh;\n        public float scattering;\n        public float transmissionLow;\n        public float transmissionMid;\n        public float transmissionHigh;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct Ray\n    {\n        public Vector3 origin;\n        public Vector3 direction;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct Hit\n    {\n        public float distance;\n        public int triangleIndex;\n        public int objectIndex;\n        public int materialIndex;\n        public Vector3 normal;\n        public IntPtr material;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct SceneSettings\n    {\n        public SceneType type;\n        public ClosestHitCallback closestHitCallback;\n        public AnyHitCallback anyHitCallback;\n        public BatchedClosestHitCallback batchedClosestHitCallback;\n        public BatchedAnyHitCallback batchedAnyHitCallback;\n        public IntPtr userData;\n        public IntPtr embreeDevice;\n        public IntPtr radeonRaysDevice;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct StaticMeshSettings\n    {\n        public int numVertices;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "public IntPtr embreeDevice;\n        public IntPtr radeonRaysDevice;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct StaticMeshSettings\n    {\n        public int numVertices;\n        public int numTriangles;\n        public int numMaterials;\n        public IntPtr vertices;\n        public IntPtr triangles;\n        public IntPtr materialIndices;\n        public IntPtr materials;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct InstancedMeshSettings\n    {\n        public IntPtr subScene;\n        public Matrix4x4 transform;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct AudioSettings\n    {\n        public int samplingRate;\n        public int frameSize;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct HRTFSettings\n    {\n        public HRTFType type;\n        public string sofaFileName;\n        public IntPtr sofaFileData;\n        public int sofaFileDataSize;\n        public float volume;\n        public HRTFNormType normType;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct ProbeGenerationParams\n    {\n        public ProbeGenerationType type;\n        public float spacing;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "public HRTFNormType normType;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct ProbeGenerationParams\n    {\n        public ProbeGenerationType type;\n        public float spacing;\n        public float height;\n        public Matrix4x4 transform;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    [Serializable]\n    public struct BakedDataIdentifier\n    {\n        public BakedDataType type;\n        public BakedDataVariation variation;\n        public Sphere endpointInfluence;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct ReflectionsBakeParams\n    {\n        public IntPtr scene;\n        public IntPtr probeBatch;\n        public SceneType sceneType;\n        public BakedDataIdentifier identifier;\n        public ReflectionsBakeFlags flags;\n        public int numRays;\n        public int numDiffuseSamples;\n        public int numBounces;\n        public float simulatedDuration;\n        public float savedDuration;\n        public int order;\n        public int numThreads;\n        public int rayBatchSize;\n        public float irradianceMinDistance;\n        public int bakeBatchSize;\n        public IntPtr openCLDevice;\n        public IntPtr radeonRaysDevice;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "numThreads;\n        public int rayBatchSize;\n        public float irradianceMinDistance;\n        public int bakeBatchSize;\n        public IntPtr openCLDevice;\n        public IntPtr radeonRaysDevice;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct PathBakeParams\n    {\n        public IntPtr scene;\n        public IntPtr probeBatch;\n        public BakedDataIdentifier identifier;\n        public int numSamples;\n        public float radius;\n        public float threshold;\n        public float visRange;\n        public float pathRange;\n        public int numThreads;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct DistanceAttenuationModel\n    {\n        public DistanceAttenuationModelType type;\n        public float minDistance;\n        public DistanceAttenuationCallback callback;\n        public IntPtr userData;\n        public Bool dirty;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct AirAbsorptionModel\n    {\n        public AirAbsorptionModelType type;\n        public float coefficientsLow;\n        public float coefficientsMid;\n        public float coefficientsHigh;\n        public AirAbsorptionCallback callback;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "public AirAbsorptionModelType type;\n        public float coefficientsLow;\n        public float coefficientsMid;\n        public float coefficientsHigh;\n        public AirAbsorptionCallback callback;\n        public IntPtr userData;\n        public Bool dirty;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct Directivity\n    {\n        public float dipoleWeight;\n        public float dipolePower;\n        public DirectivityCallback callback;\n        public IntPtr userData;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct SimulationSettings\n    {\n        public SimulationFlags flags;\n        public SceneType sceneType;\n        public ReflectionEffectType reflectionType;\n        public int maxNumOcclusionSamples;\n        public int maxNumRays;\n        public int numDiffuseSamples;\n        public float maxDuration;\n        public int maxOrder;\n        public int maxNumSources;\n        public int numThreads;\n        public int rayBatchSize;\n        public int numVisSamples;\n        public int samplingRate;\n        public int frameSize;\n        public IntPtr openCLDevice;\n        public IntPtr radeonRaysDevice;\n        public IntPtr tanDevice;\n    }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "c int numVisSamples;\n        public int samplingRate;\n        public int frameSize;\n        public IntPtr openCLDevice;\n        public IntPtr radeonRaysDevice;\n        public IntPtr tanDevice;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct SourceSettings\n    {\n        public SimulationFlags flags;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct SimulationInputs\n    {\n        public SimulationFlags flags;\n        public DirectSimulationFlags directFlags;\n        public CoordinateSpace3 source;\n        public DistanceAttenuationModel distanceAttenuationModel;\n        public AirAbsorptionModel airAbsorptionModel;\n        public Directivity directivity;\n        public OcclusionType occlusionType;\n        public float occlusionRadius;\n        public int numOcclusionSamples;\n        public float reverbScaleLow;\n        public float reverbScaleMid;\n        public float reverbScaleHigh;\n        public float hybridReverbTransitionTime;\n        public float hybridReverbOverlapPercent;\n        public Bool baked;\n        public BakedDataIdentifier bakedDataIdentifier;\n        public IntPtr pathingProbes;\n        public float visRadius;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "public float hybridReverbOverlapPercent;\n        public Bool baked;\n        public BakedDataIdentifier bakedDataIdentifier;\n        public IntPtr pathingProbes;\n        public float visRadius;\n        public float visThreshold;\n        public float visRange;\n        public int pathingOrder;\n        public Bool enableValidation;\n        public Bool findAlternatePaths;\n        public int numTransmissionRays;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct SimulationSharedInputs\n    {\n        public CoordinateSpace3 listener;\n        public int numRays;\n        public int numBounces;\n        public float duration;\n        public int order;\n        public float irradianceMinDistance;\n        public PathingVisualizationCallback pathingVisualizationCallback;\n        public IntPtr pathingUserData;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct DirectEffectParams\n    {\n        public DirectEffectFlags flags;\n        public TransmissionType transmissionType;\n        public float distanceAttenuation;\n        public float airAbsorptionLow;\n        public float airAbsorptionMid;\n        public float airAbsorptionHigh;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "blic TransmissionType transmissionType;\n        public float distanceAttenuation;\n        public float airAbsorptionLow;\n        public float airAbsorptionMid;\n        public float airAbsorptionHigh;\n        public float directivity;\n        public float occlusion;\n        public float transmissionLow;\n        public float transmissionMid;\n        public float transmissionHigh;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct ReflectionEffectParams\n    {\n        public ReflectionEffectType type;\n        public IntPtr ir;\n        public float reverbTimesLow;\n        public float reverbTimesMid;\n        public float reverbTimesHigh;\n        public float eqLow;\n        public float eqMid;\n        public float eqHigh;\n        public int delay;\n        public int numChannels;\n        public int irSize;\n        public IntPtr tanDevice;\n        public int tanSlot;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct PathEffectParams\n    {\n        public float eqCoeffsLow;\n        public float eqCoeffsMid;\n        public float eqCoeffsHigh;\n        public IntPtr shCoeffs;\n        public int order;\n        public Bool binaural;\n        public IntPtr hrtf;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "t eqCoeffsLow;\n        public float eqCoeffsMid;\n        public float eqCoeffsHigh;\n        public IntPtr shCoeffs;\n        public int order;\n        public Bool binaural;\n        public IntPtr hrtf;\n        public CoordinateSpace3 listener;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct SimulationOutputs\n    {\n        public DirectEffectParams direct;\n        public ReflectionEffectParams reflections;\n        public PathEffectParams pathing;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct PerspectiveCorrection\n    {\n        public Bool enabled;\n        public float xfactor;\n        public float yfactor;\n        public Matrix4x4 transform;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct EnergyFieldSettings\n    {\n        public float duration;\n        public int order;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct ImpulseResponseSettings\n    {\n        public float duration;\n        public int order;\n        public int samplingRate;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct ReconstructorSettings\n    {\n        public float maxDuration;\n        public int maxOrder;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "t order;\n        public int samplingRate;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct ReconstructorSettings\n    {\n        public float maxDuration;\n        public int maxOrder;\n        public int samplingRate;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct ReconstructorInputs\n    {\n        public IntPtr energyField;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct ReconstructorSharedInputs\n    {\n        public float duration;\n        public int order;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct ReconstructorOutputs\n    {\n        public IntPtr impulseResponse;\n    }\n\n    // FUNCTIONS\n\n    public static class API\n    {\n        // Context\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern Error iplContextCreate(ref ContextSettings settings, out IntPtr context);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplContextRetain(IntPtr context);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": ");\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplContextRetain(IntPtr context);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplContextRelease(ref IntPtr context);\n\n        // Geometry\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern Vector3 iplCalculateRelativeDirection(IntPtr context, Vector3 sourcePosition, Vector3 listenerPosition, Vector3 listenerAhead, Vector3 listenerUp);\n\n        // Serialization\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern Error iplSerializedObjectCreate(IntPtr context, ref SerializedObjectSettings settings, out IntPtr serializedObject);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "ext, ref SerializedObjectSettings settings, out IntPtr serializedObject);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplSerializedObjectRetain(IntPtr serializedObject);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplSerializedObjectRelease(ref IntPtr serializedObject);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern UIntPtr iplSerializedObjectGetSize(IntPtr serializedObject);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplSerializedObjectGetData(IntPtr serializedObject);\n\n        // Embree\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "r iplSerializedObjectGetData(IntPtr serializedObject);\n\n        // Embree\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern Error iplEmbreeDeviceCreate(IntPtr context, ref EmbreeDeviceSettings settings, out IntPtr device);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplEmbreeDeviceRetain(IntPtr device);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplEmbreeDeviceRelease(ref IntPtr device);\n\n        // OpenCL\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern Error iplOpenCLDeviceListCreate(IntPtr context, ref OpenCLDeviceSettings settings, out IntPtr deviceList);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "ntPtr context, ref OpenCLDeviceSettings settings, out IntPtr deviceList);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplOpenCLDeviceListRetain(IntPtr deviceList);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplOpenCLDeviceListRelease(ref IntPtr deviceList);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern int iplOpenCLDeviceListGetNumDevices(IntPtr deviceList);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplOpenCLDeviceListGetDeviceDesc(IntPtr deviceList, int index, out OpenCLDeviceDesc deviceDesc);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "eviceDesc(IntPtr deviceList, int index, out OpenCLDeviceDesc deviceDesc);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern Error iplOpenCLDeviceCreate(IntPtr context, IntPtr deviceList, int index, out IntPtr device);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplOpenCLDeviceRetain(IntPtr device);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplOpenCLDeviceRelease(ref IntPtr device);\n\n        // Radeon Rays\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern Error iplRadeonRaysDeviceCreate(IntPtr openCLDevice, ref RadeonRaysDeviceSettings settings, out IntPtr rrDevice);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "penCLDevice, ref RadeonRaysDeviceSettings settings, out IntPtr rrDevice);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplRadeonRaysDeviceRetain(IntPtr device);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplRadeonRaysDeviceRelease(ref IntPtr device);\n\n        // TrueAudio Next\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern Error iplTrueAudioNextDeviceCreate(IntPtr openCLDevice, ref TrueAudioNextDeviceSettings settings, out IntPtr tanDevice);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplTrueAudioNextDeviceRetain(IntPtr device);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "public static extern IntPtr iplTrueAudioNextDeviceRetain(IntPtr device);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplTrueAudioNextDeviceRelease(ref IntPtr device);\n\n        // Scene\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern Error iplSceneCreate(IntPtr context, ref SceneSettings settings, out IntPtr scene);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplSceneRetain(IntPtr scene);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplSceneRelease(ref IntPtr scene);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "ndif\n        public static extern void iplSceneRelease(ref IntPtr scene);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern Error iplSceneLoad(IntPtr context, ref SceneSettings settings, IntPtr serializedObject, ProgressCallback progressCallback, IntPtr progressCallbackUserData, out IntPtr scene);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplSceneSave(IntPtr scene, IntPtr serializedObject);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplSceneSaveOBJ(IntPtr scene, string fileBaseName);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplSceneCommit(IntPtr scene);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": ")]\n#endif\n        public static extern void iplSceneCommit(IntPtr scene);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern Error iplStaticMeshCreate(IntPtr scene, ref StaticMeshSettings settings, out IntPtr staticMesh);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplStaticMeshRetain(IntPtr staticMesh);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplStaticMeshRelease(ref IntPtr staticMesh);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern Error iplStaticMeshLoad(IntPtr scene, IntPtr serializedObject, ProgressCallback progressCallback, IntPtr progressCallbackUserData, out IntPtr staticMesh);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "rogressCallback, IntPtr progressCallbackUserData, out IntPtr staticMesh);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplStaticMeshSave(IntPtr staticMesh, IntPtr serializedObject);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplStaticMeshAdd(IntPtr staticMesh, IntPtr scene);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplStaticMeshRemove(IntPtr staticMesh, IntPtr scene);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern Error iplInstancedMeshCreate(IntPtr scene, ref InstancedMeshSettings settings, out IntPtr instancedMesh);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplInstancedMeshRetain(IntPtr instancedMesh);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "TY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplInstancedMeshRetain(IntPtr instancedMesh);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplInstancedMeshRelease(ref IntPtr instancedMesh);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplInstancedMeshAdd(IntPtr instancedMesh, IntPtr scene);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplInstancedMeshRemove(IntPtr instancedMesh, IntPtr scene);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplInstancedMeshUpdateTransform(IntPtr instancedMesh, IntPtr scene, Matrix4x4 transform);\n\n        // HRTF\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "tern void iplInstancedMeshUpdateTransform(IntPtr instancedMesh, IntPtr scene, Matrix4x4 transform);\n\n        // HRTF\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern Error iplHRTFCreate(IntPtr context, ref AudioSettings audioSettings, ref HRTFSettings hrtfSettings, out IntPtr hrtf);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplHRTFRetain(IntPtr hrtf);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplHRTFRelease(ref IntPtr hrtf);\n\n        // Probes\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern Error iplProbeArrayCreate(IntPtr context, out IntPtr probeArray);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "extern Error iplProbeArrayCreate(IntPtr context, out IntPtr probeArray);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplProbeArrayRetain(IntPtr probeArray);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplProbeArrayRelease(ref IntPtr probeArray);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplProbeArrayGenerateProbes(IntPtr probeArray, IntPtr scene, ref ProbeGenerationParams generationParams);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern int iplProbeArrayGetNumProbes(IntPtr probeArray);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern Sphere iplProbeArrayGetProbe(IntPtr probeArray, int index);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "|| UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern Sphere iplProbeArrayGetProbe(IntPtr probeArray, int index);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern Error iplProbeBatchCreate(IntPtr context, out IntPtr probeBatch);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplProbeBatchRetain(IntPtr probeBatch);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplProbeBatchRelease(ref IntPtr probeBatch);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern Error iplProbeBatchLoad(IntPtr context, IntPtr serializedObject, out IntPtr probeBatch);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "atchLoad(IntPtr context, IntPtr serializedObject, out IntPtr probeBatch);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplProbeBatchSave(IntPtr probeBatch, IntPtr serializedObject);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern int iplProbeBatchGetNumProbes(IntPtr probeBatch);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplProbeBatchAddProbe(IntPtr probeBatch, Sphere probe);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplProbeBatchAddProbeArray(IntPtr probeBatch, IntPtr probeArray);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplProbeBatchRemoveProbe(IntPtr probeBatch, int index);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "| UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplProbeBatchRemoveProbe(IntPtr probeBatch, int index);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplProbeBatchCommit(IntPtr probeBatch);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplProbeBatchRemoveData(IntPtr probeBatch, ref BakedDataIdentifier identifier);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern UIntPtr iplProbeBatchGetDataSize(IntPtr probeBatch, ref BakedDataIdentifier identifier);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplProbeBatchGetEnergyField(IntPtr probeBatch, ref BakedDataIdentifier identifier, int probeIndex, IntPtr energyField);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplProbeBatchGetEnergyField(IntPtr probeBatch, ref BakedDataIdentifier identifier, int probeIndex, IntPtr energyField);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplProbeBatchGetReverb(IntPtr probeBatch, ref BakedDataIdentifier identifier, int probeIndex, float[] reverbTimes);\n\n        // Baking\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplReflectionsBakerBake(IntPtr context, ref ReflectionsBakeParams bakeParams, ProgressCallback progressCallback, IntPtr userData);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplReflectionsBakerCancelBake(IntPtr context);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "public static extern void iplReflectionsBakerCancelBake(IntPtr context);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplPathBakerBake(IntPtr context, ref PathBakeParams bakeParams, ProgressCallback progressCallback, IntPtr userData);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplPathBakerCancelBake(IntPtr context);\n\n        // Run-Time Simulation\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern Error iplSimulatorCreate(IntPtr context, ref SimulationSettings settings, out IntPtr simulator);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplSimulatorRetain(IntPtr simulator);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "public static extern IntPtr iplSimulatorRetain(IntPtr simulator);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplSimulatorRelease(ref IntPtr simulator);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplSimulatorSetScene(IntPtr simulator, IntPtr scene);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplSimulatorAddProbeBatch(IntPtr simulator, IntPtr probeBatch);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplSimulatorRemoveProbeBatch(IntPtr simulator, IntPtr probeBatch);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "n void iplSimulatorRemoveProbeBatch(IntPtr simulator, IntPtr probeBatch);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplSimulatorSetSharedInputs(IntPtr simulator, SimulationFlags flags, ref SimulationSharedInputs sharedInputs);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplSimulatorCommit(IntPtr simulator);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplSimulatorRunDirect(IntPtr simulator);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplSimulatorRunReflections(IntPtr simulator);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplSimulatorRunPathing(IntPtr simulator);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "f (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplSimulatorRunPathing(IntPtr simulator);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern Error iplSourceCreate(IntPtr simulator, ref SourceSettings settings, out IntPtr source);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplSourceRetain(IntPtr source);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplSourceRelease(ref IntPtr source);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplSourceAdd(IntPtr source, IntPtr simulator);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "public static extern void iplSourceAdd(IntPtr source, IntPtr simulator);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplSourceRemove(IntPtr source, IntPtr simulator);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplSourceSetInputs(IntPtr source, SimulationFlags flags,  ref SimulationInputs inputs);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplSourceGetOutputs(IntPtr source, SimulationFlags flags,  ref SimulationOutputs outputs);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern float iplDistanceAttenuationCalculate(IntPtr context, Vector3 source, Vector3 listener, ref DistanceAttenuationModel model);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "t, Vector3 source, Vector3 listener, ref DistanceAttenuationModel model);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplAirAbsorptionCalculate(IntPtr context, Vector3 source, Vector3 listener, ref AirAbsorptionModel mode, float[] minDistances);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern float iplDirectivityCalculate(IntPtr context, CoordinateSpace3 source, Vector3 listener, ref Directivity model);\n\n        // Energy Field API\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern Error iplEnergyFieldCreate(IntPtr context, ref EnergyFieldSettings settings, out IntPtr energyField);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplEnergyFieldRetain(IntPtr energyField);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "[DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplEnergyFieldRetain(IntPtr energyField);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplEnergyFieldRelease(ref IntPtr energyField);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern int iplEnergyFieldGetNumChannels(IntPtr energyField);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern int iplEnergyFieldGetNumBins(IntPtr energyField);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplEnergyFieldGetData(IntPtr energyField);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "public static extern IntPtr iplEnergyFieldGetData(IntPtr energyField);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplEnergyFieldGetChannel(IntPtr energyField, int channelIndex);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplEnergyFieldGetBand(IntPtr energyField, int channelIndex, int bandIndex);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplEnergyFieldReset(IntPtr energyField);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplEnergyFieldCopy(IntPtr srcEnergyField, IntPtr dstEnergyField);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplEnergyFieldSwap(IntPtr energyFieldA, IntPtr energyFieldB);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "Y_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplEnergyFieldSwap(IntPtr energyFieldA, IntPtr energyFieldB);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplEnergyFieldAdd(IntPtr energyField1, IntPtr energyField2, IntPtr outEnergyField);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplEnergyFieldScale(IntPtr inEnergyField, float scalar, IntPtr outEnergyField);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplEnergyFieldScaleAccum(IntPtr inEnergyField, float scalar, IntPtr outEnergyField);\n\n        // Impulse Response API\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "d, float scalar, IntPtr outEnergyField);\n\n        // Impulse Response API\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern Error iplImpulseResponseCreate(IntPtr context, ref ImpulseResponseSettings settings, out IntPtr impulseResponse);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplImpulseResponseRetain(IntPtr impulseResponse);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplImpulseResponseRelease(ref IntPtr impulseResponse);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern int iplImpulseResponseGetNumChannels(IntPtr impulseResponse);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "atic extern int iplImpulseResponseGetNumChannels(IntPtr impulseResponse);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern int iplImpulseResponseGetNumSamples(IntPtr impulseResponse);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplImpulseResponseGetData(IntPtr impulseResponse);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplImpulseResponseGetChannel(IntPtr impulseResponse, int channelIndex);\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplImpulseResponseReset(IntPtr impulseResponse);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplImpulseResponseCopy(IntPtr srcImpulseReponse, IntPtr dstImpulseResponse);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "ITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplImpulseResponseCopy(IntPtr srcImpulseReponse, IntPtr dstImpulseResponse);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplImpulseResponseSwap(IntPtr impulseResponse1, IntPtr impulseResponse2);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplImpulseResponseAdd(IntPtr inImpulseResponse1, IntPtr inImpulseResponse2, IntPtr outImpulseResponse);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplImpulseResponseScale(IntPtr inImpulseResponse, float scalar, IntPtr outImpulseResponse);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "Scale(IntPtr inImpulseResponse, float scalar, IntPtr outImpulseResponse);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplImpulseResponseScaleAccum(IntPtr inImpulseRespnse, float scalar, IntPtr outImpulseResponse);\n\n        // Reconstructor API\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n\n#endif\n        public static extern Error iplReconstructorCreate(IntPtr context, ref ReconstructorSettings settings, out IntPtr reconstructor);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern IntPtr iplReconstructorRetain(IntPtr reconstructor);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplReconstructorRelease(ref IntPtr reconstructor);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "lic static extern void iplReconstructorRelease(ref IntPtr reconstructor);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"phonon\")]\n#endif\n        public static extern void iplReconstructorReconstruct(IntPtr reconstructor, int numInputs, ref ReconstructorInputs inputs, ref ReconstructorSharedInputs sharedInputs, ref ReconstructorOutputs outputs);\n\n        // UNITY PLUGIN\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"audioplugin_phonon\")]\n#endif\n        public static extern void iplUnityInitialize(IntPtr context);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"audioplugin_phonon\")]\n#endif\n        public static extern void iplUnitySetPerspectiveCorrection(PerspectiveCorrection correction);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"audioplugin_phonon\")]\n#endif\n        public static extern void  iplUnitySetHRTF(IntPtr hrtf);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "[DllImport(\"audioplugin_phonon\")]\n#endif\n        public static extern void  iplUnitySetHRTF(IntPtr hrtf);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"audioplugin_phonon\")]\n#endif\n        public static extern void iplUnitySetSimulationSettings(SimulationSettings simulationSettings);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"audioplugin_phonon\")]\n#endif\n        public static extern void iplUnitySetReverbSource(IntPtr reverbSource);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"audioplugin_phonon\")]\n#endif\n        public static extern int iplUnityAddSource(IntPtr source);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"audioplugin_phonon\")]\n#endif\n        public static extern void iplUnityRemoveSource(int handle);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"audioplugin_phonon\")]\n#endif\n        public static extern void iplUnityTerminate();"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudio.cs",
      "Content": "dle);\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"audioplugin_phonon\")]\n#endif\n        public static extern void iplUnityTerminate();\n\n#if (UNITY_IOS || UNITY_WEBGL) && !UNITY_EDITOR\n        [DllImport(\"__Internal\")]\n#else\n        [DllImport(\"audioplugin_phonon\")]\n#endif\n        public static extern void iplUnitySetHRTFDisabled(bool disabled);\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioAmbisonicSource.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing System;\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    [AddComponentMenu(\"Steam Audio/Steam Audio Ambisonic Source\")]\n    [RequireComponent(typeof(AudioSource))]\n    public class SteamAudioAmbisonicSource : MonoBehaviour\n    {\n        [Header(\"HRTF Settings\")]\n        public bool applyHRTF = true;\n\n        AudioEngineAmbisonicSource mAudioEngineAmbisonicSource = null;\n\n        private void Awake()\n        {\n            mAudioEngineAmbisonicSource = AudioEngineAmbisonicSource.Create(SteamAudioSettings.Singleton.audioEngine);\n            if (mAudioEngineAmbisonicSource != null)"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioAmbisonicSource.cs",
      "Content": "vate void Awake()\n        {\n            mAudioEngineAmbisonicSource = AudioEngineAmbisonicSource.Create(SteamAudioSettings.Singleton.audioEngine);\n            if (mAudioEngineAmbisonicSource != null)\n            {\n                mAudioEngineAmbisonicSource.Initialize(gameObject);\n                mAudioEngineAmbisonicSource.UpdateParameters(this);\n            }\n        }\n\n        private void Start()\n        {\n            if (mAudioEngineAmbisonicSource != null)\n            {\n                mAudioEngineAmbisonicSource.UpdateParameters(this);\n            }\n        }\n\n        private void OnDestroy()\n        {\n            if (mAudioEngineAmbisonicSource != null)\n            {\n                mAudioEngineAmbisonicSource.Destroy();\n            }\n        }\n\n        private void OnEnable()\n        {\n            if (mAudioEngineAmbisonicSource != null)\n            {\n                mAudioEngineAmbisonicSource.UpdateParameters(this);\n            }\n        }\n\n        private void Update()\n        {\n            if (mAudioEngineAmbisonicSource != null)\n            {\n                mAudioEngineAmbisonicSource.UpdateParameters(this);\n            }\n        }\n\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioBakedListener.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing System;\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    [AddComponentMenu(\"Steam Audio/Steam Audio Baked Listener\")]\n    public class SteamAudioBakedListener : MonoBehaviour\n    {\n        [Header(\"Baked Static Listener Settings\")]\n        [Range(0.0f, 1000.0f)]\n        public float influenceRadius = 1000.0f;\n        public bool useAllProbeBatches = false;\n        public SteamAudioProbeBatch[] probeBatches = null;\n\n        [SerializeField]\n        int mTotalDataSize = 0;\n        [SerializeField]\n        int[] mProbeDataSizes = null;\n        [SerializeField]"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioBakedListener.cs",
      "Content": "public SteamAudioProbeBatch[] probeBatches = null;\n\n        [SerializeField]\n        int mTotalDataSize = 0;\n        [SerializeField]\n        int[] mProbeDataSizes = null;\n        [SerializeField]\n        BakedDataIdentifier mIdentifier = new BakedDataIdentifier { };\n        [SerializeField]\n        SteamAudioProbeBatch[] mProbeBatchesUsed = null;\n\n#if STEAMAUDIO_ENABLED\n        public int GetTotalDataSize()\n        {\n            return mTotalDataSize;\n        }\n\n        public int[] GetProbeDataSizes()\n        {\n            return mProbeDataSizes;\n        }\n\n        public int GetSizeForProbeBatch(int index)\n        {\n            return mProbeDataSizes[index];\n        }\n\n        public SteamAudioProbeBatch[] GetProbeBatchesUsed()\n        {\n            if (mProbeBatchesUsed == null)\n            {\n                CacheProbeBatchesUsed();\n            }\n\n            return mProbeBatchesUsed;\n        }\n\n        public BakedDataIdentifier GetBakedDataIdentifier()\n        {\n            var identifier = new BakedDataIdentifier { };\n            identifier.type = BakedDataType.Reflections;\n            identifier.variation = BakedDataVariation.StaticListener;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioBakedListener.cs",
      "Content": "er()\n        {\n            var identifier = new BakedDataIdentifier { };\n            identifier.type = BakedDataType.Reflections;\n            identifier.variation = BakedDataVariation.StaticListener;\n            identifier.endpointInfluence.center = Common.ConvertVector(transform.position);\n            identifier.endpointInfluence.radius = influenceRadius;\n            return identifier;\n        }\n\n        private void OnDrawGizmosSelected()\n        {\n            var oldColor = Gizmos.color;\n            var oldMatrix = Gizmos.matrix;\n\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(transform.position, influenceRadius);\n\n            Gizmos.color = Color.magenta;\n\n            if (mProbeBatchesUsed != null)\n            {\n                foreach (var probeBatch in mProbeBatchesUsed)\n                {\n                    if (probeBatch == null)\n                        continue;\n\n                    Gizmos.matrix = probeBatch.transform.localToWorldMatrix;\n                    Gizmos.DrawWireCube(new UnityEngine.Vector3(0, 0, 0), new UnityEngine.Vector3(1, 1, 1));\n                }\n            }\n\n            Gizmos.matrix = oldMatrix;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioBakedListener.cs",
      "Content": "ocalToWorldMatrix;\n                    Gizmos.DrawWireCube(new UnityEngine.Vector3(0, 0, 0), new UnityEngine.Vector3(1, 1, 1));\n                }\n            }\n\n            Gizmos.matrix = oldMatrix;\n            Gizmos.color = oldColor;\n        }\n\n        public void UpdateBakedDataStatistics()\n        {\n            if (mProbeBatchesUsed == null)\n                return;\n\n            mProbeDataSizes = new int[mProbeBatchesUsed.Length];\n            mTotalDataSize = 0;\n\n            for (var i = 0; i < mProbeBatchesUsed.Length; ++i)\n            {\n                mProbeDataSizes[i] = mProbeBatchesUsed[i].GetSizeForLayer(mIdentifier);\n                mTotalDataSize += mProbeDataSizes[i];\n            }\n        }\n\n        public void BeginBake()\n        {\n            CacheIdentifier();\n            CacheProbeBatchesUsed();\n\n            var tasks = new BakedDataTask[1];\n            tasks[0].gameObject = gameObject;\n            tasks[0].component = this;\n            tasks[0].name = gameObject.name;\n            tasks[0].identifier = mIdentifier;\n#if UNITY_2020_3_OR_NEWER"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioBakedListener.cs",
      "Content": "tasks[0].gameObject = gameObject;\n            tasks[0].component = this;\n            tasks[0].name = gameObject.name;\n            tasks[0].identifier = mIdentifier;\n#if UNITY_2020_3_OR_NEWER\n            tasks[0].probeBatches = (useAllProbeBatches) ? FindObjectsByType<SteamAudioProbeBatch>(FindObjectsSortMode.None) : probeBatches;\n#else\n            tasks[0].probeBatches = (useAllProbeBatches) ? FindObjectsOfType<SteamAudioProbeBatch>() : probeBatches;\n#endif\n            tasks[0].probeBatchNames = new string[tasks[0].probeBatches.Length];\n            tasks[0].probeBatchAssets = new SerializedData[tasks[0].probeBatches.Length];\n            for (var i = 0; i < tasks[0].probeBatchNames.Length; ++i)\n            {\n                tasks[0].probeBatchNames[i] = tasks[0].probeBatches[i].gameObject.name;\n                tasks[0].probeBatchAssets[i] = tasks[0].probeBatches[i].GetAsset();\n            }\n\n            Baker.BeginBake(tasks);\n        }\n\n        void CacheIdentifier()\n        {\n            mIdentifier = GetBakedDataIdentifier();\n        }\n\n        void CacheProbeBatchesUsed()\n        {\n#if UNITY_2020_3_OR_NEWER"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioBakedListener.cs",
      "Content": "ake(tasks);\n        }\n\n        void CacheIdentifier()\n        {\n            mIdentifier = GetBakedDataIdentifier();\n        }\n\n        void CacheProbeBatchesUsed()\n        {\n#if UNITY_2020_3_OR_NEWER\n            mProbeBatchesUsed = (useAllProbeBatches) ? FindObjectsByType<SteamAudioProbeBatch>(FindObjectsSortMode.None) : probeBatches;\n#else\n            mProbeBatchesUsed = (useAllProbeBatches) ? FindObjectsOfType<SteamAudioProbeBatch>() : probeBatches;\n#endif\n        }\n#endif\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioBakedSource.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing System;\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    [AddComponentMenu(\"Steam Audio/Steam Audio Baked Source\")]\n    public class SteamAudioBakedSource : MonoBehaviour\n    {\n        [Header(\"Baked Static Source Settings\")]\n        [Range(0.0f, 1000.0f)]\n        public float influenceRadius = 1000.0f;\n        public bool useAllProbeBatches = false;\n        public SteamAudioProbeBatch[] probeBatches = null;\n\n        [SerializeField]\n        int mTotalDataSize = 0;\n        [SerializeField]\n        int[] mProbeDataSizes = null;\n        [SerializeField]"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioBakedSource.cs",
      "Content": "public SteamAudioProbeBatch[] probeBatches = null;\n\n        [SerializeField]\n        int mTotalDataSize = 0;\n        [SerializeField]\n        int[] mProbeDataSizes = null;\n        [SerializeField]\n        BakedDataIdentifier mIdentifier = new BakedDataIdentifier { };\n        [SerializeField]\n        SteamAudioProbeBatch[] mProbeBatchesUsed = null;\n\n#if STEAMAUDIO_ENABLED\n        public int GetTotalDataSize()\n        {\n            return mTotalDataSize;\n        }\n\n        public int[] GetProbeDataSizes()\n        {\n            return mProbeDataSizes;\n        }\n\n        public int GetSizeForProbeBatch(int index)\n        {\n            return mProbeDataSizes[index];\n        }\n\n        public SteamAudioProbeBatch[] GetProbeBatchesUsed()\n        {\n            if (mProbeBatchesUsed == null)\n            {\n                CacheProbeBatchesUsed();\n            }\n\n            return mProbeBatchesUsed;\n        }\n\n        public BakedDataIdentifier GetBakedDataIdentifier()\n        {\n            var identifier = new BakedDataIdentifier { };\n            identifier.type = BakedDataType.Reflections;\n            identifier.variation = BakedDataVariation.StaticSource;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioBakedSource.cs",
      "Content": "fier()\n        {\n            var identifier = new BakedDataIdentifier { };\n            identifier.type = BakedDataType.Reflections;\n            identifier.variation = BakedDataVariation.StaticSource;\n            identifier.endpointInfluence.center = Common.ConvertVector(transform.position);\n            identifier.endpointInfluence.radius = influenceRadius;\n            return identifier;\n        }\n\n        private void OnDrawGizmosSelected()\n        {\n            var oldColor = Gizmos.color;\n            var oldMatrix = Gizmos.matrix;\n\n            Gizmos.color = Color.yellow;\n            Gizmos.DrawWireSphere(transform.position, influenceRadius);\n\n            Gizmos.color = Color.magenta;\n\n            if (mProbeBatchesUsed != null)\n            {\n                foreach (var probeBatch in mProbeBatchesUsed)\n                {\n                    if (probeBatch == null)\n                        continue;\n\n                    Gizmos.matrix = probeBatch.transform.localToWorldMatrix;\n                    Gizmos.DrawWireCube(new UnityEngine.Vector3(0, 0, 0), new UnityEngine.Vector3(1, 1, 1));\n                }\n            }\n\n            Gizmos.matrix = oldMatrix;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioBakedSource.cs",
      "Content": "ocalToWorldMatrix;\n                    Gizmos.DrawWireCube(new UnityEngine.Vector3(0, 0, 0), new UnityEngine.Vector3(1, 1, 1));\n                }\n            }\n\n            Gizmos.matrix = oldMatrix;\n            Gizmos.color = oldColor;\n        }\n\n        public void UpdateBakedDataStatistics()\n        {\n            if (mProbeBatchesUsed == null)\n                return;\n\n            mProbeDataSizes = new int[mProbeBatchesUsed.Length];\n            mTotalDataSize = 0;\n\n            for (var i = 0; i < mProbeBatchesUsed.Length; ++i)\n            {\n                mProbeDataSizes[i] = mProbeBatchesUsed[i].GetSizeForLayer(mIdentifier);\n                mTotalDataSize += mProbeDataSizes[i];\n            }\n        }\n\n        public void BeginBake()\n        {\n            CacheIdentifier();\n            CacheProbeBatchesUsed();\n\n            var tasks = new BakedDataTask[1];\n            tasks[0].gameObject = gameObject;\n            tasks[0].component = this;\n            tasks[0].name = gameObject.name;\n            tasks[0].identifier = mIdentifier;\n#if UNITY_2020_3_OR_NEWER"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioBakedSource.cs",
      "Content": "tasks[0].gameObject = gameObject;\n            tasks[0].component = this;\n            tasks[0].name = gameObject.name;\n            tasks[0].identifier = mIdentifier;\n#if UNITY_2020_3_OR_NEWER\n            tasks[0].probeBatches = (useAllProbeBatches) ? FindObjectsByType<SteamAudioProbeBatch>(FindObjectsSortMode.None) : probeBatches;\n#else\n            tasks[0].probeBatches = (useAllProbeBatches) ?  FindObjectsOfType<SteamAudioProbeBatch>() : probeBatches;\n#endif\n            tasks[0].probeBatchNames = new string[tasks[0].probeBatches.Length];\n            tasks[0].probeBatchAssets = new SerializedData[tasks[0].probeBatches.Length];\n            for (var i = 0; i < tasks[0].probeBatchNames.Length; ++i)\n            {\n                tasks[0].probeBatchNames[i] = tasks[0].probeBatches[i].gameObject.name;\n                tasks[0].probeBatchAssets[i] = tasks[0].probeBatches[i].GetAsset();\n            }\n\n            Baker.BeginBake(tasks);\n        }\n\n        void CacheIdentifier()\n        {\n            mIdentifier = GetBakedDataIdentifier();\n        }\n\n        void CacheProbeBatchesUsed()\n        {\n#if UNITY_2020_3_OR_NEWER"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioBakedSource.cs",
      "Content": "ake(tasks);\n        }\n\n        void CacheIdentifier()\n        {\n            mIdentifier = GetBakedDataIdentifier();\n        }\n\n        void CacheProbeBatchesUsed()\n        {\n#if UNITY_2020_3_OR_NEWER\n            mProbeBatchesUsed = (useAllProbeBatches) ? FindObjectsByType<SteamAudioProbeBatch>(FindObjectsSortMode.None) : probeBatches;\n#else\n            mProbeBatchesUsed = (useAllProbeBatches) ? FindObjectsOfType<SteamAudioProbeBatch>() : probeBatches;\n#endif\n        }\n#endif\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioDynamicObject.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing System;\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    [AddComponentMenu(\"Steam Audio/Steam Audio Dynamic Object\")]\n    public class SteamAudioDynamicObject : MonoBehaviour\n    {\n        [Header(\"Export Settings\")]\n        public SerializedData asset = null;\n\n#if STEAMAUDIO_ENABLED\n        InstancedMesh mInstancedMesh = null;\n\n        private void OnDestroy()\n        {\n            SteamAudioManager.UnloadDynamicObject(this);\n\n            if (mInstancedMesh != null)\n            {\n                mInstancedMesh.Release();\n            }\n        }\n\n        private void OnEnable()"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioDynamicObject.cs",
      "Content": "SteamAudioManager.UnloadDynamicObject(this);\n\n            if (mInstancedMesh != null)\n            {\n                mInstancedMesh.Release();\n            }\n        }\n\n        private void OnEnable()\n        {\n            if (mInstancedMesh != null)\n            {\n                mInstancedMesh.AddToScene(SteamAudioManager.CurrentScene);\n                SteamAudioManager.ScheduleCommitScene();\n            }\n        }\n\n        private void OnDisable()\n        {\n            if (mInstancedMesh != null && SteamAudioManager.CurrentScene != null)\n            {\n                mInstancedMesh.RemoveFromScene(SteamAudioManager.CurrentScene);\n                SteamAudioManager.ScheduleCommitScene();\n            }\n        }\n\n        private void Update()\n        {\n            if (mInstancedMesh == null && asset != null)\n            {\n                mInstancedMesh = SteamAudioManager.LoadDynamicObject(this, SteamAudioManager.CurrentScene, SteamAudioManager.Context);\n\n                if (enabled)\n                {\n                    mInstancedMesh.AddToScene(SteamAudioManager.CurrentScene);\n                    SteamAudioManager.ScheduleCommitScene();\n                }\n            }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioDynamicObject.cs",
      "Content": "enabled)\n                {\n                    mInstancedMesh.AddToScene(SteamAudioManager.CurrentScene);\n                    SteamAudioManager.ScheduleCommitScene();\n                }\n            }\n\n            // Only update the dynamic object if it has actually move this frame\n            if (transform.hasChanged)\n            {\n                mInstancedMesh.UpdateTransform(SteamAudioManager.CurrentScene, transform);\n                SteamAudioManager.ScheduleCommitScene();\n                transform.hasChanged = false;\n            }\n        }\n#endif\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioGeometry.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    [AddComponentMenu(\"Steam Audio/Steam Audio Geometry\")]\n    public class SteamAudioGeometry : MonoBehaviour\n    {\n        [Header(\"Material Settings\")]\n        public SteamAudioMaterial material = null;\n        [Header(\"Export Settings\")]\n        public bool exportAllChildren = false;\n        [Header(\"Terrain Settings\")]\n        [Range(0, 10)]\n        public int terrainSimplificationLevel = 0;\n\n#if STEAMAUDIO_ENABLED\n        public int GetNumVertices()\n        {\n            if (exportAllChildren)\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioGeometry.cs",
      "Content": "ngs\")]\n        [Range(0, 10)]\n        public int terrainSimplificationLevel = 0;\n\n#if STEAMAUDIO_ENABLED\n        public int GetNumVertices()\n        {\n            if (exportAllChildren)\n            {\n                var objects = SteamAudioManager.GetGameObjectsForExport(gameObject);\n\n                var numVertices = 0;\n                foreach (var obj in objects)\n                {\n                    numVertices += SteamAudioManager.GetNumVertices(obj);\n                }\n\n                return numVertices;\n            }\n            else\n            {\n                return SteamAudioManager.GetNumVertices(gameObject);\n            }\n        }\n\n        public int GetNumTriangles()\n        {\n            if (exportAllChildren)\n            {\n                var objects = SteamAudioManager.GetGameObjectsForExport(gameObject);\n\n                var numTriangles = 0;\n                foreach (var obj in objects)\n                {\n                    numTriangles += SteamAudioManager.GetNumTriangles(obj);\n                }\n\n                return numTriangles;\n            }\n            else\n            {\n                return SteamAudioManager.GetNumTriangles(gameObject);\n            }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioGeometry.cs",
      "Content": "riangles(obj);\n                }\n\n                return numTriangles;\n            }\n            else\n            {\n                return SteamAudioManager.GetNumTriangles(gameObject);\n            }\n        }\n#endif\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioListener.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing System;\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    public enum ReverbType\n    {\n        Realtime,\n        Baked\n    }\n\n    [AddComponentMenu(\"Steam Audio/Steam Audio Listener\")]\n    public class SteamAudioListener : MonoBehaviour\n    {\n        [Header(\"Baked Static Listener Settings\")]\n        public SteamAudioBakedListener currentBakedListener = null;\n\n        [Header(\"Reverb Settings\")]\n        public bool applyReverb = false;\n        public ReverbType reverbType = ReverbType.Realtime;\n\n        [Header(\"Baked Reverb Settings\")]"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioListener.cs",
      "Content": "edListener = null;\n\n        [Header(\"Reverb Settings\")]\n        public bool applyReverb = false;\n        public ReverbType reverbType = ReverbType.Realtime;\n\n        [Header(\"Baked Reverb Settings\")]\n        public bool useAllProbeBatches = false;\n        public SteamAudioProbeBatch[] probeBatches = null;\n\n        [SerializeField]\n        int mTotalDataSize = 0;\n        [SerializeField]\n        int[] mProbeDataSizes = null;\n        [SerializeField]\n        BakedDataIdentifier mIdentifier = new BakedDataIdentifier { };\n        [SerializeField]\n        SteamAudioProbeBatch[] mProbeBatchesUsed = null;\n\n#if STEAMAUDIO_ENABLED\n        Simulator mSimulator = null;\n        Source mSource = null;\n\n        public int GetTotalDataSize()\n        {\n            return mTotalDataSize;\n        }\n\n        public int[] GetProbeDataSizes()\n        {\n            return mProbeDataSizes;\n        }\n\n        public int GetSizeForProbeBatch(int index)\n        {\n            return mProbeDataSizes[index];\n        }\n\n        public SteamAudioProbeBatch[] GetProbeBatchesUsed()\n        {\n            if (mProbeBatchesUsed == null)\n            {\n                CacheProbeBatchesUsed();\n            }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioListener.cs",
      "Content": "dex];\n        }\n\n        public SteamAudioProbeBatch[] GetProbeBatchesUsed()\n        {\n            if (mProbeBatchesUsed == null)\n            {\n                CacheProbeBatchesUsed();\n            }\n\n            return mProbeBatchesUsed;\n        }\n\n        private void Awake()\n        {\n            Reinitialize();\n        }\n\n        public void Reinitialize()\n        {\n            mSimulator = SteamAudioManager.Simulator;\n\n            var settings = SteamAudioManager.GetSimulationSettings(false);\n            mSource = new Source(SteamAudioManager.Simulator, settings);\n\n            SteamAudioManager.GetAudioEngineState().SetReverbSource(mSource);\n        }\n\n        private void OnDestroy()\n        {\n            if (mSource != null)\n            {\n                mSource.Release();\n            }\n        }\n\n        private void Start()\n        {\n            SteamAudioManager.GetAudioEngineState().SetReverbSource(mSource);\n        }\n\n        private void OnEnable()\n        {\n            if (applyReverb)\n            {\n                mSource.AddToSimulator(mSimulator);\n                SteamAudioManager.AddListener(this);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioListener.cs",
      "Content": "}\n\n        private void OnEnable()\n        {\n            if (applyReverb)\n            {\n                mSource.AddToSimulator(mSimulator);\n                SteamAudioManager.AddListener(this);\n                SteamAudioManager.GetAudioEngineState().SetReverbSource(mSource);\n            }\n        }\n\n        private void OnDisable()\n        {\n            if (applyReverb)\n            {\n                SteamAudioManager.RemoveListener(this);\n                mSource.RemoveFromSimulator(mSimulator);\n                SteamAudioManager.GetAudioEngineState().SetReverbSource(mSource);\n            }\n        }\n\n        private void Update()\n        {\n            SteamAudioManager.GetAudioEngineState().SetReverbSource(mSource);\n        }\n\n        public BakedDataIdentifier GetBakedDataIdentifier()\n        {\n            var identifier = new BakedDataIdentifier { };\n            identifier.type = BakedDataType.Reflections;\n            identifier.variation = BakedDataVariation.Reverb;\n            return identifier;\n        }\n\n        public void SetInputs(SimulationFlags flags)\n        {\n            var inputs = new SimulationInputs { };"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioListener.cs",
      "Content": "fier.variation = BakedDataVariation.Reverb;\n            return identifier;\n        }\n\n        public void SetInputs(SimulationFlags flags)\n        {\n            var inputs = new SimulationInputs { };\n            inputs.source.origin = Common.ConvertVector(transform.position);\n            inputs.source.ahead = Common.ConvertVector(transform.forward);\n            inputs.source.up = Common.ConvertVector(transform.up);\n            inputs.source.right = Common.ConvertVector(transform.right);\n            inputs.distanceAttenuationModel.type = DistanceAttenuationModelType.Default;\n            inputs.airAbsorptionModel.type = AirAbsorptionModelType.Default;\n            inputs.reverbScaleLow = 1.0f;\n            inputs.reverbScaleMid = 1.0f;\n            inputs.reverbScaleHigh = 1.0f;\n            inputs.hybridReverbTransitionTime = SteamAudioSettings.Singleton.hybridReverbTransitionTime;\n            inputs.hybridReverbOverlapPercent = SteamAudioSettings.Singleton.hybridReverbOverlapPercent / 100.0f;\n            inputs.baked = (reverbType != ReverbType.Realtime) ? Bool.True : Bool.False;\n            if (reverbType == ReverbType.Baked)\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioListener.cs",
      "Content": "s.Singleton.hybridReverbOverlapPercent / 100.0f;\n            inputs.baked = (reverbType != ReverbType.Realtime) ? Bool.True : Bool.False;\n            if (reverbType == ReverbType.Baked)\n            {\n                inputs.bakedDataIdentifier = GetBakedDataIdentifier();\n            }\n\n            inputs.flags = 0;\n            if (applyReverb)\n            {\n                inputs.flags = inputs.flags | SimulationFlags.Reflections;\n            }\n\n            inputs.directFlags = 0;\n\n            mSource.SetInputs(flags, inputs);\n        }\n\n        public void UpdateOutputs(SimulationFlags flags)\n        {}\n\n        private void OnDrawGizmosSelected()\n        {\n            var oldColor = Gizmos.color;\n            var oldMatrix = Gizmos.matrix;\n\n            Gizmos.color = Color.magenta;\n\n            if (mProbeBatchesUsed != null)\n            {\n                foreach (var probeBatch in mProbeBatchesUsed)\n                {\n                    if (probeBatch == null)\n                        continue;\n\n                    Gizmos.matrix = probeBatch.transform.localToWorldMatrix;\n                    Gizmos.DrawWireCube(new UnityEngine.Vector3(0, 0, 0), new UnityEngine.Vector3(1, 1, 1));"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioListener.cs",
      "Content": "continue;\n\n                    Gizmos.matrix = probeBatch.transform.localToWorldMatrix;\n                    Gizmos.DrawWireCube(new UnityEngine.Vector3(0, 0, 0), new UnityEngine.Vector3(1, 1, 1));\n                }\n            }\n\n            Gizmos.matrix = oldMatrix;\n            Gizmos.color = oldColor;\n        }\n\n        public void UpdateBakedDataStatistics()\n        {\n            if (mProbeBatchesUsed == null)\n                return;\n\n            mProbeDataSizes = new int[mProbeBatchesUsed.Length];\n            mTotalDataSize = 0;\n\n            for (var i = 0; i < mProbeBatchesUsed.Length; ++i)\n            {\n                mProbeDataSizes[i] = mProbeBatchesUsed[i].GetSizeForLayer(mIdentifier);\n                mTotalDataSize += mProbeDataSizes[i];\n            }\n        }\n\n        public void BeginBake()\n        {\n            CacheIdentifier();\n            CacheProbeBatchesUsed();\n\n            var tasks = new BakedDataTask[1];\n            tasks[0].gameObject = gameObject;\n            tasks[0].component = this;\n            tasks[0].name = gameObject.name;\n            tasks[0].identifier = mIdentifier;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioListener.cs",
      "Content": "new BakedDataTask[1];\n            tasks[0].gameObject = gameObject;\n            tasks[0].component = this;\n            tasks[0].name = gameObject.name;\n            tasks[0].identifier = mIdentifier;\n            tasks[0].probeBatches = (useAllProbeBatches) ? FindObjectsOfType<SteamAudioProbeBatch>() : probeBatches;\n            tasks[0].probeBatchNames = new string[tasks[0].probeBatches.Length];\n            tasks[0].probeBatchAssets = new SerializedData[tasks[0].probeBatches.Length];\n            for (var i = 0; i < tasks[0].probeBatchNames.Length; ++i)\n            {\n                tasks[0].probeBatchNames[i] = tasks[0].probeBatches[i].gameObject.name;\n                tasks[0].probeBatchAssets[i] = tasks[0].probeBatches[i].GetAsset();\n            }\n\n            Baker.BeginBake(tasks);\n        }\n\n        void CacheIdentifier()\n        {\n            mIdentifier.type = BakedDataType.Reflections;\n            mIdentifier.variation = BakedDataVariation.Reverb;\n        }\n\n        void CacheProbeBatchesUsed()\n        {\n            mProbeBatchesUsed = (useAllProbeBatches) ? FindObjectsOfType<SteamAudioProbeBatch>() : probeBatches;\n        }\n#endif\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing System;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.Threading;\nusing AOT;\nusing UnityEngine;\nusing UnityEngine.SceneManagement;\n#if UNITY_EDITOR\nusing UnityEditor;\nusing UnityEditor.SceneManagement;\nusing System.IO;\n#if UNITY_2019_2_OR_NEWER\nusing UnityEditor.PackageManager;\n#endif\n#endif\n\nnamespace SteamAudio\n{\n    public enum ManagerInitReason\n    {\n        ExportingScene,\n        GeneratingProbes,\n        EditingProbes,\n        Baking,\n        Playing\n    }\n\n    /**"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": ";\n#endif\n#endif\n\nnamespace SteamAudio\n{\n    public enum ManagerInitReason\n    {\n        ExportingScene,\n        GeneratingProbes,\n        EditingProbes,\n        Baking,\n        Playing\n    }\n\n    /**\n     * Maintains global state for Steam Audio, manages simulations, and passes simulation results to the audio engine.\n     */\n    public class SteamAudioManager : MonoBehaviour\n    {\n        [Header(\"HRTF Settings\")]\n        public int currentHRTF = 0;\n\n#if STEAMAUDIO_ENABLED\n        public string[] hrtfNames = null;\n\n        int mNumCPUCores = 0;\n        AudioSettings mAudioSettings;\n        Context mContext = null;\n        HRTF[] mHRTFs = null;\n        EmbreeDevice mEmbreeDevice = null;\n        bool mEmbreeInitFailed = false;\n        OpenCLDevice mOpenCLDevice = null;\n        bool mOpenCLInitFailed = false;\n        RadeonRaysDevice mRadeonRaysDevice = null;\n        bool mRadeonRaysInitFailed = false;\n        TrueAudioNextDevice mTrueAudioNextDevice = null;\n        bool mTrueAudioNextInitFailed = false;\n        Scene mCurrentScene = null;\n        Dictionary<string, int> mDynamicObjectRefCounts = new Dictionary<string, int>();"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "TrueAudioNextDevice = null;\n        bool mTrueAudioNextInitFailed = false;\n        Scene mCurrentScene = null;\n        Dictionary<string, int> mDynamicObjectRefCounts = new Dictionary<string, int>();\n        Dictionary<string, Scene> mDynamicObjects = new Dictionary<string, Scene>();\n        Simulator mSimulator = null;\n        AudioEngineState mAudioEngineState = null;\n        Transform mListener = null;\n        SteamAudioListener mListenerComponent = null;\n        HashSet<SteamAudioSource> mSources = new HashSet<SteamAudioSource>();\n        HashSet<SteamAudioListener> mListeners = new HashSet<SteamAudioListener>();\n        RaycastHit[] mRayHits = new RaycastHit[1];\n        IntPtr mMaterialBuffer = IntPtr.Zero;\n        Thread mSimulationThread = null;\n        EventWaitHandle mSimulationThreadWaitHandle = null;\n        bool mStopSimulationThread = false;\n        bool mSimulationCompleted = false;\n        float mSimulationUpdateTimeElapsed = 0.0f;\n        bool mSceneCommitRequired = false;\n        Camera mMainCamera;\n\n        static SteamAudioManager sSingleton = null;\n\n        public static SteamAudioManager Singleton\n        {\n            get\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "ceneCommitRequired = false;\n        Camera mMainCamera;\n\n        static SteamAudioManager sSingleton = null;\n\n        public static SteamAudioManager Singleton\n        {\n            get\n            {\n                return sSingleton;\n            }\n        }\n\n        public static Context Context\n        {\n            get\n            {\n                return sSingleton.mContext;\n            }\n        }\n\n        public static HRTF CurrentHRTF\n        {\n            get\n            {\n                return sSingleton.mHRTFs[sSingleton.currentHRTF];\n            }\n        }\n\n        public static IntPtr EmbreeDevice\n        {\n            get\n            {\n                return sSingleton.mEmbreeDevice.Get();\n            }\n        }\n\n        public static IntPtr OpenCLDevice\n        {\n            get\n            {\n                return sSingleton.mOpenCLDevice.Get();\n            }\n        }\n\n        public static IntPtr RadeonRaysDevice\n        {\n            get\n            {\n                return sSingleton.mRadeonRaysDevice.Get();\n            }\n        }\n\n        public static IntPtr TrueAudioNextDevice\n        {\n            get\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "get\n            {\n                return sSingleton.mRadeonRaysDevice.Get();\n            }\n        }\n\n        public static IntPtr TrueAudioNextDevice\n        {\n            get\n            {\n                return sSingleton.mTrueAudioNextDevice.Get();\n            }\n        }\n\n        public static Scene CurrentScene\n        {\n            get\n            {\n                return sSingleton.mCurrentScene;\n            }\n        }\n\n        public static Simulator Simulator\n        {\n            get\n            {\n                return sSingleton.mSimulator;\n            }\n        }\n\n        public static AudioSettings AudioSettings\n        {\n            get\n            {\n                return sSingleton.mAudioSettings;\n            }\n        }\n\n        public static AudioEngineState GetAudioEngineState()\n        {\n            return sSingleton.mAudioEngineState;\n        }\n\n        public static SteamAudioListener GetSteamAudioListener()\n        {\n            if (sSingleton.mListenerComponent == null)\n                return null;\n\n            return sSingleton.mListenerComponent;\n        }\n\n        public int NumThreadsForCPUCorePercentage(int percentage)\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "eton.mListenerComponent == null)\n                return null;\n\n            return sSingleton.mListenerComponent;\n        }\n\n        public int NumThreadsForCPUCorePercentage(int percentage)\n        {\n            return (int)Mathf.Max(1, (percentage * mNumCPUCores) / 100.0f);\n        }\n\n        public static SceneType GetSceneType()\n        {\n            var sceneType = SteamAudioSettings.Singleton.sceneType;\n\n            if ((sceneType == SceneType.Embree && sSingleton.mEmbreeInitFailed) ||\n                (sceneType == SceneType.RadeonRays && (sSingleton.mOpenCLInitFailed || sSingleton.mRadeonRaysInitFailed)))\n            {\n                sceneType = SceneType.Default;\n            }\n\n            return sceneType;\n        }\n\n        public static ReflectionEffectType GetReflectionEffectType()\n        {\n            var reflectionEffectType = SteamAudioSettings.Singleton.reflectionEffectType;\n\n            if ((reflectionEffectType == ReflectionEffectType.TrueAudioNext && (sSingleton.mOpenCLInitFailed || sSingleton.mTrueAudioNextInitFailed)))\n            {\n                reflectionEffectType = ReflectionEffectType.Convolution;\n            }\n\n            return reflectionEffectType;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "enCLInitFailed || sSingleton.mTrueAudioNextInitFailed)))\n            {\n                reflectionEffectType = ReflectionEffectType.Convolution;\n            }\n\n            return reflectionEffectType;\n        }\n\n        public static PerspectiveCorrection GetPerspectiveCorrection()\n        {\n            if (!SteamAudioSettings.Singleton.perspectiveCorrection)\n                return default;\n\n            var mainCamera = Singleton.GetMainCamera();\n            PerspectiveCorrection correction = default;\n            if (mainCamera != null && mainCamera.aspect > .0f)\n            {\n                correction.enabled = SteamAudioSettings.Singleton.perspectiveCorrection ? Bool.True : Bool.False;\n                correction.xfactor = 1.0f * SteamAudioSettings.Singleton.perspectiveCorrectionFactor;\n                correction.yfactor = correction.xfactor / mainCamera.aspect;\n\n                // Camera space matches OpenGL convention. No need to transform matrix to ConvertTransform.\n                correction.transform = Common.TransformMatrix(mainCamera.projectionMatrix * mainCamera.worldToCameraMatrix);\n            }\n\n            return correction;\n        }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "ConvertTransform.\n                correction.transform = Common.TransformMatrix(mainCamera.projectionMatrix * mainCamera.worldToCameraMatrix);\n            }\n\n            return correction;\n        }\n\n        public Camera GetMainCamera()\n        {\n            return mMainCamera;\n        }\n\n        public static SimulationSettings GetSimulationSettings(bool baking)\n        {\n            var simulationSettings = new SimulationSettings { };\n            simulationSettings.sceneType = GetSceneType();\n            simulationSettings.reflectionType = GetReflectionEffectType();\n\n            if (baking)\n            {\n                simulationSettings.flags = SimulationFlags.Reflections | SimulationFlags.Pathing;\n                simulationSettings.maxNumRays = SteamAudioSettings.Singleton.bakingRays;\n                simulationSettings.numDiffuseSamples = 1024;\n                simulationSettings.maxDuration = SteamAudioSettings.Singleton.bakingDuration;\n                simulationSettings.maxOrder = SteamAudioSettings.Singleton.bakingAmbisonicOrder;\n                simulationSettings.numThreads = sSingleton.NumThreadsForCPUCorePercentage(SteamAudioSettings.Singleton.bakingCPUCoresPercentage);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "= SteamAudioSettings.Singleton.bakingAmbisonicOrder;\n                simulationSettings.numThreads = sSingleton.NumThreadsForCPUCorePercentage(SteamAudioSettings.Singleton.bakingCPUCoresPercentage);\n                simulationSettings.rayBatchSize = 16;\n            }\n            else\n            {\n                simulationSettings.flags = SimulationFlags.Direct | SimulationFlags.Reflections | SimulationFlags.Pathing;\n                simulationSettings.maxNumOcclusionSamples = SteamAudioSettings.Singleton.maxOcclusionSamples;\n                simulationSettings.maxNumRays = SteamAudioSettings.Singleton.realTimeRays;\n                simulationSettings.numDiffuseSamples = 1024;\n                simulationSettings.maxDuration = (simulationSettings.reflectionType == ReflectionEffectType.TrueAudioNext) ? SteamAudioSettings.Singleton.TANDuration : SteamAudioSettings.Singleton.realTimeDuration;\n                simulationSettings.maxOrder = (simulationSettings.reflectionType == ReflectionEffectType.TrueAudioNext) ? SteamAudioSettings.Singleton.TANAmbisonicOrder : SteamAudioSettings.Singleton.realTimeAmbisonicOrder;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "onSettings.maxOrder = (simulationSettings.reflectionType == ReflectionEffectType.TrueAudioNext) ? SteamAudioSettings.Singleton.TANAmbisonicOrder : SteamAudioSettings.Singleton.realTimeAmbisonicOrder;\n                simulationSettings.maxNumSources = (simulationSettings.reflectionType == ReflectionEffectType.TrueAudioNext) ? SteamAudioSettings.Singleton.TANMaxSources : SteamAudioSettings.Singleton.realTimeMaxSources;\n                simulationSettings.numThreads = sSingleton.NumThreadsForCPUCorePercentage(SteamAudioSettings.Singleton.realTimeCPUCoresPercentage);\n                simulationSettings.rayBatchSize = 16;\n                simulationSettings.numVisSamples = SteamAudioSettings.Singleton.bakingVisibilitySamples;\n                simulationSettings.samplingRate = AudioSettings.samplingRate;\n                simulationSettings.frameSize = AudioSettings.frameSize;\n            }\n\n            if (simulationSettings.sceneType == SceneType.RadeonRays)\n            {\n                simulationSettings.openCLDevice = sSingleton.mOpenCLDevice.Get();\n                simulationSettings.radeonRaysDevice = sSingleton.mRadeonRaysDevice.Get();\n            }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "{\n                simulationSettings.openCLDevice = sSingleton.mOpenCLDevice.Get();\n                simulationSettings.radeonRaysDevice = sSingleton.mRadeonRaysDevice.Get();\n            }\n\n            if (!baking && simulationSettings.reflectionType == ReflectionEffectType.TrueAudioNext)\n            {\n                simulationSettings.openCLDevice = sSingleton.mOpenCLDevice.Get();\n                simulationSettings.tanDevice = sSingleton.mTrueAudioNextDevice.Get();\n            }\n\n            return simulationSettings;\n        }\n\n        // This method is called at app startup (see above).\n        void OnApplicationStart(ManagerInitReason reason)\n        {\n            if (reason == ManagerInitReason.Playing)\n            {\n                SceneManager.sceneLoaded += OnSceneLoaded;\n                SceneManager.sceneUnloaded += OnSceneUnloaded;\n            }\n\n            mNumCPUCores = SystemInfo.processorCount;\n\n            mContext = new Context();\n\n            if (reason == ManagerInitReason.Playing)\n            {\n                mAudioSettings = AudioEngineStateHelpers.Create(SteamAudioSettings.Singleton.audioEngine).GetAudioSettings();"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "t();\n\n            if (reason == ManagerInitReason.Playing)\n            {\n                mAudioSettings = AudioEngineStateHelpers.Create(SteamAudioSettings.Singleton.audioEngine).GetAudioSettings();\n\n                mHRTFs = new HRTF[SteamAudioSettings.Singleton.SOFAFiles.Length + 1];\n\n                hrtfNames = new string[SteamAudioSettings.Singleton.SOFAFiles.Length + 1];\n                hrtfNames[0] = \"Default\";\n                for (var i = 0; i < SteamAudioSettings.Singleton.SOFAFiles.Length; ++i)\n                {\n                    if (SteamAudioSettings.Singleton.SOFAFiles[i])\n                        hrtfNames[i + 1] = SteamAudioSettings.Singleton.SOFAFiles[i].sofaName;\n                    else\n                        hrtfNames[i + 1] = null;\n                }\n\n                mHRTFs[0] = new HRTF(mContext, mAudioSettings, null, null, SteamAudioSettings.Singleton.hrtfVolumeGainDB, SteamAudioSettings.Singleton.hrtfNormalizationType);\n\n                for (var i = 0; i < SteamAudioSettings.Singleton.SOFAFiles.Length; ++i)\n                {\n                    if (SteamAudioSettings.Singleton.SOFAFiles[i])\n                    {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "e);\n\n                for (var i = 0; i < SteamAudioSettings.Singleton.SOFAFiles.Length; ++i)\n                {\n                    if (SteamAudioSettings.Singleton.SOFAFiles[i])\n                    {\n                        mHRTFs[i + 1] = new HRTF(mContext, mAudioSettings,\n                            SteamAudioSettings.Singleton.SOFAFiles[i].sofaName,\n                            SteamAudioSettings.Singleton.SOFAFiles[i].data,\n                            SteamAudioSettings.Singleton.SOFAFiles[i].volume,\n                            SteamAudioSettings.Singleton.SOFAFiles[i].normType);\n                    }\n                    else\n                    {\n                        Debug.LogWarning(\"SOFA Asset File Missing. Assigning default HRTF.\");\n                        mHRTFs[i + 1] = mHRTFs[0];\n                    }\n                }\n            }\n\n            if (reason != ManagerInitReason.EditingProbes)\n            {\n                if (SteamAudioSettings.Singleton.sceneType == SceneType.Embree)\n                {\n                    try\n                    {\n                        mEmbreeInitFailed = false;\n\n                        mEmbreeDevice = new EmbreeDevice(mContext);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "eneType.Embree)\n                {\n                    try\n                    {\n                        mEmbreeInitFailed = false;\n\n                        mEmbreeDevice = new EmbreeDevice(mContext);\n                    }\n                    catch (Exception e)\n                    {\n                        mEmbreeInitFailed = true;\n\n                        Debug.LogException(e);\n                        Debug.LogWarning(\"Embree initialization failed, reverting to Phonon for ray tracing.\");\n                    }\n                }\n\n                var requiresTAN = (SteamAudioSettings.Singleton.reflectionEffectType == ReflectionEffectType.TrueAudioNext);\n\n                if (SteamAudioSettings.Singleton.sceneType == SceneType.RadeonRays ||\n                    SteamAudioSettings.Singleton.reflectionEffectType == ReflectionEffectType.TrueAudioNext)\n                {\n                    try\n                    {\n                        mOpenCLInitFailed = false;\n\n                        mOpenCLDevice = new OpenCLDevice(mContext, SteamAudioSettings.Singleton.deviceType,\n                            SteamAudioSettings.Singleton.maxReservedComputeUnits,"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "= false;\n\n                        mOpenCLDevice = new OpenCLDevice(mContext, SteamAudioSettings.Singleton.deviceType,\n                            SteamAudioSettings.Singleton.maxReservedComputeUnits,\n                            SteamAudioSettings.Singleton.fractionComputeUnitsForIRUpdate,\n                            requiresTAN);\n                    }\n                    catch (Exception e)\n                    {\n                        mOpenCLInitFailed = true;\n\n                        Debug.LogException(e);\n\n                        var warningMessage = \"OpenCL initialization failed.\";\n                        if (SteamAudioSettings.Singleton.sceneType == SceneType.RadeonRays)\n                            warningMessage += \" Reverting to Phonon for ray tracing.\";\n                        if (SteamAudioSettings.Singleton.reflectionEffectType == ReflectionEffectType.TrueAudioNext)\n                            warningMessage += \" Reverting to Convolution for reflection effect processing.\";\n\n                        Debug.LogWarning(warningMessage);\n                    }\n                }\n\n                if (SteamAudioSettings.Singleton.sceneType == SceneType.RadeonRays &&"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "processing.\";\n\n                        Debug.LogWarning(warningMessage);\n                    }\n                }\n\n                if (SteamAudioSettings.Singleton.sceneType == SceneType.RadeonRays &&\n                    !mOpenCLInitFailed)\n                {\n                    try\n                    {\n                        mRadeonRaysInitFailed = false;\n\n                        mRadeonRaysDevice = new RadeonRaysDevice(mOpenCLDevice);\n                    }\n                    catch (Exception e)\n                    {\n                        mRadeonRaysInitFailed = true;\n\n                        Debug.LogException(e);\n                        Debug.LogWarning(\"Radeon Rays initialization failed, reverting to Phonon for ray tracing.\");\n                    }\n                }\n\n                if (SteamAudioSettings.Singleton.reflectionEffectType == ReflectionEffectType.TrueAudioNext &&\n                    reason == ManagerInitReason.Playing &&\n                    !mOpenCLInitFailed)\n                {\n                    try\n                    {\n                        mTrueAudioNextInitFailed = false;\n\n                        var frameSize = AudioSettings.frameSize;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "InitFailed)\n                {\n                    try\n                    {\n                        mTrueAudioNextInitFailed = false;\n\n                        var frameSize = AudioSettings.frameSize;\n                        var irSize = Mathf.CeilToInt(SteamAudioSettings.Singleton.realTimeDuration * AudioSettings.samplingRate);\n                        var order = SteamAudioSettings.Singleton.realTimeAmbisonicOrder;\n                        var maxSources = SteamAudioSettings.Singleton.TANMaxSources;\n\n                        mTrueAudioNextDevice = new TrueAudioNextDevice(mOpenCLDevice, frameSize, irSize,\n                            order, maxSources);\n                    }\n                    catch (Exception e)\n                    {\n                        mTrueAudioNextInitFailed = true;\n\n                        Debug.LogException(e);\n                        Debug.LogWarning(\"TrueAudio Next initialization failed, reverting to Convolution for reflection effect processing.\");\n                    }\n                }\n            }\n\n            if (reason == ManagerInitReason.Playing)\n            {\n                var simulationSettings = GetSimulationSettings(false);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "ng.\");\n                    }\n                }\n            }\n\n            if (reason == ManagerInitReason.Playing)\n            {\n                var simulationSettings = GetSimulationSettings(false);\n                var perspectiveCorrection = GetPerspectiveCorrection();\n\n                mSimulator = new Simulator(mContext, simulationSettings);\n\n                mSimulationThreadWaitHandle = new EventWaitHandle(false, EventResetMode.AutoReset);\n\n                mSimulationThread = new Thread(RunSimulation);\n                mSimulationThread.Start();\n\n                mAudioEngineState = AudioEngineState.Create(SteamAudioSettings.Singleton.audioEngine);\n                if (mAudioEngineState != null)\n                {\n                    mAudioEngineState.Initialize(mContext.Get(), mHRTFs[0].Get(), simulationSettings, perspectiveCorrection);\n                }\n\n#if UNITY_EDITOR && UNITY_2019_3_OR_NEWER\n                // If the developer has disabled scene reload, SceneManager.sceneLoaded won't fire during initial load\n                if ( EditorSettings.enterPlayModeOptionsEnabled &&"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "19_3_OR_NEWER\n                // If the developer has disabled scene reload, SceneManager.sceneLoaded won't fire during initial load\n                if ( EditorSettings.enterPlayModeOptionsEnabled &&\n                    EditorSettings.enterPlayModeOptions.HasFlag(EnterPlayModeOptions.DisableSceneReload))\n                {\n                    OnSceneLoaded(SceneManager.GetActiveScene(), LoadSceneMode.Single);\n                }\n#endif\n            }\n        }\n\n        // This method is called at app shutdown.\n        void OnApplicationQuit()\n        {\n            ShutDown();\n        }\n\n        // This method is called when a scene is loaded.\n        void OnSceneLoaded(UnityEngine.SceneManagement.Scene scene, LoadSceneMode loadSceneMode)\n        {\n            LoadScene(scene, mContext, additive: (loadSceneMode == LoadSceneMode.Additive));\n\n            NotifyMainCameraChanged();\n            NotifyAudioListenerChanged();\n        }\n\n        // This method is called when a scene is unloaded.\n        void OnSceneUnloaded(UnityEngine.SceneManagement.Scene scene)\n        {\n            RemoveAllDynamicObjects();\n        }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "}\n\n        // This method is called when a scene is unloaded.\n        void OnSceneUnloaded(UnityEngine.SceneManagement.Scene scene)\n        {\n            RemoveAllDynamicObjects();\n        }\n\n        /** Notifies Steam Audio that the \\c AudioListener has changed.\n         *\n         *  Call this function when you create a new \\c AudioListener component (or its equivalent, if you are using\n         *  third-party audio middleware).\n         *\n         *  Steam Audio attempts to find the \\c AudioListener whenever the scene changes, but if the \\c AudioListener\n         *  changes dynamically after the scene has been loaded, this function must be called, otherwise simulation\n         *  results will be incorrect.\n         *\n         *  If the \\c AudioListener starts out disabled, but is then enabled after scene load, this function\n         *  must be called, because Steam Audio does not consider disabled \\c AudioListener components in its initial search.\n         *\n         *  Use this function if you want Steam Audio to automatically find the new AudioListener.\n         */\n        public static void NotifyAudioListenerChanged()\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "ial search.\n         *\n         *  Use this function if you want Steam Audio to automatically find the new AudioListener.\n         */\n        public static void NotifyAudioListenerChanged()\n        {\n            NotifyAudioListenerChangedTo(AudioEngineStateHelpers.Create(SteamAudioSettings.Singleton.audioEngine).GetListenerTransform());\n        }\n\n        /** Notifies Steam Audio that the \\c AudioListener has changed to a specific \\c GameObject.\n         *  Call this function when you want to explicitly specify a new \\c AudioListener component (or its equivalent, if\n         *  you are using third-party audio middleware).\n         *\n         *  Steam Audio attempts to find the \\c AudioListener whenever the scene changes, but if the \\c AudioListener\n         *  changes dynamically after the scene has been loaded, this function must be called, otherwise simulation\n         *  results will be incorrect.\n         *\n         *  If the \\c AudioListener starts out disabled, but is then enabled after scene load, this function\n         *  must be called, because Steam Audio does not consider disabled \\c AudioListener components in its initial search.\n         *"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "disabled, but is then enabled after scene load, this function\n         *  must be called, because Steam Audio does not consider disabled \\c AudioListener components in its initial search.\n         *\n         *  \\param[in]  listenerTransform   The \\c Transform component attached to the \\c GameObject that contains the \\c AudioListener.\n         */\n        public static void NotifyAudioListenerChangedTo(Transform listenerTransform)\n        {\n            sSingleton.mListener = listenerTransform;\n            if (sSingleton.mListener)\n            {\n                sSingleton.mListenerComponent = sSingleton.mListener.GetComponent<SteamAudioListener>();\n            }\n        }\n\n        // Call this function when you create or change the main camera.\n        public static void NotifyMainCameraChanged()\n        {\n            sSingleton.mMainCamera = Camera.main;\n        }\n\n        // Call this function to request that changes to a scene be committed. Call only when changes have happened.\n        public static void ScheduleCommitScene()\n        {\n            sSingleton.mSceneCommitRequired = true;\n        }\n\n#if STEAMAUDIO_ENABLED\n        private void LateUpdate()\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "happened.\n        public static void ScheduleCommitScene()\n        {\n            sSingleton.mSceneCommitRequired = true;\n        }\n\n#if STEAMAUDIO_ENABLED\n        private void LateUpdate()\n        {\n            if (mAudioEngineState == null)\n                return;\n\n            mAudioEngineState.SetHRTFDisabled(SteamAudioSettings.Singleton.hrtfDisabled);\n            var perspectiveCorrection = GetPerspectiveCorrection();\n            mAudioEngineState.SetPerspectiveCorrection(perspectiveCorrection);\n\n            mAudioEngineState.SetHRTF(CurrentHRTF.Get());\n\n            if (mCurrentScene == null || mSimulator == null)\n                return;\n\n            if (mSimulationThread.ThreadState == ThreadState.WaitSleepJoin)\n            {\n                if (mSceneCommitRequired)\n                {\n                    mCurrentScene.Commit();\n                    mSceneCommitRequired = false;\n                }\n\n                mSimulator.SetScene(mCurrentScene);\n                mSimulator.Commit();\n            }\n\n            var sharedInputs = new SimulationSharedInputs { };\n\n            if (mListener != null)\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "Simulator.SetScene(mCurrentScene);\n                mSimulator.Commit();\n            }\n\n            var sharedInputs = new SimulationSharedInputs { };\n\n            if (mListener != null)\n            {\n                sharedInputs.listener.origin = Common.ConvertVector(mListener.position);\n                sharedInputs.listener.ahead = Common.ConvertVector(mListener.forward);\n                sharedInputs.listener.up = Common.ConvertVector(mListener.up);\n                sharedInputs.listener.right = Common.ConvertVector(mListener.right);\n            }\n\n            sharedInputs.numRays = SteamAudioSettings.Singleton.realTimeRays;\n            sharedInputs.numBounces = SteamAudioSettings.Singleton.realTimeBounces;\n            sharedInputs.duration = SteamAudioSettings.Singleton.realTimeDuration;\n            sharedInputs.order = SteamAudioSettings.Singleton.realTimeAmbisonicOrder;\n            sharedInputs.irradianceMinDistance = SteamAudioSettings.Singleton.realTimeIrradianceMinDistance;\n            sharedInputs.pathingVisualizationCallback = null;\n            sharedInputs.pathingUserData = IntPtr.Zero;\n\n            mSimulator.SetSharedInputs(SimulationFlags.Direct, sharedInputs);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": ";\n            sharedInputs.pathingVisualizationCallback = null;\n            sharedInputs.pathingUserData = IntPtr.Zero;\n\n            mSimulator.SetSharedInputs(SimulationFlags.Direct, sharedInputs);\n\n            foreach (var source in mSources)\n            {\n                source.SetInputs(SimulationFlags.Direct);\n            }\n\n            foreach (var listener in mListeners)\n            {\n                listener.SetInputs(SimulationFlags.Direct);\n            }\n\n            mSimulator.RunDirect();\n\n            foreach (var source in mSources)\n            {\n                source.UpdateOutputs(SimulationFlags.Direct);\n            }\n\n            foreach (var listener in mListeners)\n            {\n                listener.UpdateOutputs(SimulationFlags.Direct);\n            }\n\n            mSimulationUpdateTimeElapsed += Time.deltaTime;\n            if (mSimulationUpdateTimeElapsed < SteamAudioSettings.Singleton.simulationUpdateInterval)\n                return;\n\n            mSimulationUpdateTimeElapsed = 0.0f;\n\n            if (mSimulationThread.ThreadState == ThreadState.WaitSleepJoin)\n            {\n                if (mSimulationCompleted)\n                {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "mSimulationUpdateTimeElapsed = 0.0f;\n\n            if (mSimulationThread.ThreadState == ThreadState.WaitSleepJoin)\n            {\n                if (mSimulationCompleted)\n                {\n                    mSimulationCompleted = false;\n\n                    foreach (var source in mSources)\n                    {\n                        source.UpdateOutputs(SimulationFlags.Reflections | SimulationFlags.Pathing);\n                    }\n\n                    foreach (var listener in mListeners)\n                    {\n                        listener.UpdateOutputs(SimulationFlags.Reflections | SimulationFlags.Pathing);\n                    }\n                }\n\n                mSimulator.SetSharedInputs(SimulationFlags.Reflections | SimulationFlags.Pathing, sharedInputs);\n\n                foreach (var source in mSources)\n                {\n                    source.SetInputs(SimulationFlags.Reflections | SimulationFlags.Pathing);\n                }\n\n                foreach (var listener in mListeners)\n                {\n                    listener.SetInputs(SimulationFlags.Reflections | SimulationFlags.Pathing);\n                }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "}\n\n                foreach (var listener in mListeners)\n                {\n                    listener.SetInputs(SimulationFlags.Reflections | SimulationFlags.Pathing);\n                }\n\n                if (SteamAudioSettings.Singleton.sceneType == SceneType.Custom)\n                {\n                    // The Unity ray tracer must be called from the main thread only, so run the simulation here.\n                    // It's not suitable for heavy workloads anyway, so we assume that the performance hit is\n                    // acceptable. If not, we recommend switching to one of the other ray tracers.\n                    RunSimulationInternal();\n                }\n                else\n                {\n                    mSimulationThreadWaitHandle.Set();\n                }\n            }\n        }\n#endif\n\n        void RunSimulationInternal()\n        {\n            if (mSimulator == null)\n                return;\n\n            mSimulator.RunReflections();\n            mSimulator.RunPathing();\n\n            mSimulationCompleted = true;\n        }\n\n        void RunSimulation()\n        {\n            while (!mStopSimulationThread)\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "eflections();\n            mSimulator.RunPathing();\n\n            mSimulationCompleted = true;\n        }\n\n        void RunSimulation()\n        {\n            while (!mStopSimulationThread)\n            {\n                mSimulationThreadWaitHandle.WaitOne();\n\n                if (mStopSimulationThread)\n                    break;\n\n                RunSimulationInternal();\n            }\n        }\n\n        public static void Initialize(ManagerInitReason reason)\n        {\n            var managerObject = new GameObject(\"Steam Audio Manager\");\n            var manager = managerObject.AddComponent<SteamAudioManager>();\n\n            if (reason == ManagerInitReason.Playing)\n            {\n                DontDestroyOnLoad(managerObject);\n            }\n\n            sSingleton = manager;\n\n            manager.OnApplicationStart(reason);\n        }\n\n        public static void ShutDown()\n        {\n            if (sSingleton.mSimulationThread != null)\n            {\n                sSingleton.mStopSimulationThread = true;\n                sSingleton.mSimulationThreadWaitHandle.Set();\n                sSingleton.mSimulationThread.Join();\n            }\n\n            RemoveAllDynamicObjects(force: true);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "ationThread = true;\n                sSingleton.mSimulationThreadWaitHandle.Set();\n                sSingleton.mSimulationThread.Join();\n            }\n\n            RemoveAllDynamicObjects(force: true);\n            RemoveAllAdditiveScenes();\n\n            if (sSingleton.mAudioEngineState != null)\n            {\n                sSingleton.mAudioEngineState.Destroy();\n            }\n\n            if (sSingleton.mSimulator != null)\n            {\n                sSingleton.mSimulator.Release();\n                sSingleton.mSimulator = null;\n            }\n\n            if (sSingleton.mTrueAudioNextDevice != null)\n            {\n                sSingleton.mTrueAudioNextDevice.Release();\n                sSingleton.mTrueAudioNextDevice = null;\n            }\n\n            if (sSingleton.mRadeonRaysDevice != null)\n            {\n                sSingleton.mRadeonRaysDevice.Release();\n                sSingleton.mRadeonRaysDevice = null;\n            }\n\n            if (sSingleton.mOpenCLDevice != null)\n            {\n                sSingleton.mOpenCLDevice.Release();\n                sSingleton.mOpenCLDevice = null;\n            }\n\n            if (sSingleton.mEmbreeDevice != null)\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "null)\n            {\n                sSingleton.mOpenCLDevice.Release();\n                sSingleton.mOpenCLDevice = null;\n            }\n\n            if (sSingleton.mEmbreeDevice != null)\n            {\n                sSingleton.mEmbreeDevice.Release();\n                sSingleton.mEmbreeDevice = null;\n            }\n\n            if (sSingleton.mHRTFs != null)\n            {\n                for (var i = 0; i < sSingleton.mHRTFs.Length; ++i)\n                {\n                    sSingleton.mHRTFs[i].Release();\n                    sSingleton.mHRTFs[i] = null;\n                }\n            }\n\n            SceneManager.sceneLoaded -= sSingleton.OnSceneLoaded;\n            SceneManager.sceneUnloaded -= sSingleton.OnSceneUnloaded;\n\n            sSingleton.mContext.Release();\n            sSingleton.mContext = null;\n        }\n\n        public static void Reinitialize()\n        {\n            if (sSingleton.mSimulationThread != null)\n            {\n                sSingleton.mStopSimulationThread = true;\n                sSingleton.mSimulationThreadWaitHandle.Set();\n                sSingleton.mSimulationThread.Join();\n            }\n\n            RemoveAllDynamicObjects(force: true);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "ationThread = true;\n                sSingleton.mSimulationThreadWaitHandle.Set();\n                sSingleton.mSimulationThread.Join();\n            }\n\n            RemoveAllDynamicObjects(force: true);\n            RemoveAllAdditiveScenes();\n\n            if (sSingleton.mAudioEngineState != null)\n            {\n                sSingleton.mAudioEngineState.Destroy();\n            }\n\n            sSingleton.mSimulator = null;\n\n            UnityEngine.AudioSettings.Reset(UnityEngine.AudioSettings.GetConfiguration());\n\n            if ((sSingleton.mEmbreeDevice == null || sSingleton.mEmbreeDevice.Get() == IntPtr.Zero)\n                && SteamAudioSettings.Singleton.sceneType == SceneType.Embree)\n            {\n                try\n                {\n                    sSingleton.mEmbreeInitFailed = false;\n\n                    sSingleton.mEmbreeDevice = new EmbreeDevice(sSingleton.mContext);\n                }\n                catch (Exception e)\n                {\n                    sSingleton.mEmbreeInitFailed = true;\n\n                    Debug.LogException(e);\n                    Debug.LogWarning(\"Embree initialization failed, reverting to Phonon for ray tracing.\");\n                }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "ton.mEmbreeInitFailed = true;\n\n                    Debug.LogException(e);\n                    Debug.LogWarning(\"Embree initialization failed, reverting to Phonon for ray tracing.\");\n                }\n            }\n\n            var requiresTAN = (SteamAudioSettings.Singleton.reflectionEffectType == ReflectionEffectType.TrueAudioNext);\n\n            if ((sSingleton.mOpenCLDevice == null || sSingleton.mOpenCLDevice.Get() == IntPtr.Zero) &&\n                (SteamAudioSettings.Singleton.sceneType == SceneType.RadeonRays ||\n                SteamAudioSettings.Singleton.reflectionEffectType == ReflectionEffectType.TrueAudioNext))\n            {\n                try\n                {\n                    sSingleton.mOpenCLInitFailed = false;\n\n                    sSingleton.mOpenCLDevice = new OpenCLDevice(sSingleton.mContext, SteamAudioSettings.Singleton.deviceType,\n                        SteamAudioSettings.Singleton.maxReservedComputeUnits,\n                        SteamAudioSettings.Singleton.fractionComputeUnitsForIRUpdate,\n                        requiresTAN);\n                }\n                catch (Exception e)\n                {\n                    sSingleton.mOpenCLInitFailed = true;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "ractionComputeUnitsForIRUpdate,\n                        requiresTAN);\n                }\n                catch (Exception e)\n                {\n                    sSingleton.mOpenCLInitFailed = true;\n\n                    Debug.LogException(e);\n\n                    var warningMessage = \"OpenCL initialization failed.\";\n                    if (SteamAudioSettings.Singleton.sceneType == SceneType.RadeonRays)\n                        warningMessage += \" Reverting to Phonon for ray tracing.\";\n                    if (SteamAudioSettings.Singleton.reflectionEffectType == ReflectionEffectType.TrueAudioNext)\n                        warningMessage += \" Reverting to Convolution for reflection effect processing.\";\n\n                    Debug.LogWarning(warningMessage);\n                }\n            }\n\n            if ((sSingleton.mRadeonRaysDevice == null || sSingleton.mRadeonRaysDevice.Get() == IntPtr.Zero) &&\n                SteamAudioSettings.Singleton.sceneType == SceneType.RadeonRays &&\n                !sSingleton.mOpenCLInitFailed)\n            {\n                try\n                {\n                    sSingleton.mRadeonRaysInitFailed = false;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": ".sceneType == SceneType.RadeonRays &&\n                !sSingleton.mOpenCLInitFailed)\n            {\n                try\n                {\n                    sSingleton.mRadeonRaysInitFailed = false;\n\n                    sSingleton.mRadeonRaysDevice = new RadeonRaysDevice(sSingleton.mOpenCLDevice);\n                }\n                catch (Exception e)\n                {\n                    sSingleton.mRadeonRaysInitFailed = true;\n\n                    Debug.LogException(e);\n                    Debug.LogWarning(\"Radeon Rays initialization failed, reverting to Phonon for ray tracing.\");\n                }\n            }\n\n            if ((sSingleton.mTrueAudioNextDevice == null || sSingleton.mTrueAudioNextDevice.Get() == IntPtr.Zero) &&\n                SteamAudioSettings.Singleton.reflectionEffectType == ReflectionEffectType.TrueAudioNext &&\n                !sSingleton.mOpenCLInitFailed)\n            {\n                try\n                {\n                    sSingleton.mTrueAudioNextInitFailed = false;\n\n                    var frameSize = AudioSettings.frameSize;\n                    var irSize = Mathf.CeilToInt(SteamAudioSettings.Singleton.realTimeDuration * AudioSettings.samplingRate);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "ed = false;\n\n                    var frameSize = AudioSettings.frameSize;\n                    var irSize = Mathf.CeilToInt(SteamAudioSettings.Singleton.realTimeDuration * AudioSettings.samplingRate);\n                    var order = SteamAudioSettings.Singleton.realTimeAmbisonicOrder;\n                    var maxSources = SteamAudioSettings.Singleton.TANMaxSources;\n\n                    sSingleton.mTrueAudioNextDevice = new TrueAudioNextDevice(sSingleton.mOpenCLDevice, frameSize, irSize,\n                        order, maxSources);\n                }\n                catch (Exception e)\n                {\n                    sSingleton.mTrueAudioNextInitFailed = true;\n\n                    Debug.LogException(e);\n                    Debug.LogWarning(\"TrueAudio Next initialization failed, reverting to Convolution for reflection effect processing.\");\n                }\n            }\n\n            var simulationSettings = GetSimulationSettings(false);\n            var persPectiveCorrection = GetPerspectiveCorrection();\n\n            sSingleton.mSimulator = new Simulator(sSingleton.mContext, simulationSettings);\n\n            sSingleton.mStopSimulationThread = false;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "persPectiveCorrection = GetPerspectiveCorrection();\n\n            sSingleton.mSimulator = new Simulator(sSingleton.mContext, simulationSettings);\n\n            sSingleton.mStopSimulationThread = false;\n            sSingleton.mSimulationThread = new Thread(sSingleton.RunSimulation);\n            sSingleton.mSimulationThread.Start();\n\n            sSingleton.mAudioEngineState = AudioEngineState.Create(SteamAudioSettings.Singleton.audioEngine);\n            if (sSingleton.mAudioEngineState != null)\n            {\n                sSingleton.mAudioEngineState.Initialize(sSingleton.mContext.Get(), sSingleton.mHRTFs[0].Get(), simulationSettings, persPectiveCorrection);\n\n                var listeners = new SteamAudioListener[sSingleton.mListeners.Count];\n                sSingleton.mListeners.CopyTo(listeners);\n                foreach (var listener in listeners)\n                {\n                    listener.enabled = false;\n                    listener.Reinitialize();\n                    listener.enabled = true;\n                }\n            }\n        }\n\n        public static void AddSource(SteamAudioSource source)\n        {\n            sSingleton.mSources.Add(source);\n        }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "listener.enabled = true;\n                }\n            }\n        }\n\n        public static void AddSource(SteamAudioSource source)\n        {\n            sSingleton.mSources.Add(source);\n        }\n\n        public static void RemoveSource(SteamAudioSource source)\n        {\n            sSingleton.mSources.Remove(source);\n        }\n\n        public static void AddListener(SteamAudioListener listener)\n        {\n            sSingleton.mListeners.Add(listener);\n        }\n\n        public static void RemoveListener(SteamAudioListener listener)\n        {\n            sSingleton.mListeners.Remove(listener);\n        }\n\n#if UNITY_EDITOR\n        [MenuItem(\"Steam Audio/Settings\", false, 1)]\n        public static void EditSettings()\n        {\n            Selection.activeObject = SteamAudioSettings.Singleton;\n#if UNITY_2018_2_OR_NEWER\n            EditorApplication.ExecuteMenuItem(\"Window/General/Inspector\");\n#else\n            EditorApplication.ExecuteMenuItem(\"Window/Inspector\");\n#endif\n        }\n\n        [MenuItem(\"Steam Audio/Export Active Scene\", false, 12)]\n        public static void ExportActiveScene()\n        {\n            ExportScene(SceneManager.GetActiveScene(), false);\n        }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "}\n\n        [MenuItem(\"Steam Audio/Export Active Scene\", false, 12)]\n        public static void ExportActiveScene()\n        {\n            ExportScene(SceneManager.GetActiveScene(), false);\n        }\n\n        [MenuItem(\"Steam Audio/Export All Open Scenes\", false, 13)]\n        public static void ExportAllOpenScenes()\n        {\n            for (var i = 0; i < SceneManager.sceneCount; ++i)\n            {\n                var scene = SceneManager.GetSceneAt(i);\n\n                EditorUtility.DisplayProgressBar(\"Steam Audio\", string.Format(\"Exporting scene: {0}\", scene.name), (float)i / (float)SceneManager.sceneCount);\n\n                if (!scene.isLoaded)\n                {\n                    Debug.LogWarning(string.Format(\"Scene {0} is not loaded in the hierarchy.\", scene.name));\n                    continue;\n                }\n\n                ExportScene(scene, false);\n            }\n\n            EditorUtility.DisplayProgressBar(\"Steam Audio\", \"\", 1.0f);\n            EditorUtility.ClearProgressBar();\n        }\n\n        [MenuItem(\"Steam Audio/Export All Scenes In Build\", false, 14)]\n        public static void ExportAllScenesInBuild()\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": ", 1.0f);\n            EditorUtility.ClearProgressBar();\n        }\n\n        [MenuItem(\"Steam Audio/Export All Scenes In Build\", false, 14)]\n        public static void ExportAllScenesInBuild()\n        {\n            for (var i = 0; i < SceneManager.sceneCountInBuildSettings; ++i)\n            {\n                var scene = SceneManager.GetSceneByBuildIndex(i);\n\n                EditorUtility.DisplayProgressBar(\"Steam Audio\", string.Format(\"Exporting scene: {0}\", scene.name), (float)i / (float)SceneManager.sceneCountInBuildSettings);\n\n                var shouldClose = false;\n                if (!scene.isLoaded)\n                {\n                    scene = EditorSceneManager.OpenScene(SceneUtility.GetScenePathByBuildIndex(i), OpenSceneMode.Additive);\n                    shouldClose = true;\n                }\n\n                ExportScene(scene, false);\n\n                if (shouldClose)\n                {\n                    EditorSceneManager.CloseScene(scene, true);\n                }\n            }\n\n            EditorUtility.DisplayProgressBar(\"Steam Audio\", \"\", 1.0f);\n            EditorUtility.ClearProgressBar();\n        }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "rSceneManager.CloseScene(scene, true);\n                }\n            }\n\n            EditorUtility.DisplayProgressBar(\"Steam Audio\", \"\", 1.0f);\n            EditorUtility.ClearProgressBar();\n        }\n\n        [MenuItem(\"Steam Audio/Export Active Scene To OBJ\", false, 25)]\n        public static void ExportActiveSceneToOBJ()\n        {\n            ExportScene(SceneManager.GetActiveScene(), true);\n        }\n\n        [MenuItem(\"Steam Audio/Export Dynamic Objects In Active Scene\", false, 36)]\n        public static void ExportDynamicObjectsInActiveScene()\n        {\n            ExportDynamicObjectsInArray(GetDynamicObjectsInScene(SceneManager.GetActiveScene()));\n        }\n\n        [MenuItem(\"Steam Audio/Export Dynamic Objects In All Open Scenes\", false, 37)]\n        public static void ExportDynamicObjectsInAllOpenScenes()\n        {\n            for (var i = 0; i < SceneManager.sceneCount; ++i)\n            {\n                var scene = SceneManager.GetSceneAt(i);\n\n                EditorUtility.DisplayProgressBar(\"Steam Audio\", string.Format(\"Exporting dynamic objects in scene: {0}\", scene.name), (float)i / (float)SceneManager.sceneCount);\n\n                if (!scene.isLoaded)"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "EditorUtility.DisplayProgressBar(\"Steam Audio\", string.Format(\"Exporting dynamic objects in scene: {0}\", scene.name), (float)i / (float)SceneManager.sceneCount);\n\n                if (!scene.isLoaded)\n                {\n                    Debug.LogWarning(string.Format(\"Scene {0} is not loaded in the hierarchy.\", scene.name));\n                    continue;\n                }\n\n                ExportDynamicObjectsInArray(GetDynamicObjectsInScene(scene));\n            }\n\n            EditorUtility.DisplayProgressBar(\"Steam Audio\", \"\", 1.0f);\n            EditorUtility.ClearProgressBar();\n        }\n\n        [MenuItem(\"Steam Audio/Export Dynamic Objects In All Scenes In Build\", false, 38)]\n        public static void ExportDynamicObjectsInBuild()\n        {\n            for (var i = 0; i < SceneManager.sceneCountInBuildSettings; ++i)\n            {\n                var scene = SceneManager.GetSceneByBuildIndex(i);\n\n                EditorUtility.DisplayProgressBar(\"Steam Audio\", string.Format(\"Exporting dynamic objects in scene: {0}\", scene.name), (float)i / (float)SceneManager.sceneCountInBuildSettings);\n\n                var shouldClose = false;\n                if (!scene.isLoaded)"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "ormat(\"Exporting dynamic objects in scene: {0}\", scene.name), (float)i / (float)SceneManager.sceneCountInBuildSettings);\n\n                var shouldClose = false;\n                if (!scene.isLoaded)\n                {\n                    scene = EditorSceneManager.OpenScene(SceneUtility.GetScenePathByBuildIndex(i), OpenSceneMode.Additive);\n                    shouldClose = true;\n                }\n\n                ExportDynamicObjectsInArray(GetDynamicObjectsInScene(scene));\n\n                if (shouldClose)\n                {\n                    EditorSceneManager.CloseScene(scene, true);\n                }\n            }\n\n            EditorUtility.DisplayProgressBar(\"Steam Audio\", \"\", 1.0f);\n            EditorUtility.ClearProgressBar();\n        }\n\n        [MenuItem(\"Steam Audio/Export All Dynamic Objects In Project\", false, 39)]\n        public static void ExportDynamicObjectsInProject()\n        {\n            var scenes = AssetDatabase.FindAssets(\"t:Scene\");\n            var prefabs = AssetDatabase.FindAssets(\"t:Prefab\");\n\n            var numItems = scenes.Length + prefabs.Length;\n\n            var index = 0;\n            foreach (var sceneGUID in scenes)\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "var prefabs = AssetDatabase.FindAssets(\"t:Prefab\");\n\n            var numItems = scenes.Length + prefabs.Length;\n\n            var index = 0;\n            foreach (var sceneGUID in scenes)\n            {\n                var scenePath = AssetDatabase.GUIDToAssetPath(sceneGUID);\n\n                EditorUtility.DisplayProgressBar(\"Steam Audio\", string.Format(\"Exporting dynamic objects in scene: {0}\", scenePath), (float)index / (float)numItems);\n\n                var activeScene = EditorSceneManager.GetActiveScene();\n                var isLoadedScene = (scenePath == activeScene.path);\n\n                var scene = activeScene;\n                if (!isLoadedScene)\n                {\n#if UNITY_2019_2_OR_NEWER\n                    var packageInfo = UnityEditor.PackageManager.PackageInfo.FindForAssetPath(scenePath);\n                    if (!(packageInfo == null || packageInfo.source == PackageSource.Embedded || packageInfo.source == PackageSource.Local))\n                    {\n                        Debug.LogWarning(string.Format(\"Scene {0} is part of a read-only package, skipping.\", scenePath));\n                        continue;\n                    }\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "{\n                        Debug.LogWarning(string.Format(\"Scene {0} is part of a read-only package, skipping.\", scenePath));\n                        continue;\n                    }\n#endif\n\n                    scene = EditorSceneManager.OpenScene(scenePath, OpenSceneMode.Additive);\n                }\n\n                ExportDynamicObjectsInArray(GetDynamicObjectsInScene(scene));\n\n                if (!isLoadedScene)\n                {\n                    EditorSceneManager.CloseScene(scene, true);\n                }\n\n                ++index;\n            }\n\n            foreach (var prefabGUID in prefabs)\n            {\n                var prefabPath = AssetDatabase.GUIDToAssetPath(prefabGUID);\n\n                EditorUtility.DisplayProgressBar(\"Steam Audio\", string.Format(\"Exporting dynamic objects in prefab: {0}\", prefabPath), (float)index / (float)numItems);\n\n                var prefab = AssetDatabase.LoadMainAssetAtPath(prefabPath) as GameObject;\n                var dynamicObjects = prefab.GetComponentsInChildren<SteamAudioDynamicObject>();\n                ExportDynamicObjectsInArray(dynamicObjects);\n\n                ++index;\n            }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": ";\n                var dynamicObjects = prefab.GetComponentsInChildren<SteamAudioDynamicObject>();\n                ExportDynamicObjectsInArray(dynamicObjects);\n\n                ++index;\n            }\n\n            EditorUtility.DisplayProgressBar(\"Steam Audio\", \"\", 1.0f);\n            EditorUtility.ClearProgressBar();\n        }\n\n        [MenuItem(\"Steam Audio/Install FMOD Studio Plugin Files\", false, 50)]\n        public static void InstallFMODStudioPluginFiles()\n        {\n            // Make sure the FMOD Studio Unity integration is installed.\n            var assemblySuffix = \",FMODUnity\";\n            var FMODUnity_Settings = Type.GetType(\"FMODUnity.Settings\" + assemblySuffix);\n            if (FMODUnity_Settings == null)\n            {\n                EditorUtility.DisplayDialog(\"Steam Audio\",\n                    \"The FMOD Studio Unity integration does not seem to be installed to your Unity project. Install \" +\n                    \"it and try again.\",\n                    \"OK\");\n                return;\n            }\n\n            // Make sure we're using at least FMOD Studio v2.0.\n            var FMODUnity_Settings_Instance = FMODUnity_Settings.GetProperty(\"Instance\");"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "\"OK\");\n                return;\n            }\n\n            // Make sure we're using at least FMOD Studio v2.0.\n            var FMODUnity_Settings_Instance = FMODUnity_Settings.GetProperty(\"Instance\");\n            var FMODUnity_Settings_CurrentVersion = FMODUnity_Settings.GetField(\"CurrentVersion\");\n            var fmodSettings = FMODUnity_Settings_Instance.GetValue(null, null);\n            var fmodVersion = (int)FMODUnity_Settings_CurrentVersion.GetValue(fmodSettings);\n            var fmodVersionMajor = (fmodVersion & 0x00ff0000) >> 16;\n            var fmodVersionMinor = (fmodVersion & 0x0000ff00) >> 8;\n            var fmodVersionPatch = (fmodVersion & 0x000000ff);\n            if (fmodVersionMajor < 2)\n            {\n                EditorUtility.DisplayDialog(\"Steam Audio\",\n                    \"Steam Audio requires FMOD Studio 2.0 or later.\",\n                    \"OK\");\n                return;\n            }\n\n            var moveRequired = false;\n            var moveSucceeded = false;\n\n            // Look for the FMOD Studio plugin files. The files are in the right place for FMOD Studio 2.2\n            // out of the box, but will need to be copied for 2.1 or earlier."
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "eded = false;\n\n            // Look for the FMOD Studio plugin files. The files are in the right place for FMOD Studio 2.2\n            // out of the box, but will need to be copied for 2.1 or earlier.\n            // 2.0 through 2.1 expect plugin files in Assets/Plugins/FMOD/lib/(platform)\n            // 2.2 expects plugin files in Assets/Plugins/FMOD/platforms/(platform)/lib\n            if (AssetExists(\"Assets/Plugins/FMOD/lib/win/x86_64/phonon_fmod.dll\"))\n            {\n                // Files are in the location corresponding to 2.1 or earlier.\n                if (fmodVersionMinor >= 2)\n                {\n                    // We're using 2.2 or later, so we need to move files.\n                    moveRequired = true;\n\n                    var moves = new Dictionary<string, string>();\n                    moves.Add(\"Assets/Plugins/FMOD/lib/win/x86/phonon_fmod.dll\", \"Assets/Plugins/FMOD/platforms/win/lib/x86/phonon_fmod.dll\");\n                    moves.Add(\"Assets/Plugins/FMOD/lib/win/x86_64/phonon_fmod.dll\", \"Assets/Plugins/FMOD/platforms/win/lib/x86_64/phonon_fmod.dll\");"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "gins/FMOD/platforms/win/lib/x86/phonon_fmod.dll\");\n                    moves.Add(\"Assets/Plugins/FMOD/lib/win/x86_64/phonon_fmod.dll\", \"Assets/Plugins/FMOD/platforms/win/lib/x86_64/phonon_fmod.dll\");\n                    moves.Add(\"Assets/Plugins/FMOD/lib/linux/x86/libphonon_fmod.so\", \"Assets/Plugins/FMOD/platforms/linux/lib/x86/libphonon_fmod.so\");\n                    moves.Add(\"Assets/Plugins/FMOD/lib/linux/x86_64/libphonon_fmod.so\", \"Assets/Plugins/FMOD/platforms/linux/lib/x86_64/libphonon_fmod.so\");\n                    moves.Add(\"Assets/Plugins/FMOD/lib/mac/phonon_fmod.bundle\", \"Assets/Plugins/FMOD/platforms/mac/lib/phonon_fmod.bundle\");\n                    moves.Add(\"Assets/Plugins/FMOD/lib/android/armeabi-v7a/libphonon_fmod.so\", \"Assets/Plugins/FMOD/platforms/android/lib/armeabi-v7a/libphonon_fmod.so\");\n                    moves.Add(\"Assets/Plugins/FMOD/lib/android/arm64-v8a/libphonon_fmod.so\", \"Assets/Plugins/FMOD/platforms/android/lib/arm64-v8a/libphonon_fmod.so\");\n                    moves.Add(\"Assets/Plugins/FMOD/lib/android/x86/libphonon_fmod.so\", \"Assets/Plugins/FMOD/platforms/android/lib/x86/libphonon_fmod.so\");\n\n                    moveSucceeded = MoveAssets(moves);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "moves.Add(\"Assets/Plugins/FMOD/lib/android/x86/libphonon_fmod.so\", \"Assets/Plugins/FMOD/platforms/android/lib/x86/libphonon_fmod.so\");\n\n                    moveSucceeded = MoveAssets(moves);\n                }\n            }\n            else if (AssetExists(\"Assets/Plugins/FMOD/platforms/win/lib/x86_64/phonon_fmod.dll\"))\n            {\n                // Files are in the location corresponding to 2.2 or later.\n                if (fmodVersionMinor <= 1)\n                {\n                    // We're using 2.1 or earlier, so we need to move files.\n                    moveRequired = true;\n\n                    var moves = new Dictionary<string, string>();\n                    moves.Add(\"Assets/Plugins/FMOD/platforms/win/lib/x86/phonon_fmod.dll\", \"Assets/Plugins/FMOD/lib/win/x86/phonon_fmod.dll\");\n                    moves.Add(\"Assets/Plugins/FMOD/platforms/win/lib/x86_64/phonon_fmod.dll\", \"Assets/Plugins/FMOD/lib/win/x86_64/phonon_fmod.dll\");\n                    moves.Add(\"Assets/Plugins/FMOD/platforms/linux/lib/x86/libphonon_fmod.so\", \"Assets/Plugins/FMOD/lib/linux/x86/libphonon_fmod.so\");"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "s/Plugins/FMOD/lib/win/x86_64/phonon_fmod.dll\");\n                    moves.Add(\"Assets/Plugins/FMOD/platforms/linux/lib/x86/libphonon_fmod.so\", \"Assets/Plugins/FMOD/lib/linux/x86/libphonon_fmod.so\");\n                    moves.Add(\"Assets/Plugins/FMOD/platforms/linux/lib/x86_64/libphonon_fmod.so\", \"Assets/Plugins/FMOD/lib/linux/x86_64/libphonon_fmod.so\");\n                    moves.Add(\"Assets/Plugins/FMOD/platforms/mac/lib/phonon_fmod.bundle\", \"Assets/Plugins/FMOD/lib/mac/phonon_fmod.bundle\");\n                    moves.Add(\"Assets/Plugins/FMOD/platforms/android/lib/armeabi-v7a/libphonon_fmod.so\", \"Assets/Plugins/FMOD/lib/android/armeabi-v7a/libphonon_fmod.so\");\n                    moves.Add(\"Assets/Plugins/FMOD/platforms/android/lib/arm64-v8a/libphonon_fmod.so\", \"Assets/Plugins/FMOD/lib/android/arm64-v8a/libphonon_fmod.so\");\n                    moves.Add(\"Assets/Plugins/FMOD/platforms/android/lib/x86/libphonon_fmod.so\", \"Assets/Plugins/FMOD/lib/android/x86/libphonon_fmod.so\");\n\n                    moveSucceeded = MoveAssets(moves);\n                }\n            }\n            else\n            {\n                EditorUtility.DisplayDialog(\"Steam Audio\","
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "/libphonon_fmod.so\");\n\n                    moveSucceeded = MoveAssets(moves);\n                }\n            }\n            else\n            {\n                EditorUtility.DisplayDialog(\"Steam Audio\",\n                    \"Unable to find Steam Audio FMOD Studio plugin files. Try reinstalling the Steam Audio Unity \" +\n                    \"integration.\",\n                    \"OK\");\n                return;\n            }\n\n            if (!moveRequired)\n            {\n                EditorUtility.DisplayDialog(\"Steam Audio\",\n                    \"Steam Audio FMOD Studio plugin files are already in the correct place.\",\n                    \"OK\");\n            }\n            else if (!moveSucceeded)\n            {\n                EditorUtility.DisplayDialog(\"Steam Audio\",\n                    \"Failed to copy Steam Audio FMOD Studio plugin files to the correct place. See the console for \" +\n                    \"details.\",\n                    \"OK\");\n            }\n            else\n            {\n                EditorUtility.DisplayDialog(\"Steam Audio\",\n                    \"Steam Audio FMOD Studio plugin files moved to the correct place.\",\n                    \"OK\");\n            }\n        }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "EditorUtility.DisplayDialog(\"Steam Audio\",\n                    \"Steam Audio FMOD Studio plugin files moved to the correct place.\",\n                    \"OK\");\n            }\n        }\n\n        [MenuItem(\"Steam Audio/Install FMOD Studio Plugin Files\", true)]\n        public static bool ValidateInstallFMODStudioPluginFiles()\n        {\n            return (SteamAudioSettings.Singleton.audioEngine == AudioEngineType.FMODStudio);\n        }\n\n        private static bool AssetExists(string assetPath)\n        {\n            return !string.IsNullOrEmpty(AssetDatabase.AssetPathToGUID(assetPath)) &&\n                (File.Exists(Environment.CurrentDirectory + \"/\" + assetPath) || Directory.Exists(Environment.CurrentDirectory + \"/\" + assetPath));\n        }\n\n        private static bool EnsureAssetDirectoryExists(string directory)\n        {\n            if (AssetDatabase.IsValidFolder(directory))\n                return true;\n\n            var parent = Path.GetDirectoryName(directory);\n            var baseName = Path.GetFileName(directory);\n\n            if (!EnsureAssetDirectoryExists(parent))\n                return false;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "var parent = Path.GetDirectoryName(directory);\n            var baseName = Path.GetFileName(directory);\n\n            if (!EnsureAssetDirectoryExists(parent))\n                return false;\n\n            var result = AssetDatabase.CreateFolder(parent, baseName);\n            if (string.IsNullOrEmpty(result))\n            {\n                Debug.LogErrorFormat(\"Unable to create asset directory {0} in {1}: {2}\", baseName, parent, result);\n                return false;\n            }\n\n            return true;\n        }\n\n        private static bool MoveAssets(Dictionary<string, string> moves)\n        {\n            foreach (var source in moves.Keys)\n            {\n                if (!AssetExists(source))\n                {\n                    Debug.LogErrorFormat(\"Unable to find plugin file: {0}\", source);\n                    return false;\n                }\n\n                var destination = moves[source];\n                var directory = Path.GetDirectoryName(destination);\n\n                if (!EnsureAssetDirectoryExists(directory))\n                {\n                    Debug.LogErrorFormat(\"Unable to create directory: {0}\", directory);\n                    return false;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "if (!EnsureAssetDirectoryExists(directory))\n                {\n                    Debug.LogErrorFormat(\"Unable to create directory: {0}\", directory);\n                    return false;\n                }\n\n                var result = AssetDatabase.MoveAsset(source, destination);\n\n                if (!string.IsNullOrEmpty(result))\n                {\n                    Debug.LogErrorFormat(\"Unable to move {0} to {1}: {2}\", source, destination, result);\n                    return false;\n                }\n\n                Debug.LogFormat(\"Moved {0} to {1}.\", source, destination);\n            }\n\n            return true;\n        }\n#endif\n\n        // Exports a dynamic object.\n        public static void ExportDynamicObject(SteamAudioDynamicObject dynamicObject, bool exportOBJ)\n        {\n            var objects = GetDynamicGameObjectsForExport(dynamicObject);\n\n            if (objects == null || objects.Length == 0)\n            {\n                Debug.LogError(string.Format(\"Dynamic object {0} has no Steam Audio geometry attached. Skipping export.\", dynamicObject.name));\n                return;\n            }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "0)\n            {\n                Debug.LogError(string.Format(\"Dynamic object {0} has no Steam Audio geometry attached. Skipping export.\", dynamicObject.name));\n                return;\n            }\n\n            var dataAsset = (!exportOBJ) ? GetDataAsset(dynamicObject) : null;\n            var objFileName = (exportOBJ) ? GetOBJFileName(dynamicObject) : \"\";\n\n            if (!exportOBJ && dataAsset == null)\n                return;\n\n            if (exportOBJ && (objFileName == null || objFileName.Length == 0))\n                return;\n\n            Export(objects, dynamicObject.name, dataAsset, objFileName, true, exportOBJ);\n        }\n\n        // Exports all dynamic objects in an array.\n        static void ExportDynamicObjectsInArray(SteamAudioDynamicObject[] dynamicObjects)\n        {\n            foreach (var dynamicObject in dynamicObjects)\n            {\n                ExportDynamicObject(dynamicObject, false);\n            }\n        }\n\n        // Finds all dynamic objects in a scene.\n        static SteamAudioDynamicObject[] GetDynamicObjectsInScene(UnityEngine.SceneManagement.Scene scene)\n        {\n            var dynamicObjects = new List<SteamAudioDynamicObject>();"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "in a scene.\n        static SteamAudioDynamicObject[] GetDynamicObjectsInScene(UnityEngine.SceneManagement.Scene scene)\n        {\n            var dynamicObjects = new List<SteamAudioDynamicObject>();\n\n            var rootObjects = scene.GetRootGameObjects();\n            foreach (var rootObject in rootObjects)\n            {\n                dynamicObjects.AddRange(rootObject.GetComponentsInChildren<SteamAudioDynamicObject>());\n            }\n\n            return dynamicObjects.ToArray();\n        }\n\n        // Loads a static scene.\n        public static void LoadScene(UnityEngine.SceneManagement.Scene unityScene, Context context, bool additive)\n        {\n            if (!additive)\n            {\n                sSingleton.mCurrentScene = CreateScene(context);\n            }\n        }\n\n        // Loads a dynamic object as an instanced mesh. Multiple dynamic objects loaded from the same file\n        // will share the underlying geometry and material data (using a reference count). The instanced meshes\n        // allow each dynamic object to have its own transform.\n        public static InstancedMesh LoadDynamicObject(SteamAudioDynamicObject dynamicObject, Scene parentScene, Context context)"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "meshes\n        // allow each dynamic object to have its own transform.\n        public static InstancedMesh LoadDynamicObject(SteamAudioDynamicObject dynamicObject, Scene parentScene, Context context)\n        {\n            InstancedMesh instancedMesh = null;\n\n            var dataAsset = dynamicObject.asset;\n            var assetName = dataAsset.name;\n            if (dataAsset != null)\n            {\n                Scene subScene = null;\n                if (sSingleton.mDynamicObjects.ContainsKey(assetName))\n                {\n                    subScene = sSingleton.mDynamicObjects[assetName];\n                    sSingleton.mDynamicObjectRefCounts[assetName]++;\n                }\n                else\n                {\n                    subScene = CreateScene(context);\n                    var subStaticMesh = Load(dataAsset, context, subScene);\n                    subStaticMesh.AddToScene(subScene);\n                    subStaticMesh.Release();\n\n                    sSingleton.mDynamicObjects.Add(assetName, subScene);\n                    sSingleton.mDynamicObjectRefCounts.Add(assetName, 1);\n                }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "subStaticMesh.Release();\n\n                    sSingleton.mDynamicObjects.Add(assetName, subScene);\n                    sSingleton.mDynamicObjectRefCounts.Add(assetName, 1);\n                }\n\n                instancedMesh = new InstancedMesh(parentScene, subScene, dynamicObject.transform);\n            }\n\n            return instancedMesh;\n        }\n\n        // Unloads a dynamic object and decrements the reference count of the underlying data. However,\n        // when the reference count hits zero, we don't get rid of the data, because the dynamic object may\n        // be instantiated again within a few frames, and we don't want to waste time re-loading it. The data\n        // will eventually be unloaded at the next scene change.\n        public static void UnloadDynamicObject(SteamAudioDynamicObject dynamicObject)\n        {\n            var assetName = (dynamicObject.asset) ? dynamicObject.asset.name : \"\";\n\n            if (sSingleton.mDynamicObjectRefCounts.ContainsKey(assetName))\n            {\n                sSingleton.mDynamicObjectRefCounts[assetName]--;\n            }\n        }\n\n        // Gather a list of all GameObjects to export, starting from a given root object."
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "ame))\n            {\n                sSingleton.mDynamicObjectRefCounts[assetName]--;\n            }\n        }\n\n        // Gather a list of all GameObjects to export, starting from a given root object.\n        public static List<GameObject> GetGameObjectsForExport(GameObject root, bool exportingStaticObjects = false)\n        {\n            var gameObjects = new List<GameObject>();\n\n            if (exportingStaticObjects && root.GetComponentInParent<SteamAudioDynamicObject>() != null)\n                return new List<GameObject>();\n\n            var geometries = root.GetComponentsInChildren<SteamAudioGeometry>();\n            foreach (var geometry in geometries)\n            {\n                if (IsDynamicSubObject(root, geometry.gameObject))\n                    continue;\n\n                if (geometry.exportAllChildren)\n                {\n                    var meshes = geometry.GetComponentsInChildren<MeshFilter>();\n                    foreach (var mesh in meshes)\n                    {\n                        if (!IsDynamicSubObject(root, mesh.gameObject))\n                        {\n                            if (IsActiveInHierarchy(mesh.gameObject.transform))"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "{\n                        if (!IsDynamicSubObject(root, mesh.gameObject))\n                        {\n                            if (IsActiveInHierarchy(mesh.gameObject.transform))\n                            {\n                                gameObjects.Add(mesh.gameObject);\n                            }\n                        }\n                    }\n\n                    var terrains = geometry.GetComponentsInChildren<Terrain>();\n                    foreach (var terrain in terrains)\n                    {\n                        if (!IsDynamicSubObject(root, terrain.gameObject))\n                        {\n                            if (IsActiveInHierarchy(terrain.gameObject.transform))\n                            {\n                                gameObjects.Add(terrain.gameObject);\n                            }\n                        }\n                    }\n                }\n                else\n                {\n                    if (IsActiveInHierarchy(geometry.gameObject.transform))\n                    {\n                        if (geometry.gameObject.GetComponent<MeshFilter>() != null ||"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "{\n                    if (IsActiveInHierarchy(geometry.gameObject.transform))\n                    {\n                        if (geometry.gameObject.GetComponent<MeshFilter>() != null ||\n                            geometry.gameObject.GetComponent<Terrain>() != null)\n                        {\n                            gameObjects.Add(geometry.gameObject);\n                        }\n                    }\n                }\n            }\n\n            var uniqueGameObjects = new HashSet<GameObject>(gameObjects);\n\n            gameObjects.Clear();\n            foreach (var uniqueGameObject in uniqueGameObjects)\n            {\n                gameObjects.Add(uniqueGameObject);\n            }\n\n            return gameObjects;\n        }\n\n        // Returns the number of vertices associated with a GameObject.\n        public static int GetNumVertices(GameObject gameObject)\n        {\n            var mesh = gameObject.GetComponent<MeshFilter>();\n            var terrain = gameObject.GetComponent<Terrain>();\n\n            if (mesh != null && mesh.sharedMesh != null)\n            {\n                return mesh.sharedMesh.vertexCount;\n            }\n            else if (terrain != null)"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "etComponent<Terrain>();\n\n            if (mesh != null && mesh.sharedMesh != null)\n            {\n                return mesh.sharedMesh.vertexCount;\n            }\n            else if (terrain != null)\n            {\n                var terrainSimplificationLevel = GetTerrainSimplificationLevel(terrain);\n\n                var w = terrain.terrainData.heightmapResolution;\n                var h = terrain.terrainData.heightmapResolution;\n                var s = Mathf.Min(w - 1, Mathf.Min(h - 1, (int)Mathf.Pow(2.0f, terrainSimplificationLevel)));\n\n                if (s == 0)\n                {\n                    s = 1;\n                }\n\n                w = ((w - 1) / s) + 1;\n                h = ((h - 1) / s) + 1;\n\n                return (w * h);\n            }\n            else\n            {\n                return 0;\n            }\n        }\n\n        // Returns the number of triangles associated with a GameObject.\n        public static int GetNumTriangles(GameObject gameObject)\n        {\n            var mesh = gameObject.GetComponent<MeshFilter>();\n            var terrain = gameObject.GetComponent<Terrain>();\n\n            if (mesh != null && mesh.sharedMesh != null)\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "{\n            var mesh = gameObject.GetComponent<MeshFilter>();\n            var terrain = gameObject.GetComponent<Terrain>();\n\n            if (mesh != null && mesh.sharedMesh != null)\n            {\n                return mesh.sharedMesh.triangles.Length / 3;\n            }\n            else if (terrain != null)\n            {\n                var terrainSimplificationLevel = GetTerrainSimplificationLevel(terrain);\n\n                var w = terrain.terrainData.heightmapResolution;\n                var h = terrain.terrainData.heightmapResolution;\n                var s = Mathf.Min(w - 1, Mathf.Min(h - 1, (int)Mathf.Pow(2.0f, terrainSimplificationLevel)));\n\n                if (s == 0)\n                {\n                    s = 1;\n                }\n\n                w = ((w - 1) / s) + 1;\n                h = ((h - 1) / s) + 1;\n\n                return ((w - 1) * (h - 1) * 2);\n            }\n            else\n            {\n                return 0;\n            }\n        }\n\n        [MonoPInvokeCallback(typeof(ClosestHitCallback))]\n        public static void ClosestHit(ref Ray ray, float minDistance, float maxDistance, out Hit hit, IntPtr userData)\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "}\n        }\n\n        [MonoPInvokeCallback(typeof(ClosestHitCallback))]\n        public static void ClosestHit(ref Ray ray, float minDistance, float maxDistance, out Hit hit, IntPtr userData)\n        {\n            var origin = Common.ConvertVector(ray.origin);\n            var direction = Common.ConvertVector(ray.direction);\n\n            origin += minDistance * direction;\n\n            var layerMask = SteamAudioSettings.Singleton.layerMask;\n\n            hit.objectIndex = 0;\n            hit.triangleIndex = 0;\n            hit.materialIndex = 0;\n\n            var numHits = Physics.RaycastNonAlloc(origin, direction, sSingleton.mRayHits, maxDistance, layerMask);\n            if (numHits > 0)\n            {\n                hit.distance = sSingleton.mRayHits[0].distance;\n                hit.normal = Common.ConvertVector(sSingleton.mRayHits[0].normal);\n                hit.material = GetMaterialBufferForTransform(sSingleton.mRayHits[0].collider.transform);\n            }\n            else\n            {\n                hit.distance = Mathf.Infinity;\n                hit.normal = new Vector3 { x = 0.0f, y = 0.0f, z = 0.0f };\n                hit.material = IntPtr.Zero;\n            }\n        }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "{\n                hit.distance = Mathf.Infinity;\n                hit.normal = new Vector3 { x = 0.0f, y = 0.0f, z = 0.0f };\n                hit.material = IntPtr.Zero;\n            }\n        }\n\n        [MonoPInvokeCallback(typeof(AnyHitCallback))]\n        public static void AnyHit(ref Ray ray, float minDistance, float maxDistance, out byte occluded, IntPtr userData)\n        {\n            var origin = Common.ConvertVector(ray.origin);\n            var direction = Common.ConvertVector(ray.direction);\n\n            origin += minDistance * direction;\n\n            var layerMask = SteamAudioSettings.Singleton.layerMask;\n\n            var numHits = Physics.RaycastNonAlloc(origin, direction, sSingleton.mRayHits, maxDistance, layerMask);\n\n            occluded = (byte)((numHits > 0) ? 1 : 0);\n        }\n\n        // This method is called as soon as scripts are loaded, which happens whenever play mode is started\n        // (in the editor), or whenever the game is launched. We then create a Steam Audio Manager object\n        // and move it to the Don't Destroy On Load list.\n        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]\n        static void AutoInitialize()"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "Audio Manager object\n        // and move it to the Don't Destroy On Load list.\n        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]\n        static void AutoInitialize()\n        {\n            Initialize(ManagerInitReason.Playing);\n        }\n\n        // Exports the static geometry in a scene.\n        public static void ExportScene(UnityEngine.SceneManagement.Scene unityScene, bool exportOBJ)\n        {\n            var objects = GetStaticGameObjectsForExport(unityScene);\n\n            if (objects == null || objects.Length == 0)\n            {\n                Debug.LogWarning(string.Format(\"Scene {0} has no Steam Audio static geometry. Skipping export.\", unityScene.name));\n                return;\n            }\n\n            var dataAsset = (!exportOBJ) ? GetDataAsset(unityScene) : null;\n            var objFileName = (exportOBJ) ? GetOBJFileName(unityScene) : \"\";\n\n            if (!exportOBJ && dataAsset == null)\n                return;\n\n            if (exportOBJ && (objFileName == null || objFileName.Length == 0))\n                return;\n\n            Export(objects, unityScene.name, dataAsset, objFileName, false, exportOBJ);\n        }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "if (exportOBJ && (objFileName == null || objFileName.Length == 0))\n                return;\n\n            Export(objects, unityScene.name, dataAsset, objFileName, false, exportOBJ);\n        }\n\n        // Exports a set of GameObjects.\n        static void Export(GameObject[] objects, string name, SerializedData dataAsset, string objFileName, bool dynamic, bool exportOBJ)\n        {\n            var type = (dynamic) ? \"Dynamic Object\" : \"Scene\";\n\n            Vector3[] vertices = null;\n            Triangle[] triangles = null;\n            int[] materialIndices = null;\n            Material[] materials = null;\n            GetGeometryAndMaterialBuffers(objects, ref vertices, ref triangles, ref materialIndices, ref materials, dynamic, exportOBJ);\n\n            if (vertices.Length == 0 || triangles.Length == 0 || materialIndices.Length == 0 || materials.Length == 0)\n            {\n                Debug.LogError(string.Format(\"Steam Audio {0} [{1}]: No Steam Audio Geometry components attached.\", type, name));\n                return;\n            }\n\n            var context = new Context();\n\n            // Scene type should always be Phonon when exporting."
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "Audio Geometry components attached.\", type, name));\n                return;\n            }\n\n            var context = new Context();\n\n            // Scene type should always be Phonon when exporting.\n            var scene = new Scene(context, SceneType.Default, null, null, null, null);\n\n            var staticMesh = new StaticMesh(context, scene, vertices, triangles, materialIndices, materials);\n            staticMesh.AddToScene(scene);\n\n            if (exportOBJ)\n            {\n                scene.Commit();\n                scene.SaveOBJ(objFileName);\n            }\n            else\n            {\n                staticMesh.Save(dataAsset);\n            }\n\n            Debug.Log(string.Format(\"Steam Audio {0} [{1}]: Exported to {2}.\", type, name, (exportOBJ) ? objFileName : dataAsset.name));\n\n            staticMesh.Release();\n            scene.Release();\n        }\n\n        static Scene CreateScene(Context context)\n        {\n            var sceneType = GetSceneType();\n\n            var scene = new Scene(context, sceneType, sSingleton.mEmbreeDevice, sSingleton.mRadeonRaysDevice,\n                ClosestHit, AnyHit);\n\n            if (sceneType == SceneType.Custom)\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "var scene = new Scene(context, sceneType, sSingleton.mEmbreeDevice, sSingleton.mRadeonRaysDevice,\n                ClosestHit, AnyHit);\n\n            if (sceneType == SceneType.Custom)\n            {\n                if (sSingleton.mMaterialBuffer == IntPtr.Zero)\n                {\n                    sSingleton.mMaterialBuffer = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(Material)));\n                }\n            }\n\n            return scene;\n        }\n\n        // Loads a Steam Audio scene.\n        static StaticMesh Load(SerializedData dataAsset, Context context, Scene scene)\n        {\n            return new StaticMesh(context, scene, dataAsset);\n        }\n\n        // Unloads the underlying data for dynamic objects. Can either remove only unreferenced data (for use when\n        // changing scenes) or all data (for use when shutting down).\n        static void RemoveAllDynamicObjects(bool force = false)\n        {\n            var unreferencedDynamicObjects = new List<string>();\n\n            foreach (var scene in sSingleton.mDynamicObjectRefCounts.Keys)\n            {\n                if (force || sSingleton.mDynamicObjectRefCounts[scene] == 0)\n                {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "ist<string>();\n\n            foreach (var scene in sSingleton.mDynamicObjectRefCounts.Keys)\n            {\n                if (force || sSingleton.mDynamicObjectRefCounts[scene] == 0)\n                {\n                    unreferencedDynamicObjects.Add(scene);\n                }\n            }\n\n            foreach (var scene in unreferencedDynamicObjects)\n            {\n                sSingleton.mDynamicObjects[scene].Release();\n                sSingleton.mDynamicObjects.Remove(scene);\n                sSingleton.mDynamicObjectRefCounts.Remove(scene);\n            }\n        }\n\n        // Unloads all currently-loaded scenes.\n        static void RemoveAllAdditiveScenes()\n        {\n            Marshal.FreeHGlobal(sSingleton.mMaterialBuffer);\n\n            if (sSingleton.mCurrentScene != null)\n            {\n                sSingleton.mCurrentScene.Release();\n                sSingleton.mCurrentScene = null;\n            }\n        }\n\n        static IntPtr GetMaterialBufferForTransform(Transform obj)\n        {\n            var material = new Material();\n            var found = false;\n\n            var currentObject = obj;\n            while (currentObject != null)\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "nsform(Transform obj)\n        {\n            var material = new Material();\n            var found = false;\n\n            var currentObject = obj;\n            while (currentObject != null)\n            {\n                var steamAudioGeometry = currentObject.GetComponent<SteamAudioGeometry>();\n                if (steamAudioGeometry != null && steamAudioGeometry.material != null)\n                {\n                    material = steamAudioGeometry.material.GetMaterial();\n                    found = true;\n                    break;\n                }\n                currentObject = currentObject.parent;\n            }\n\n            if (!found)\n            {\n                material = SteamAudioSettings.Singleton.defaultMaterial.GetMaterial();\n            }\n\n            Marshal.StructureToPtr(material, sSingleton.mMaterialBuffer, true);\n\n            return sSingleton.mMaterialBuffer;\n        }\n\n        // Gather a list of all GameObjects to export in a scene, excluding dynamic objects.\n        static GameObject[] GetStaticGameObjectsForExport(UnityEngine.SceneManagement.Scene scene)\n        {\n            var gameObjects = new List<GameObject>();"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "a scene, excluding dynamic objects.\n        static GameObject[] GetStaticGameObjectsForExport(UnityEngine.SceneManagement.Scene scene)\n        {\n            var gameObjects = new List<GameObject>();\n\n            var roots = scene.GetRootGameObjects();\n            foreach (var root in roots)\n            {\n                gameObjects.AddRange(GetGameObjectsForExport(root, true));\n            }\n\n            return gameObjects.ToArray();\n        }\n\n        // Gather a list of all GameObjects to export for a given dynamic object.\n        static GameObject[] GetDynamicGameObjectsForExport(SteamAudioDynamicObject dynamicObject)\n        {\n            return GetGameObjectsForExport(dynamicObject.gameObject).ToArray();\n        }\n\n        static bool IsDynamicSubObject(GameObject root, GameObject obj)\n        {\n            return (root.GetComponentInParent<SteamAudioDynamicObject>() !=\n                obj.GetComponentInParent<SteamAudioDynamicObject>());\n        }\n\n        // Ideally, we want to use GameObject.activeInHierarchy to check if a GameObject is active. However, when\n        // we batch-export dynamic objects, Prefabs are instantiated using AssetDatabase.LoadMainAssetAtPath,"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "ant to use GameObject.activeInHierarchy to check if a GameObject is active. However, when\n        // we batch-export dynamic objects, Prefabs are instantiated using AssetDatabase.LoadMainAssetAtPath,\n        // and isActiveInHierarchy returns false even if all GameObjects in the Prefab return true for\n        // GameObject.activeSelf. Therefore, we manually walk up the hierarchy and check if the GameObject is active.\n        static bool IsActiveInHierarchy(Transform obj)\n        {\n            if (obj == null)\n                return true;\n\n            return (obj.gameObject.activeSelf && IsActiveInHierarchy(obj.parent));\n        }\n\n        // Given an array of GameObjects, export the vertex, triangle, material index, and material data.\n        static void GetGeometryAndMaterialBuffers(GameObject[] gameObjects, ref Vector3[] vertices, ref Triangle[] triangles, ref int[] materialIndices, ref Material[] materials, bool isDynamic, bool exportOBJ)\n        {\n            var numVertices = new int[gameObjects.Length];\n            var numTriangles = new int[gameObjects.Length];\n            var totalNumVertices = 0;\n            var totalNumTriangles = 0;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "{\n            var numVertices = new int[gameObjects.Length];\n            var numTriangles = new int[gameObjects.Length];\n            var totalNumVertices = 0;\n            var totalNumTriangles = 0;\n            for (var i = 0; i < gameObjects.Length; ++i)\n            {\n                numVertices[i] = GetNumVertices(gameObjects[i]);\n                numTriangles[i] = GetNumTriangles(gameObjects[i]);\n                totalNumVertices += numVertices[i];\n                totalNumTriangles += numTriangles[i];\n            }\n\n            int[] materialIndicesPerObject = null;\n            GetMaterialMapping(gameObjects, ref materials, ref materialIndicesPerObject);\n\n            vertices = new Vector3[totalNumVertices];\n            triangles = new Triangle[totalNumTriangles];\n            materialIndices = new int[totalNumTriangles];\n\n            // If we're exporting a dynamic object, apply the relevant transform. However, if we're exporting\n            // to an OBJ file, _don't_ apply the transform, so the dynamic object appears centered at its local\n            // origin.\n            Transform transform = null;\n            if (isDynamic && !exportOBJ)\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "_don't_ apply the transform, so the dynamic object appears centered at its local\n            // origin.\n            Transform transform = null;\n            if (isDynamic && !exportOBJ)\n            {\n                var dynamicObject = gameObjects[0].GetComponent<SteamAudioDynamicObject>();\n                if (dynamicObject == null)\n                {\n                    dynamicObject = GetDynamicObjectInParent(gameObjects[0].transform);\n                }\n                transform = dynamicObject.transform;\n            }\n\n            var verticesOffset = 0;\n            var trianglesOffset = 0;\n            for (var i = 0; i < gameObjects.Length; ++i)\n            {\n                GetVertices(gameObjects[i], vertices, verticesOffset, transform);\n                GetTriangles(gameObjects[i], triangles, trianglesOffset);\n                FixupTriangleIndices(triangles, trianglesOffset, trianglesOffset + numTriangles[i], verticesOffset);\n\n                for (var j = 0; j < numTriangles[i]; ++j)\n                {\n                    materialIndices[trianglesOffset + j] = materialIndicesPerObject[i];\n                }\n\n                verticesOffset += numVertices[i];"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "< numTriangles[i]; ++j)\n                {\n                    materialIndices[trianglesOffset + j] = materialIndicesPerObject[i];\n                }\n\n                verticesOffset += numVertices[i];\n                trianglesOffset += numTriangles[i];\n            }\n        }\n\n        // Ideally, we want to use GameObject.GetComponentInParent<>() to find the SteamAudioDynamicObject attached to\n        // an ancestor of this GameObject. However, GetComponentInParent only returns \"active\" components, which in\n        // turn seem to be subject to the same behavior as activeInHierarchy (see above), so we have to manually walk\n        // the hierarchy upwards to find the first SteamAudioDynamicObject.\n        static SteamAudioDynamicObject GetDynamicObjectInParent(Transform obj)\n        {\n            if (obj == null)\n                return null;\n\n            var dynamicObject = obj.gameObject.GetComponent<SteamAudioDynamicObject>();\n            if (dynamicObject != null)\n                return dynamicObject;\n\n            return GetDynamicObjectInParent(obj.parent);\n        }\n\n        // Populates an array with the vertices associated with a GameObject, starting at a given offset."
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "return dynamicObject;\n\n            return GetDynamicObjectInParent(obj.parent);\n        }\n\n        // Populates an array with the vertices associated with a GameObject, starting at a given offset.\n        static void GetVertices(GameObject gameObject, Vector3[] vertices, int offset, Transform transform)\n        {\n            var mesh = gameObject.GetComponent<MeshFilter>();\n            var terrain = gameObject.GetComponent<Terrain>();\n\n            if (mesh != null && mesh.sharedMesh != null)\n            {\n                var vertexArray = mesh.sharedMesh.vertices;\n                for (var i = 0; i < vertexArray.Length; ++i)\n                {\n                    var transformedVertex = mesh.transform.TransformPoint(vertexArray[i]);\n                    if (transform != null)\n                    {\n                        transformedVertex = transform.InverseTransformPoint(transformedVertex);\n                    }\n                    vertices[offset + i] = Common.ConvertVector(transformedVertex);\n                }\n            }\n            else if (terrain != null)\n            {\n                var terrainSimplificationLevel = GetTerrainSimplificationLevel(terrain);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "ector(transformedVertex);\n                }\n            }\n            else if (terrain != null)\n            {\n                var terrainSimplificationLevel = GetTerrainSimplificationLevel(terrain);\n\n                var w = terrain.terrainData.heightmapResolution;\n                var h = terrain.terrainData.heightmapResolution;\n                var s = Mathf.Min(w - 1, Mathf.Min(h - 1, (int)Mathf.Pow(2.0f, terrainSimplificationLevel)));\n                if (s == 0)\n                {\n                    s = 1;\n                }\n\n                w = ((w - 1) / s) + 1;\n                h = ((h - 1) / s) + 1;\n\n                var heights = terrain.terrainData.GetHeights(0, 0, terrain.terrainData.heightmapResolution,\n                    terrain.terrainData.heightmapResolution);\n\n                var index = 0;\n                for (var v = 0; v < terrain.terrainData.heightmapResolution; v += s)\n                {\n                    for (var u = 0; u < terrain.terrainData.heightmapResolution; u += s)\n                    {\n                        var height = heights[v, u];\n\n                        var x = ((float) u / terrain.terrainData.heightmapResolution) * terrain.terrainData.size.x;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "u += s)\n                    {\n                        var height = heights[v, u];\n\n                        var x = ((float) u / terrain.terrainData.heightmapResolution) * terrain.terrainData.size.x;\n                        var y = height * terrain.terrainData.size.y;\n                        var z = ((float) v / terrain.terrainData.heightmapResolution) * terrain.terrainData.size.z;\n\n                        var vertex = new UnityEngine.Vector3 { x = x, y = y, z = z };\n                        var transformedVertex = terrain.transform.TransformPoint(vertex);\n                        if (transform != null)\n                        {\n                            transformedVertex = transform.InverseTransformPoint(transformedVertex);\n                        }\n                        vertices[offset + index] = Common.ConvertVector(transformedVertex);\n                        ++index;\n                    }\n                }\n            }\n        }\n\n        // Populates an array with the triangles associated with a GameObject, starting at a given offset.\n        static void GetTriangles(GameObject gameObject, Triangle[] triangles, int offset)\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "// Populates an array with the triangles associated with a GameObject, starting at a given offset.\n        static void GetTriangles(GameObject gameObject, Triangle[] triangles, int offset)\n        {\n            var mesh = gameObject.GetComponent<MeshFilter>();\n            var terrain = gameObject.GetComponent<Terrain>();\n\n            if (mesh != null && mesh.sharedMesh != null)\n            {\n                var triangleArray = mesh.sharedMesh.triangles;\n                for (var i = 0; i < triangleArray.Length / 3; ++i)\n                {\n                    triangles[offset + i].index0 = triangleArray[3 * i + 0];\n                    triangles[offset + i].index1 = triangleArray[3 * i + 1];\n                    triangles[offset + i].index2 = triangleArray[3 * i + 2];\n                }\n            }\n            else if (terrain != null)\n            {\n                var terrainSimplificationLevel = GetTerrainSimplificationLevel(terrain);\n\n                var w = terrain.terrainData.heightmapResolution;\n                var h = terrain.terrainData.heightmapResolution;\n                var s = Mathf.Min(w - 1, Mathf.Min(h - 1, (int)Mathf.Pow(2.0f, terrainSimplificationLevel)));"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "ata.heightmapResolution;\n                var h = terrain.terrainData.heightmapResolution;\n                var s = Mathf.Min(w - 1, Mathf.Min(h - 1, (int)Mathf.Pow(2.0f, terrainSimplificationLevel)));\n                if (s == 0)\n                {\n                    s = 1;\n                }\n\n                w = ((w - 1) / s) + 1;\n                h = ((h - 1) / s) + 1;\n\n                var index = 0;\n                for (var v = 0; v < h - 1; ++v)\n                {\n                    for (var u = 0; u < w - 1; ++u)\n                    {\n                        var i0 = v * w + u;\n                        var i1 = (v + 1) * w + u;\n                        var i2 = v * w + (u + 1);\n                        triangles[offset + index] = new Triangle\n                        {\n                            index0 = i0,\n                            index1 = i1,\n                            index2 = i2\n                        };\n\n                        i0 = v * w + (u + 1);\n                        i1 = (v + 1) * w + u;\n                        i2 = (v + 1) * w + (u + 1);\n                        triangles[offset + index + 1] = new Triangle\n                        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "+ 1);\n                        i1 = (v + 1) * w + u;\n                        i2 = (v + 1) * w + (u + 1);\n                        triangles[offset + index + 1] = new Triangle\n                        {\n                            index0 = i0,\n                            index1 = i1,\n                            index2 = i2\n                        };\n\n                        index += 2;\n                    }\n                }\n            }\n        }\n\n        // When multiple meshes are combined to form a single piece of geometry, each mesh will have\n        // 0-based triangle indices, even though the combined mesh will have a single vertex buffer. This\n        // function applies appropriate offsets to triangle indices so make all vertex indices correct.\n        static void FixupTriangleIndices(Triangle[] triangles, int startIndex, int endIndex, int indexOffset)\n        {\n            for (var i = startIndex; i < endIndex; ++i)\n            {\n                triangles[i].index0 += indexOffset;\n                triangles[i].index1 += indexOffset;\n                triangles[i].index2 += indexOffset;\n            }\n        }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "++i)\n            {\n                triangles[i].index0 += indexOffset;\n                triangles[i].index1 += indexOffset;\n                triangles[i].index2 += indexOffset;\n            }\n        }\n\n        static float GetTerrainSimplificationLevel(Terrain terrain)\n        {\n            return terrain.GetComponentInParent<SteamAudioGeometry>().terrainSimplificationLevel;\n        }\n\n        // Given an array of GameObjects, returns: a) an array containing all the unique materials referenced by\n        // them, and b) an array indicating for each GameObject, which material it references.\n        static void GetMaterialMapping(GameObject[] gameObjects, ref Material[] materials, ref int[] materialIndices)\n        {\n            var materialMapping = new Dictionary<Material, List<int>>();\n\n            // Loop through all the given GameObjects, and generate a dictionary mapping each material\n            // to a list of GameObjects that reference it.\n            for (var i = 0; i < gameObjects.Length; ++i)\n            {\n                var material = GetMaterialForGameObject(gameObjects[i]);\n                if (!materialMapping.ContainsKey(material))\n                {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "= 0; i < gameObjects.Length; ++i)\n            {\n                var material = GetMaterialForGameObject(gameObjects[i]);\n                if (!materialMapping.ContainsKey(material))\n                {\n                    materialMapping.Add(material, new List<int>());\n                }\n                materialMapping[material].Add(i);\n            }\n\n            materials = new Material[materialMapping.Keys.Count];\n            materialIndices = new int[gameObjects.Length];\n\n            // Extract an array of unique materials and an array mapping GameObjects to materials.\n            var index = 0;\n            foreach (var material in materialMapping.Keys)\n            {\n                materials[index] = material;\n                foreach (var gameObjectIndex in materialMapping[material])\n                {\n                    materialIndices[gameObjectIndex] = index;\n                }\n                ++index;\n            }\n        }\n\n        // Returns the Steam Audio material associated with a given GameObject.\n        static Material GetMaterialForGameObject(GameObject gameObject)\n        {\n            // Traverse the hierarchy upwards starting at this GameObject, until we find the"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "with a given GameObject.\n        static Material GetMaterialForGameObject(GameObject gameObject)\n        {\n            // Traverse the hierarchy upwards starting at this GameObject, until we find the\n            // first GameObject that has a Steam Audio Geometry component with a non-empty\n            // Material property.\n            var current = gameObject.transform;\n            while (current != null)\n            {\n                var geometry = current.gameObject.GetComponent<SteamAudioGeometry>();\n                if (geometry != null && geometry.material != null)\n                {\n                    return geometry.material.GetMaterial();\n                }\n\n                current = current.parent;\n            }\n\n            // If we didn't find any such GameObject, use the default material specified in\n            // the Steam Audio Settings.\n            var defaultMaterial = SteamAudioSettings.Singleton.defaultMaterial;\n            if (defaultMaterial != null)\n            {\n                return SteamAudioSettings.Singleton.defaultMaterial.GetMaterial();\n            }\n\n            // The default material was set to null, so create a default material and use it."
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "{\n                return SteamAudioSettings.Singleton.defaultMaterial.GetMaterial();\n            }\n\n            // The default material was set to null, so create a default material and use it.\n            Debug.LogWarning(\n                \"A default material has not been set, using built-in default. Click Steam Audio > Settings \" +\n                \"to specify a default material.\");\n            return ScriptableObject.CreateInstance<SteamAudioMaterial>().GetMaterial();\n        }\n\n        static string GetOBJFileName(UnityEngine.SceneManagement.Scene scene)\n        {\n            var fileName = \"\";\n\n#if UNITY_EDITOR\n            fileName = EditorUtility.SaveFilePanelInProject(\"Export Scene to OBJ\", scene.name, \"obj\",\n                \"Select a file to export this scene's data to.\");\n#endif\n\n            return fileName;\n        }\n\n        static string GetOBJFileName(SteamAudioDynamicObject dynamicObject)\n        {\n            var fileName = \"\";\n\n#if UNITY_EDITOR\n            fileName = EditorUtility.SaveFilePanelInProject(\"Export Dynamic Object to OBJ\", dynamicObject.name, \"obj\",\n                \"Select a file to export this dynamic object's data to.\");\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "fileName = EditorUtility.SaveFilePanelInProject(\"Export Dynamic Object to OBJ\", dynamicObject.name, \"obj\",\n                \"Select a file to export this dynamic object's data to.\");\n#endif\n\n            return fileName;\n        }\n\n        static SerializedData GetDataAsset(UnityEngine.SceneManagement.Scene scene)\n        {\n            SteamAudioStaticMesh steamAudioStaticMesh = null;\n            var rootObjects = scene.GetRootGameObjects();\n            foreach (var rootObject in rootObjects)\n            {\n                steamAudioStaticMesh = rootObject.GetComponentInChildren<SteamAudioStaticMesh>();\n                if (steamAudioStaticMesh != null)\n                    break;\n            }\n\n            if (steamAudioStaticMesh == null)\n            {\n                var activeScene = SceneManager.GetActiveScene();\n                SceneManager.SetActiveScene(scene);\n                var rootObject = new GameObject(\"Steam Audio Static Mesh\");\n                steamAudioStaticMesh = rootObject.AddComponent<SteamAudioStaticMesh>();\n#if UNITY_EDITOR\n                EditorSceneManager.MarkSceneDirty(SceneManager.GetActiveScene());\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioManager.cs",
      "Content": "sh\");\n                steamAudioStaticMesh = rootObject.AddComponent<SteamAudioStaticMesh>();\n#if UNITY_EDITOR\n                EditorSceneManager.MarkSceneDirty(SceneManager.GetActiveScene());\n#endif\n                SceneManager.SetActiveScene(activeScene);\n            }\n\n            if (steamAudioStaticMesh.asset == null)\n            {\n                steamAudioStaticMesh.asset = SerializedData.PromptForNewAsset(scene.name);\n                steamAudioStaticMesh.sceneNameWhenExported = scene.name;\n            }\n\n            return steamAudioStaticMesh.asset;\n        }\n\n        static SerializedData GetDataAsset(SteamAudioDynamicObject dynamicObject)\n        {\n            return dynamicObject.asset;\n        }\n#endif\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioMaterial.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    [CreateAssetMenu(menuName = \"Steam Audio/Steam Audio Material\")]\n    public class SteamAudioMaterial : ScriptableObject\n    {\n        [Header(\"Absorption\")]\n        [Range(0.0f, 1.0f)]\n        public float lowFreqAbsorption = 0.1f;\n        [Range(0.0f, 1.0f)]\n        public float midFreqAbsorption = 0.1f;\n        [Range(0.0f, 1.0f)]\n        public float highFreqAbsorption = 0.1f;\n        [Header(\"Scattering\")]\n        [Range(0.0f, 1.0f)]\n        public float scattering = 0.5f;\n        [Header(\"Transmission\")]\n        [Range(0.0f, 1.0f)]"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioMaterial.cs",
      "Content": "public float highFreqAbsorption = 0.1f;\n        [Header(\"Scattering\")]\n        [Range(0.0f, 1.0f)]\n        public float scattering = 0.5f;\n        [Header(\"Transmission\")]\n        [Range(0.0f, 1.0f)]\n        public float lowFreqTransmission = 0.1f;\n        [Range(0.0f, 1.0f)]\n        public float midFreqTransmission = 0.1f;\n        [Range(0.0f, 1.0f)]\n        public float highFreqTransmission = 0.1f;\n\n        public Material GetMaterial()\n        {\n            var material = new Material { };\n            material.absorptionLow = lowFreqAbsorption;\n            material.absorptionMid = midFreqAbsorption;\n            material.absorptionHigh = highFreqAbsorption;\n            material.scattering = scattering;\n            material.transmissionLow = lowFreqTransmission;\n            material.transmissionMid = midFreqTransmission;\n            material.transmissionHigh = highFreqTransmission;\n            return material;\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioProbeBatch.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing System;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.SceneManagement;\n#if UNITY_EDITOR\nusing UnityEditor;\n#endif\n\nnamespace SteamAudio\n{\n    [Serializable]\n    public struct BakedDataLayerInfo\n    {\n        public GameObject gameObject;\n        public BakedDataIdentifier identifier;\n        public int dataSize;\n    }\n\n    [AddComponentMenu(\"Steam Audio/Steam Audio Probe Batch\")]\n    public class SteamAudioProbeBatch : MonoBehaviour\n    {\n        [Header(\"Placement Settings\")]"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioProbeBatch.cs",
      "Content": "r;\n        public int dataSize;\n    }\n\n    [AddComponentMenu(\"Steam Audio/Steam Audio Probe Batch\")]\n    public class SteamAudioProbeBatch : MonoBehaviour\n    {\n        [Header(\"Placement Settings\")]\n        public ProbeGenerationType placementStrategy = ProbeGenerationType.UniformFloor;\n        [Range(.1f, 50f)]\n        public float horizontalSpacing = 5f;\n        [Range(.1f, 20f)]\n        public float heightAboveFloor = 1.5f;\n\n        [Header(\"Export Settings\")]\n        public SerializedData asset = null;\n\n        public int probeDataSize = 0;\n        [SerializeField] Sphere[] mProbeSpheres = null;\n        [SerializeField] List<BakedDataLayerInfo> mBakedDataLayerInfo = new List<BakedDataLayerInfo>();\n\n#if STEAMAUDIO_ENABLED\n        ProbeBatch mProbeBatch = null;\n\n        const float kProbeDrawSize = 0.1f;\n\n        public SerializedData GetAsset()\n        {\n            if (asset == null)\n            {\n                asset = SerializedData.PromptForNewAsset(gameObject.scene.name + \"_\" + name);\n            }\n\n            return asset;\n        }\n\n        public int GetNumProbes()\n        {\n            return (mProbeSpheres == null) ? 0 : mProbeSpheres.Length;\n        }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioProbeBatch.cs",
      "Content": "e.name + \"_\" + name);\n            }\n\n            return asset;\n        }\n\n        public int GetNumProbes()\n        {\n            return (mProbeSpheres == null) ? 0 : mProbeSpheres.Length;\n        }\n\n        public int GetNumLayers()\n        {\n            return mBakedDataLayerInfo.Count;\n        }\n\n        public IntPtr GetProbeBatch()\n        {\n            return mProbeBatch.Get();\n        }\n\n        private void Awake()\n        {\n            if (asset == null)\n                return;\n\n            mProbeBatch = new ProbeBatch(SteamAudioManager.Context, asset);\n            mProbeBatch.Commit();\n        }\n\n        private void OnDestroy()\n        {\n            if (mProbeBatch != null)\n            {\n                mProbeBatch.Release();\n            }\n        }\n\n        private void OnEnable()\n        {\n            SteamAudioManager.Simulator.AddProbeBatch(mProbeBatch);\n        }\n\n        private void OnDisable()\n        {\n            if (SteamAudioManager.Simulator != null)\n            {\n                SteamAudioManager.Simulator.RemoveProbeBatch(mProbeBatch);\n            }\n        }\n\n        void OnDrawGizmosSelected()\n        {\n            var oldColor = Gizmos.color;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioProbeBatch.cs",
      "Content": "{\n                SteamAudioManager.Simulator.RemoveProbeBatch(mProbeBatch);\n            }\n        }\n\n        void OnDrawGizmosSelected()\n        {\n            var oldColor = Gizmos.color;\n            Gizmos.color = Color.magenta;\n\n            var oldMatrix = Gizmos.matrix;\n            Gizmos.matrix = transform.localToWorldMatrix;\n            Gizmos.DrawWireCube(new UnityEngine.Vector3(0, 0, 0), new UnityEngine.Vector3(1, 1, 1));\n            Gizmos.matrix = oldMatrix;\n\n            Gizmos.color = Color.yellow;\n            if (mProbeSpheres != null)\n            {\n                for (var i = 0; i < mProbeSpheres.Length; ++i)\n                {\n                    var center = Common.ConvertVector(mProbeSpheres[i].center);\n                    Gizmos.DrawCube(center, new UnityEngine.Vector3(kProbeDrawSize, kProbeDrawSize, kProbeDrawSize));\n                }\n            }\n            Gizmos.color = oldColor;\n        }\n\n        public void GenerateProbes()\n        {\n            SteamAudioManager.Initialize(ManagerInitReason.GeneratingProbes);\n            SteamAudioManager.LoadScene(SceneManager.GetActiveScene(), SteamAudioManager.Context, false);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioProbeBatch.cs",
      "Content": "bes()\n        {\n            SteamAudioManager.Initialize(ManagerInitReason.GeneratingProbes);\n            SteamAudioManager.LoadScene(SceneManager.GetActiveScene(), SteamAudioManager.Context, false);\n            var scene = SteamAudioManager.CurrentScene;\n\n            SteamAudioStaticMesh staticMeshComponent = null;\n            var rootObjects = SceneManager.GetActiveScene().GetRootGameObjects();\n            foreach (var rootObject in rootObjects)\n            {\n                staticMeshComponent = rootObject.GetComponentInChildren<SteamAudioStaticMesh>();\n                if (staticMeshComponent)\n                    break;\n            }\n\n            if (staticMeshComponent == null || staticMeshComponent.asset == null)\n            {\n                Debug.LogError(string.Format(\"Scene {0} has not been exported. Click Steam Audio > Export Active Scene to do so.\", SceneManager.GetActiveScene().name));\n                return;\n            }\n\n            var staticMesh = new StaticMesh(SteamAudioManager.Context, scene, staticMeshComponent.asset);\n            staticMesh.AddToScene(scene);\n\n            scene.Commit();\n\n            var probeArray = new ProbeArray(SteamAudioManager.Context);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioProbeBatch.cs",
      "Content": "udioManager.Context, scene, staticMeshComponent.asset);\n            staticMesh.AddToScene(scene);\n\n            scene.Commit();\n\n            var probeArray = new ProbeArray(SteamAudioManager.Context);\n\n            var probeGenerationParams = new ProbeGenerationParams { };\n            probeGenerationParams.type = placementStrategy;\n            probeGenerationParams.spacing = horizontalSpacing;\n            probeGenerationParams.height = heightAboveFloor;\n            probeGenerationParams.transform = Common.ConvertTransform(gameObject.transform);\n\n            probeArray.GenerateProbes(scene, probeGenerationParams);\n\n            var numProbes = probeArray.GetNumProbes();\n            mProbeSpheres = new Sphere[numProbes];\n            for (var i = 0; i < numProbes; ++i)\n            {\n                mProbeSpheres[i] = probeArray.GetProbe(i);\n            }\n\n            var probeBatch = new ProbeBatch(SteamAudioManager.Context);\n            probeBatch.AddProbeArray(probeArray);\n\n            probeDataSize = probeBatch.Save(GetAsset());\n\n            probeBatch.Release();\n            probeArray.Release();\n            staticMesh.Release();\n\n            SteamAudioManager.ShutDown();"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioProbeBatch.cs",
      "Content": "probeDataSize = probeBatch.Save(GetAsset());\n\n            probeBatch.Release();\n            probeArray.Release();\n            staticMesh.Release();\n\n            SteamAudioManager.ShutDown();\n            DestroyImmediate(SteamAudioManager.Singleton.gameObject);\n\n            ResetLayers();\n\n            Debug.Log(\"Generated \" + mProbeSpheres.Length + \" probes for game object \" + gameObject.name + \".\");\n\n            // Redraw scene view for probes to show up instantly.\n#if UNITY_EDITOR\n            SceneView.RepaintAll();\n#endif\n        }\n\n        public void DeleteBakedDataForIdentifier(BakedDataIdentifier identifier)\n        {\n            if (asset == null)\n                return;\n\n            SteamAudioManager.Initialize(ManagerInitReason.EditingProbes);\n\n            var probeBatch = new ProbeBatch(SteamAudioManager.Context, asset);\n            probeBatch.RemoveData(identifier);\n            probeDataSize = probeBatch.Save(asset);\n            probeBatch.Release();\n\n            SteamAudioManager.ShutDown();\n            DestroyImmediate(SteamAudioManager.Singleton.gameObject);\n\n            RemoveLayer(identifier);\n        }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioProbeBatch.cs",
      "Content": "t);\n            probeBatch.Release();\n\n            SteamAudioManager.ShutDown();\n            DestroyImmediate(SteamAudioManager.Singleton.gameObject);\n\n            RemoveLayer(identifier);\n        }\n\n        public int GetSizeForLayer(BakedDataIdentifier identifier)\n        {\n            for (int i = 0; i < mBakedDataLayerInfo.Count; ++i)\n            {\n                if (mBakedDataLayerInfo[i].identifier.Equals(identifier))\n                {\n                    return mBakedDataLayerInfo[i].dataSize;\n                }\n\n            }\n\n            return 0;\n        }\n\n        public BakedDataLayerInfo GetInfoForLayer(int index)\n        {\n            return mBakedDataLayerInfo[index];\n        }\n\n        public void ResetLayers()\n        {\n            mBakedDataLayerInfo.Clear();\n        }\n\n        public void AddLayer(GameObject gameObject, BakedDataIdentifier identifier, int dataSize)\n        {\n            var layerInfo = new BakedDataLayerInfo { };\n            layerInfo.gameObject = gameObject;\n            layerInfo.identifier = identifier;\n            layerInfo.dataSize = dataSize;\n\n            mBakedDataLayerInfo.Add(layerInfo);\n        }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioProbeBatch.cs",
      "Content": "};\n            layerInfo.gameObject = gameObject;\n            layerInfo.identifier = identifier;\n            layerInfo.dataSize = dataSize;\n\n            mBakedDataLayerInfo.Add(layerInfo);\n        }\n\n        public void RemoveLayer(BakedDataIdentifier identifier)\n        {\n            for (int i = 0; i < mBakedDataLayerInfo.Count; ++i)\n            {\n                if (mBakedDataLayerInfo[i].identifier.Equals(identifier))\n                {\n                    var layerInfo = mBakedDataLayerInfo[i];\n                    mBakedDataLayerInfo.RemoveAt(i);\n                    UpdateGameObjectStatistics(layerInfo);\n                    return;\n                }\n            }\n        }\n\n        public void AddOrUpdateLayer(GameObject gameObject, BakedDataIdentifier identifier, int dataSize)\n        {\n            for (int i = 0; i < mBakedDataLayerInfo.Count; ++i)\n            {\n                if (mBakedDataLayerInfo[i].identifier.Equals(identifier))\n                {\n                    var layerInfo = mBakedDataLayerInfo[i];\n                    layerInfo.dataSize = dataSize;\n                    mBakedDataLayerInfo[i] = layerInfo;\n                    return;\n                }\n            }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioProbeBatch.cs",
      "Content": "erInfo = mBakedDataLayerInfo[i];\n                    layerInfo.dataSize = dataSize;\n                    mBakedDataLayerInfo[i] = layerInfo;\n                    return;\n                }\n            }\n\n            AddLayer(gameObject, identifier, dataSize);\n        }\n\n        void UpdateGameObjectStatistics(BakedDataLayerInfo layerInfo)\n        {\n            if (layerInfo.identifier.type == BakedDataType.Reflections)\n            {\n                switch (layerInfo.identifier.variation)\n                {\n                case BakedDataVariation.Reverb:\n                    layerInfo.gameObject.GetComponent<SteamAudioListener>().UpdateBakedDataStatistics();\n                    break;\n\n                case BakedDataVariation.StaticSource:\n                    layerInfo.gameObject.GetComponent<SteamAudioBakedSource>().UpdateBakedDataStatistics();\n                    break;\n\n                case BakedDataVariation.StaticListener:\n                    layerInfo.gameObject.GetComponent<SteamAudioBakedListener>().UpdateBakedDataStatistics();\n                    break;\n                }\n            }\n        }\n\n        BakedDataIdentifier GetBakedDataIdentifier()\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioProbeBatch.cs",
      "Content": "tComponent<SteamAudioBakedListener>().UpdateBakedDataStatistics();\n                    break;\n                }\n            }\n        }\n\n        BakedDataIdentifier GetBakedDataIdentifier()\n        {\n            var identifier = new BakedDataIdentifier { };\n            identifier.type = BakedDataType.Pathing;\n            identifier.variation = BakedDataVariation.Dynamic;\n            return identifier;\n        }\n\n        public void BeginBake()\n        {\n            var tasks = new BakedDataTask[1];\n            tasks[0].gameObject = gameObject;\n            tasks[0].component = this;\n            tasks[0].name = gameObject.name;\n            tasks[0].identifier = GetBakedDataIdentifier();\n            tasks[0].probeBatches = new SteamAudioProbeBatch[1];\n            tasks[0].probeBatchNames = new string[1];\n            tasks[0].probeBatchAssets = new SerializedData[1];\n\n            tasks[0].probeBatches[0] = this;\n            tasks[0].probeBatchNames[0] = gameObject.name;\n            tasks[0].probeBatchAssets[0] = GetAsset();\n\n            Baker.BeginBake(tasks);\n        }\n#endif\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioReverbData.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    /** Baked reverb data stored for a \\c SteamAudioReverbDataPoint.\n     */\n    public class SteamAudioReverbData : ScriptableObject\n    {\n        /** Reverb times (in seconds), for use in a parametric reverb effect. One per frequency band. */\n        public float[] reverbTimes;\n\n        /** The energy field, stored in a row-major array of size (#channels x #bands x #bins). */\n        public float[] reverbEnergyField;\n\n        /** The number of channels in the energy field. */\n        public int reverbEnergyFieldNumChannels;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioReverbData.cs",
      "Content": "array of size (#channels x #bands x #bins). */\n        public float[] reverbEnergyField;\n\n        /** The number of channels in the energy field. */\n        public int reverbEnergyFieldNumChannels;\n\n        /** The number of bands in the energy field. */\n        public int reverbEnergyFieldNumBands;\n\n        /** The number of bins in the energy field. */\n        public int reverbEnergyFieldNumBins;\n\n        /** The impulse response, stored in a row-major array of size (#channels x #samples). */\n        public float[] reverbIR;\n\n        /** The number of channels in the impulse response. */\n        public int reverbIRNumChannels;\n\n        /** The number of samples in the impulse response. */\n        public int reverbIRNumSamples;\n\n        /** Initializes the reverb data to default (empty) values.\n         */\n        public void Initialize()\n        {\n            reverbTimes = new float[3];\n\n            reverbEnergyField = null;\n            reverbEnergyFieldNumChannels = 0;\n            reverbEnergyFieldNumBands = 0;\n            reverbEnergyFieldNumBins = 0;\n\n            reverbIR = null;\n            reverbIRNumChannels = 0;\n            reverbIRNumSamples = 0;\n        }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioReverbData.cs",
      "Content": "reverbEnergyFieldNumBands = 0;\n            reverbEnergyFieldNumBins = 0;\n\n            reverbIR = null;\n            reverbIRNumChannels = 0;\n            reverbIRNumSamples = 0;\n        }\n\n        /** \\return The total size of the impulse response (#channels x #samples).\n         */\n        public int GetImpulseResponseSize()\n        {\n            return sizeof(float) * reverbIR.Length;\n        }\n\n        /** \\return The energy value stored for a particular channel, band, and bin.\n         * \n         *  \\param[in]  channel     The index of the channel.\n         *  \\param[in]  band        The index of the band.\n         *  \\param[in]  bin         The index of the bin.\n         */\n        public float GetEnergyFieldData(int channel, int band, int bin)\n        {\n            int index = (channel * reverbEnergyFieldNumBands * reverbEnergyFieldNumBins) + band * reverbEnergyFieldNumBins + bin;\n            return reverbEnergyField[index];\n        }\n\n        /** \\return The total size of the energy field (#channels x #bands x #bins).\n         */\n        public int GetEnergyFieldSize()\n        {\n            return sizeof(float) * reverbEnergyField.Length;\n        }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioReverbData.cs",
      "Content": "The total size of the energy field (#channels x #bands x #bins).\n         */\n        public int GetEnergyFieldSize()\n        {\n            return sizeof(float) * reverbEnergyField.Length;\n        }\n\n        /** \\return The sample value stored for a particular channel and sample index.\n         * \n         *  \\param[in]  channel     The index of the channel.\n         *  \\param[in]  sample      The index of the sample.\n         */\n        public float GetImpulseResponseData(int channel, int sample)\n        {\n            int index = (channel * reverbIRNumSamples) + sample;\n            return reverbIR[index];\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioReverbDataPoint.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEngine;\nusing System;\nusing System.Runtime.InteropServices;\nusing System.IO;\nusing System.Collections.Generic;\n\n#if UNITY_EDITOR\nusing UnityEditor;\n#endif\n\nnamespace SteamAudio\n{\n    [AddComponentMenu(\"Steam Audio/Steam Audio Reverb Data Point\")]\n    [ExecuteAlways]\n    public class SteamAudioReverbDataPoint : MonoBehaviour\n    {\n        public int sampleRate = 44100;\n\n        [Range(0, 3)]\n        public int ambisonicOrder = 0;\n\n        [Range(0.1f, 10.0f)]\n        public float reverbDuration = 1.0f;\n\n        public bool storeEnergyField = false;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioReverbDataPoint.cs",
      "Content": "pleRate = 44100;\n\n        [Range(0, 3)]\n        public int ambisonicOrder = 0;\n\n        [Range(0.1f, 10.0f)]\n        public float reverbDuration = 1.0f;\n\n        public bool storeEnergyField = false;\n        public bool storeImpulseResponse = true;\n\n        [Header(\"Baked Data\")]\n        public SteamAudioReverbData reverbData;\n\n        static List<SteamAudioReverbData> sAssetsToFlush = null;\n\n#if STEAMAUDIO_ENABLED\n        void CreateFolderRecursively(string path)\n        {\n#if UNITY_EDITOR\n            string[] parts = path.Split('/');\n            string currentPath = \"\";\n\n            for (int i = 1; i < parts.Length; i++)\n            {\n                currentPath += \"/\" + parts[i];\n                string fullPath = \"Assets\" + currentPath;\n\n                if (!AssetDatabase.IsValidFolder(fullPath))\n                {\n                    string parentPath = string.Join(\"/\", parts, 0, i);\n                    AssetDatabase.CreateFolder(parentPath, parts[i]);\n                    AssetDatabase.Refresh();\n                }\n            }\n#endif\n        }\n\n        public static string GetAssetFolderPath()\n        {\n            // Must start with Assets/"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioReverbDataPoint.cs",
      "Content": "[i]);\n                    AssetDatabase.Refresh();\n                }\n            }\n#endif\n        }\n\n        public static string GetAssetFolderPath()\n        {\n            // Must start with Assets/\n            return \"Assets/Resources/ReverbData\";\n        }\n\n        static BakedDataIdentifier GetBakedDataIdentifier()\n        {\n            var identifier = new BakedDataIdentifier { };\n            identifier.type = BakedDataType.Reflections;\n            identifier.variation = BakedDataVariation.Reverb;\n            return identifier;\n        }\n\n        public void EnsureValidData()\n        {\n#if UNITY_EDITOR\n            if (reverbData != null)\n                return;\n\n            var folderPath = GetAssetFolderPath();\n\n            if (!AssetDatabase.IsValidFolder(folderPath))\n            {\n                CreateFolderRecursively(folderPath);\n            }\n\n            string assetName = $\"{gameObject.name}_{Guid.NewGuid()}.asset\";\n            string path = Path.Combine(folderPath, assetName);\n\n            reverbData = ScriptableObject.CreateInstance<SteamAudioReverbData>();\n            reverbData.Initialize();\n\n            AssetDatabase.CreateAsset(reverbData, path);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioReverbDataPoint.cs",
      "Content": "lderPath, assetName);\n\n            reverbData = ScriptableObject.CreateInstance<SteamAudioReverbData>();\n            reverbData.Initialize();\n\n            AssetDatabase.CreateAsset(reverbData, path);\n            AssetDatabase.SaveAssets();\n            AssetDatabase.Refresh();\n            EditorUtility.SetDirty(this);\n#endif\n        }\n\n        public static void BeginBake(SteamAudioReverbDataPoint[] probes)\n        {\n#if UNITY_EDITOR\n            AssetDatabase.StartAssetEditing();\n#endif\n\n            var tasks = new BakedDataTask[probes.Length];\n            for (var i = 0; i < probes.Length; i++)\n            {\n                tasks[i].gameObject = probes[i].gameObject;\n                tasks[i].component = probes[i];\n                tasks[i].name = probes[i].gameObject.name;\n                tasks[i].identifier = GetBakedDataIdentifier();\n                tasks[i].probeBatches = null;\n                tasks[i].probeBatchNames = null;\n                tasks[i].probeBatchAssets = null;\n                tasks[i].probe = probes[i];\n                tasks[i].probePosition = probes[i].gameObject.transform.position;\n\n                tasks[i].probe.EnsureValidData();\n            }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioReverbDataPoint.cs",
      "Content": "= null;\n                tasks[i].probe = probes[i];\n                tasks[i].probePosition = probes[i].gameObject.transform.position;\n\n                tasks[i].probe.EnsureValidData();\n            }\n\n#if UNITY_EDITOR\n            AssetDatabase.StopAssetEditing();\n#endif\n\n            Baker.BeginBake(tasks, true);\n        }\n\n        public void UpdateEnergyField(IntPtr energyField)\n        {\n            if (!storeEnergyField)\n            {\n                reverbData.reverbEnergyFieldNumChannels = 0;\n                reverbData.reverbEnergyFieldNumBands = 0;\n                reverbData.reverbEnergyFieldNumBins = 0;\n                reverbData.reverbEnergyField = null;\n                return;\n            }\n\n            if (energyField == IntPtr.Zero)\n                return;\n\n            reverbData.reverbEnergyFieldNumChannels = API.iplEnergyFieldGetNumChannels(energyField);\n            reverbData.reverbEnergyFieldNumBands = 3;\n            reverbData.reverbEnergyFieldNumBins = API.iplEnergyFieldGetNumBins(energyField);\n            reverbData.reverbEnergyField = new float[reverbData.reverbEnergyFieldNumChannels * reverbData.reverbEnergyFieldNumBands * reverbData.reverbEnergyFieldNumBins];"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioReverbDataPoint.cs",
      "Content": "ldGetNumBins(energyField);\n            reverbData.reverbEnergyField = new float[reverbData.reverbEnergyFieldNumChannels * reverbData.reverbEnergyFieldNumBands * reverbData.reverbEnergyFieldNumBins];\n\n            IntPtr reverbEnergyFieldData = API.iplEnergyFieldGetData(energyField);\n            if (reverbEnergyFieldData == IntPtr.Zero)\n                return;\n\n            Marshal.Copy(reverbEnergyFieldData, reverbData.reverbEnergyField, 0, reverbData.reverbEnergyField.Length);\n        }\n\n        public void UpdateImpulseResponse(IntPtr ir)\n        {\n            if (!storeImpulseResponse)\n            {\n                reverbData.reverbIRNumChannels = 0;\n                reverbData.reverbIRNumSamples = 0;\n                reverbData.reverbIR = null;\n                return;\n            }\n\n            if (ir == IntPtr.Zero)\n                return;\n\n            reverbData.reverbIRNumChannels = API.iplImpulseResponseGetNumChannels(ir);\n            reverbData.reverbIRNumSamples = API.iplImpulseResponseGetNumSamples(ir);\n            reverbData.reverbIR = new float[reverbData.reverbIRNumChannels * reverbData.reverbIRNumSamples];"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioReverbDataPoint.cs",
      "Content": "ir);\n            reverbData.reverbIRNumSamples = API.iplImpulseResponseGetNumSamples(ir);\n            reverbData.reverbIR = new float[reverbData.reverbIRNumChannels * reverbData.reverbIRNumSamples];\n\n            IntPtr reverbIRData = API.iplImpulseResponseGetData(ir);\n            if (reverbIRData == IntPtr.Zero)\n                return;\n            \n            Marshal.Copy(reverbIRData, reverbData.reverbIR, 0, reverbData.reverbIR.Length);\n        }\n\n        public void WriteReverbDataToFile(bool flush = true)\n        {\n            if (flush)\n            {\n                FlushWrite(reverbData);\n            }\n            else\n            {\n                if (sAssetsToFlush == null)\n                {\n                    sAssetsToFlush = new List<SteamAudioReverbData>();\n                }\n\n                sAssetsToFlush.Add(reverbData);\n            }\n        }\n\n        public static void FlushWrite(SteamAudioReverbData dataAsset)\n        {\n#if UNITY_EDITOR\n            var assetPaths = new string[1];\n            assetPaths[0] = AssetDatabase.GetAssetPath(dataAsset);\n\n            // TODO: Deprecate older versions of Unity.\n#if UNITY_2017_3_OR_NEWER"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioReverbDataPoint.cs",
      "Content": "DITOR\n            var assetPaths = new string[1];\n            assetPaths[0] = AssetDatabase.GetAssetPath(dataAsset);\n\n            // TODO: Deprecate older versions of Unity.\n#if UNITY_2017_3_OR_NEWER\n            AssetDatabase.ForceReserializeAssets(assetPaths);\n#endif\n#endif\n        }\n\n        public static void FlushAllWrites()\n        {\n#if UNITY_EDITOR\n            AssetDatabase.StartAssetEditing();\n            if (sAssetsToFlush != null)\n            {\n                for (int i = 0; i < sAssetsToFlush.Count; ++i)\n                {\n                    EditorUtility.DisplayProgressBar(\"Saving Assets\", $\"{sAssetsToFlush[i]}\", ((float)(i + 1)) / sAssetsToFlush.Count);\n                    FlushWrite(sAssetsToFlush[i]);\n                }\n\n                sAssetsToFlush.Clear();\n            }\n            AssetDatabase.StopAssetEditing();\n#endif\n        }\n#endif\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSettings.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEngine;\n#if UNITY_EDITOR\nusing UnityEditor;\n#endif\n\nnamespace SteamAudio\n{\n    public enum AudioEngineType\n    {\n        Unity,\n        FMODStudio,\n        Wwise\n    }\n\n    [CreateAssetMenu(menuName = \"Steam Audio/Steam Audio Settings\")]\n    public class SteamAudioSettings : ScriptableObject\n    {\n        [Header(\"Audio Engine Settings\")]\n        public AudioEngineType audioEngine = AudioEngineType.Unity;\n\n        [Header(\"HRTF Settings\")]\n        public bool hrtfDisabled = false;\n        public bool perspectiveCorrection = false;\n        [Range(.25f, 4.0f)]"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSettings.cs",
      "Content": "neType audioEngine = AudioEngineType.Unity;\n\n        [Header(\"HRTF Settings\")]\n        public bool hrtfDisabled = false;\n        public bool perspectiveCorrection = false;\n        [Range(.25f, 4.0f)]\n        public float perspectiveCorrectionFactor = 1.0f;\n        [Range(-12.0f, 12.0f)]\n        public float hrtfVolumeGainDB = 0.0f;\n        public HRTFNormType hrtfNormalizationType = HRTFNormType.None;\n        public SOFAFile[] SOFAFiles = null;\n\n        [Header(\"Material Settings\")]\n        public SteamAudioMaterial defaultMaterial = null;\n\n        [Header(\"Ray Tracer Settings\")]\n        public SceneType sceneType = SceneType.Default;\n        public LayerMask layerMask = new LayerMask();\n\n        [Header(\"Occlusion Settings\")]\n        [Range(1, 128)]\n        public int maxOcclusionSamples = 16;\n\n        [Header(\"Real-time Reflections Settings\")]\n        [Range(1024, 65536)]\n        public int realTimeRays = 4096;\n        [Range(1, 64)]\n        public int realTimeBounces = 4;\n        [Range(0.1f, 10.0f)]\n        public float realTimeDuration = 1.0f;\n        [Range(0, 3)]\n        public int realTimeAmbisonicOrder = 1;\n        [Range(1, 128)]"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSettings.cs",
      "Content": "public int realTimeBounces = 4;\n        [Range(0.1f, 10.0f)]\n        public float realTimeDuration = 1.0f;\n        [Range(0, 3)]\n        public int realTimeAmbisonicOrder = 1;\n        [Range(1, 128)]\n        public int realTimeMaxSources = 32;\n        [Range(0, 100)]\n        public int realTimeCPUCoresPercentage = 5;\n        [Range(0.1f, 10.0f)]\n        public float realTimeIrradianceMinDistance = 1.0f;\n\n        [Header(\"Baked Reflections Settings\")]\n        public bool bakeConvolution = true;\n        public bool bakeParametric = false;\n        [Range(1024, 65536)]\n        public int bakingRays = 16384;\n        [Range(1, 64)]\n        public int bakingBounces = 16;\n        [Range(0.1f, 10.0f)]\n        public float bakingDuration = 1.0f;\n        [Range(0, 3)]\n        public int bakingAmbisonicOrder = 1;\n        [Range(0, 100)]\n        public int bakingCPUCoresPercentage = 50;\n        [Range(0.1f, 10.0f)]\n        public float bakingIrradianceMinDistance = 1.0f;\n\n        [Header(\"Baked Pathing Settings\")]\n        [Range(1, 32)]\n        public int bakingVisibilitySamples = 4;\n        [Range(0.0f, 2.0f)]\n        public float bakingVisibilityRadius = 1.0f;\n        [Range(0.0f, 1.0f)]"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSettings.cs",
      "Content": "Pathing Settings\")]\n        [Range(1, 32)]\n        public int bakingVisibilitySamples = 4;\n        [Range(0.0f, 2.0f)]\n        public float bakingVisibilityRadius = 1.0f;\n        [Range(0.0f, 1.0f)]\n        public float bakingVisibilityThreshold = 0.1f;\n        [Range(0.0f, 1000.0f)]\n        public float bakingVisibilityRange = 1000.0f;\n        [Range(0.0f, 1000.0f)]\n        public float bakingPathRange = 1000.0f;\n        [Range(0, 100)]\n        public int bakedPathingCPUCoresPercentage = 50;\n\n        [Header(\"Simulation Update Settings\")]\n        [Range(0.1f, 1.0f)]\n        public float simulationUpdateInterval = 0.1f;\n\n        [Header(\"Reflection Effect Settings\")]\n        public ReflectionEffectType reflectionEffectType = ReflectionEffectType.Convolution;\n\n        [Header(\"Hybrid Reverb Settings\")]\n        [Range(0.1f, 2.0f)]\n        public float hybridReverbTransitionTime = 1.0f;\n        [Range(0, 100)]\n        public int hybridReverbOverlapPercent = 25;\n\n        [Header(\"OpenCL Settings\")]\n        public OpenCLDeviceType deviceType = OpenCLDeviceType.GPU;\n        [Range(0, 16)]\n        public int maxReservedComputeUnits = 8;\n        [Range(0.0f, 1.0f)]"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSettings.cs",
      "Content": "[Header(\"OpenCL Settings\")]\n        public OpenCLDeviceType deviceType = OpenCLDeviceType.GPU;\n        [Range(0, 16)]\n        public int maxReservedComputeUnits = 8;\n        [Range(0.0f, 1.0f)]\n        public float fractionComputeUnitsForIRUpdate = 0.5f;\n\n        [Header(\"Radeon Rays Settings\")]\n        [Range(1, 16)]\n        public int bakingBatchSize = 8;\n\n        [Header(\"TrueAudio Next Settings\")]\n        [Range(0.1f, 10.0f)]\n        public float TANDuration = 1.0f;\n        [Range(0, 3)]\n        public int TANAmbisonicOrder = 1;\n        [Range(1, 128)]\n        public int TANMaxSources = 32;\n\n        [Header(\"Advanced Settings\")]\n        public bool EnableValidation = false;\n\n        static SteamAudioSettings sSingleton = null;\n\n        public static SteamAudioSettings Singleton\n        {\n            get\n            {\n                if (sSingleton == null)\n                {\n                    sSingleton = Resources.Load<SteamAudioSettings>(\"SteamAudioSettings\");\n                    if (sSingleton == null)\n                    {\n                        sSingleton = CreateInstance<SteamAudioSettings>();\n                        sSingleton.name = \"Steam Audio Settings\";"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSettings.cs",
      "Content": "if (sSingleton == null)\n                    {\n                        sSingleton = CreateInstance<SteamAudioSettings>();\n                        sSingleton.name = \"Steam Audio Settings\";\n\n#if UNITY_EDITOR\n                        sSingleton.defaultMaterial = (SteamAudioMaterial) AssetDatabase.LoadAssetAtPath(\"Assets/Plugins/SteamAudio/Resources/Materials/Default.asset\", typeof(SteamAudioMaterial));\n\n                        AssetDatabase.CreateAsset(sSingleton, \"Assets/Plugins/SteamAudio/Resources/SteamAudioSettings.asset\");\n#endif\n                    }\n                }\n\n                return sSingleton;\n            }\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSource.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing AOT;\nusing System;\nusing System.Runtime.InteropServices;\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    public enum DistanceAttenuationInput\n    {\n        CurveDriven,\n        PhysicsBased\n    }\n\n    public enum AirAbsorptionInput\n    {\n        SimulationDefined,\n        UserDefined\n    }\n\n    public enum DirectivityInput\n    {\n        SimulationDefined,\n        UserDefined\n    }\n\n    public enum OcclusionInput\n    {\n        SimulationDefined,\n        UserDefined\n    }\n\n    public enum TransmissionInput\n    {\n        SimulationDefined,\n        UserDefined\n    }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSource.cs",
      "Content": "Defined\n    }\n\n    public enum OcclusionInput\n    {\n        SimulationDefined,\n        UserDefined\n    }\n\n    public enum TransmissionInput\n    {\n        SimulationDefined,\n        UserDefined\n    }\n\n    public enum ReflectionsType\n    {\n        Realtime,\n        BakedStaticSource,\n        BakedStaticListener\n    }\n\n    public struct AudioSourceAttenuationData\n    {\n        public AudioRolloffMode rolloffMode;\n        public float minDistance;\n        public float maxDistance;\n        public AnimationCurve curve;\n    }\n\n    [AddComponentMenu(\"Steam Audio/Steam Audio Source\")]\n    public class SteamAudioSource : MonoBehaviour\n    {\n        [Header(\"HRTF Settings\")]\n        public bool directBinaural = true;\n        public HRTFInterpolation interpolation = HRTFInterpolation.Nearest;\n        public bool perspectiveCorrection = false;\n\n        [Header(\"Attenuation Settings\")]\n        public bool distanceAttenuation = false;\n        public DistanceAttenuationInput distanceAttenuationInput = DistanceAttenuationInput.CurveDriven;\n        public float distanceAttenuationValue = 1.0f;\n        public bool airAbsorption = false;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSource.cs",
      "Content": "public DistanceAttenuationInput distanceAttenuationInput = DistanceAttenuationInput.CurveDriven;\n        public float distanceAttenuationValue = 1.0f;\n        public bool airAbsorption = false;\n        public AirAbsorptionInput airAbsorptionInput = AirAbsorptionInput.SimulationDefined;\n        [Range(0.0f, 1.0f)]\n        public float airAbsorptionLow = 1.0f;\n        [Range(0.0f, 1.0f)]\n        public float airAbsorptionMid = 1.0f;\n        [Range(0.0f, 1.0f)]\n        public float airAbsorptionHigh = 1.0f;\n\n        [Header(\"Directivity Settings\")]\n        public bool directivity = false;\n        public DirectivityInput directivityInput = DirectivityInput.SimulationDefined;\n        [Range(0.0f, 1.0f)]\n        public float dipoleWeight = 0.0f;\n        [Range(0.0f, 4.0f)]\n        public float dipolePower = 0.0f;\n        [Range(0.0f, 1.0f)]\n        public float directivityValue = 1.0f;\n\n        [Header(\"Occlusion Settings\")]\n        public bool occlusion = false;\n        public OcclusionInput occlusionInput = OcclusionInput.SimulationDefined;\n        public OcclusionType occlusionType = OcclusionType.Raycast;\n        [Range(0.0f, 4.0f)]\n        public float occlusionRadius = 1.0f;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSource.cs",
      "Content": "onInput occlusionInput = OcclusionInput.SimulationDefined;\n        public OcclusionType occlusionType = OcclusionType.Raycast;\n        [Range(0.0f, 4.0f)]\n        public float occlusionRadius = 1.0f;\n        [Range(1, 128)]\n        public int occlusionSamples = 16;\n        [Range(0.0f, 1.0f)]\n        public float occlusionValue = 1.0f;\n        public bool transmission = false;\n        public TransmissionType transmissionType = TransmissionType.FrequencyIndependent;\n        public TransmissionInput transmissionInput = TransmissionInput.SimulationDefined;\n        [Range(0.0f, 1.0f)]\n        public float transmissionLow = 1.0f;\n        [Range(0.0f, 1.0f)]\n        public float transmissionMid = 1.0f;\n        [Range(0.0f, 1.0f)]\n        public float transmissionHigh = 1.0f;\n        [Range(1, 8)]\n        public int maxTransmissionSurfaces = 1;\n\n        [Header(\"Direct Mix Settings\")]\n        [Range(0.0f, 1.0f)]\n        public float directMixLevel = 1.0f;\n\n        [Header(\"Reflections Settings\")]\n        public bool reflections = false;\n        public ReflectionsType reflectionsType = ReflectionsType.Realtime;\n        public bool useDistanceCurveForReflections = false;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSource.cs",
      "Content": "Reflections Settings\")]\n        public bool reflections = false;\n        public ReflectionsType reflectionsType = ReflectionsType.Realtime;\n        public bool useDistanceCurveForReflections = false;\n        public SteamAudioBakedSource currentBakedSource = null;\n        public IntPtr reflectionsIR = IntPtr.Zero;\n        public float reverbTimeLow = 0.0f;\n        public float reverbTimeMid = 0.0f;\n        public float reverbTimeHigh = 0.0f;\n        public float hybridReverbEQLow = 1.0f;\n        public float hybridReverbEQMid = 1.0f;\n        public float hybridReverbEQHigh = 1.0f;\n        public int hybridReverbDelay = 0;\n        public bool applyHRTFToReflections = false;\n        [Range(0.0f, 10.0f)]\n        public float reflectionsMixLevel = 1.0f;\n\n        [Header(\"Pathing Settings\")]\n        public bool pathing = false;\n        public SteamAudioProbeBatch pathingProbeBatch = null;\n        public bool pathValidation = true;\n        public bool findAlternatePaths = true;\n        public float[] pathingEQ = new float[3] { 1.0f, 1.0f, 1.0f };\n        public float[] pathingSH = new float[16];\n        public bool applyHRTFToPathing = false;\n        [Range(0.0f, 10.0f)]"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSource.cs",
      "Content": "e;\n        public float[] pathingEQ = new float[3] { 1.0f, 1.0f, 1.0f };\n        public float[] pathingSH = new float[16];\n        public bool applyHRTFToPathing = false;\n        [Range(0.0f, 10.0f)]\n        public float pathingMixLevel = 1.0f;\n        public bool normalizePathingEQ = false;\n\n#if STEAMAUDIO_ENABLED\n        Simulator mSimulator = null;\n        Source mSource = null;\n        AudioEngineSource mAudioEngineSource = null;\n        UnityEngine.Vector3[] mSphereVertices = null;\n        UnityEngine.Vector3[] mDeformedSphereVertices = null;\n        Mesh mDeformedSphereMesh = null;\n\n        AudioSource mAudioSource = null;\n        AudioSourceAttenuationData mAttenuationData = new AudioSourceAttenuationData { };\n        DistanceAttenuationModel mCurveAttenuationModel = new DistanceAttenuationModel { };\n        GCHandle mThis;\n        SteamAudioSettings mSettings = null;\n\n        private void Awake()\n        {\n            mSimulator = SteamAudioManager.Simulator;\n\n            var settings = SteamAudioManager.GetSimulationSettings(false);\n            mSource = new Source(SteamAudioManager.Simulator, settings);\n            mSettings = SteamAudioSettings.Singleton;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSource.cs",
      "Content": "var settings = SteamAudioManager.GetSimulationSettings(false);\n            mSource = new Source(SteamAudioManager.Simulator, settings);\n            mSettings = SteamAudioSettings.Singleton;\n\n            mAudioEngineSource = AudioEngineSource.Create(mSettings.audioEngine);\n            if (mAudioEngineSource != null)\n            {\n                mAudioEngineSource.Initialize(gameObject);\n                mAudioEngineSource.UpdateParameters(this);\n            }\n\n            mAudioSource = GetComponent<AudioSource>();\n\n            mThis = GCHandle.Alloc(this);\n\n            if ((mSettings.audioEngine == AudioEngineType.Unity &&\n                distanceAttenuation &&\n                distanceAttenuationInput == DistanceAttenuationInput.CurveDriven &&\n                reflections &&\n                useDistanceCurveForReflections) ||\n                (pathing && distanceAttenuationInput == DistanceAttenuationInput.CurveDriven))\n            {\n                mAttenuationData.rolloffMode = mAudioSource.rolloffMode;\n                mAttenuationData.minDistance = mAudioSource.minDistance;\n                mAttenuationData.maxDistance = mAudioSource.maxDistance;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSource.cs",
      "Content": "tenuationData.rolloffMode = mAudioSource.rolloffMode;\n                mAttenuationData.minDistance = mAudioSource.minDistance;\n                mAttenuationData.maxDistance = mAudioSource.maxDistance;\n                mAttenuationData.curve = mAudioSource.GetCustomCurve(AudioSourceCurveType.CustomRolloff);\n\n                mCurveAttenuationModel.type = DistanceAttenuationModelType.Callback;\n                mCurveAttenuationModel.callback = EvaluateDistanceCurve;\n                mCurveAttenuationModel.userData = GCHandle.ToIntPtr(mThis);\n                mCurveAttenuationModel.dirty = Bool.False;\n            }\n        }\n\n        private void Start()\n        {\n            if (mAudioEngineSource != null)\n            {\n                mAudioEngineSource.UpdateParameters(this);\n            }\n        }\n\n        private void OnDestroy()\n        {\n            if (mAudioEngineSource != null)\n            {\n                mAudioEngineSource.Destroy();\n                mAudioEngineSource = null;\n            }\n\n            if (mSource != null)\n            {\n                mSource.Release();\n                mSource = null;\n            }\n        }\n\n        ~SteamAudioSource()\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSource.cs",
      "Content": "= null;\n            }\n\n            if (mSource != null)\n            {\n                mSource.Release();\n                mSource = null;\n            }\n        }\n\n        ~SteamAudioSource()\n        {\n            if (mThis.IsAllocated)\n            {\n                mThis.Free();\n            }\n        }\n\n        private void OnEnable()\n        {\n            mSource.AddToSimulator(mSimulator);\n            SteamAudioManager.AddSource(this);\n\n            if (mAudioEngineSource != null)\n            {\n                mAudioEngineSource.UpdateParameters(this);\n            }\n        }\n\n        private void OnDisable()\n        {\n            SteamAudioManager.RemoveSource(this);\n            mSource.RemoveFromSimulator(mSimulator);\n        }\n\n        private void Update()\n        {\n            if (mAudioEngineSource != null)\n            {\n                mAudioEngineSource.UpdateParameters(this);\n            }\n        }\n\n        private void OnDrawGizmosSelected()\n        {\n            if (directivity && directivityInput == DirectivityInput.SimulationDefined && dipoleWeight > 0.0f)\n            {\n                if (mDeformedSphereMesh == null)\n                {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSource.cs",
      "Content": "{\n            if (directivity && directivityInput == DirectivityInput.SimulationDefined && dipoleWeight > 0.0f)\n            {\n                if (mDeformedSphereMesh == null)\n                {\n                    InitializeDeformedSphereMesh(32, 32);\n                }\n\n                DeformSphereMesh();\n\n                var oldColor = Gizmos.color;\n                Gizmos.color = Color.red;\n                Gizmos.DrawWireMesh(mDeformedSphereMesh, transform.position, transform.rotation);\n                Gizmos.color = oldColor;\n            }\n        }\n\n        public void SetInputs(SimulationFlags flags)\n        {\n            var listener = SteamAudioManager.GetSteamAudioListener();\n\n            var inputs = new SimulationInputs { };\n            inputs.source.origin = Common.ConvertVector(transform.position);\n            inputs.source.ahead = Common.ConvertVector(transform.forward);\n            inputs.source.up = Common.ConvertVector(transform.up);\n            inputs.source.right = Common.ConvertVector(transform.right);\n\n            if (mSettings.audioEngine == AudioEngineType.Unity &&\n                distanceAttenuation &&"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSource.cs",
      "Content": "ector(transform.up);\n            inputs.source.right = Common.ConvertVector(transform.right);\n\n            if (mSettings.audioEngine == AudioEngineType.Unity &&\n                distanceAttenuation &&\n                distanceAttenuationInput == DistanceAttenuationInput.CurveDriven &&\n                reflections &&\n                useDistanceCurveForReflections)\n            {\n                inputs.distanceAttenuationModel = mCurveAttenuationModel;\n            }\n            else if (pathing && distanceAttenuationInput == DistanceAttenuationInput.CurveDriven)\n            {\n                inputs.distanceAttenuationModel = mCurveAttenuationModel;\n            }\n            else\n            {\n                inputs.distanceAttenuationModel.type = DistanceAttenuationModelType.Default;\n            }\n\n            inputs.airAbsorptionModel.type = AirAbsorptionModelType.Default;\n            inputs.directivity.dipoleWeight = dipoleWeight;\n            inputs.directivity.dipolePower = dipolePower;\n            inputs.occlusionType = occlusionType;\n            inputs.occlusionRadius = occlusionRadius;\n            inputs.numOcclusionSamples = occlusionSamples;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSource.cs",
      "Content": "rectivity.dipolePower = dipolePower;\n            inputs.occlusionType = occlusionType;\n            inputs.occlusionRadius = occlusionRadius;\n            inputs.numOcclusionSamples = occlusionSamples;\n            inputs.numTransmissionRays = maxTransmissionSurfaces;\n            inputs.reverbScaleLow = 1.0f;\n            inputs.reverbScaleMid = 1.0f;\n            inputs.reverbScaleHigh = 1.0f;\n            inputs.hybridReverbTransitionTime = mSettings.hybridReverbTransitionTime;\n            inputs.hybridReverbOverlapPercent = mSettings.hybridReverbOverlapPercent / 100.0f;\n            inputs.baked = (reflectionsType != ReflectionsType.Realtime) ? Bool.True : Bool.False;\n            inputs.pathingProbes = (pathingProbeBatch != null) ? pathingProbeBatch.GetProbeBatch() : IntPtr.Zero;\n            inputs.visRadius = mSettings.bakingVisibilityRadius;\n            inputs.visThreshold = mSettings.bakingVisibilityThreshold;\n            inputs.visRange = mSettings.bakingVisibilityRange;\n            inputs.pathingOrder = mSettings.realTimeAmbisonicOrder;\n            inputs.enableValidation = pathValidation ? Bool.True : Bool.False;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSource.cs",
      "Content": "inputs.visRange = mSettings.bakingVisibilityRange;\n            inputs.pathingOrder = mSettings.realTimeAmbisonicOrder;\n            inputs.enableValidation = pathValidation ? Bool.True : Bool.False;\n            inputs.findAlternatePaths = findAlternatePaths ? Bool.True : Bool.False;\n\n            if (reflectionsType == ReflectionsType.BakedStaticSource)\n            {\n                if (currentBakedSource != null)\n                {\n                    inputs.bakedDataIdentifier = currentBakedSource.GetBakedDataIdentifier();\n                }\n            }\n            else if (reflectionsType == ReflectionsType.BakedStaticListener)\n            {\n                if (listener != null && listener.currentBakedListener != null)\n                {\n                    inputs.bakedDataIdentifier = listener.currentBakedListener.GetBakedDataIdentifier();\n                }\n            }\n\n            inputs.flags = SimulationFlags.Direct;\n            if (reflections)\n            {\n                if ((reflectionsType == ReflectionsType.Realtime) ||\n                    (reflectionsType == ReflectionsType.BakedStaticSource && currentBakedSource != null) ||"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSource.cs",
      "Content": "ections)\n            {\n                if ((reflectionsType == ReflectionsType.Realtime) ||\n                    (reflectionsType == ReflectionsType.BakedStaticSource && currentBakedSource != null) ||\n                    (reflectionsType == ReflectionsType.BakedStaticListener && listener != null && listener.currentBakedListener != null))\n                {\n                    inputs.flags = inputs.flags | SimulationFlags.Reflections;\n                }\n            }\n            if (pathing)\n            {\n                if (pathingProbeBatch == null)\n                {\n                    pathing = false;\n                    Debug.LogWarningFormat(\"Pathing probe batch not set, disabling pathing for source {0}.\", gameObject.name);\n                }\n                else\n                {\n                    inputs.flags = inputs.flags | SimulationFlags.Pathing;\n                }\n            }\n\n            inputs.directFlags = 0;\n            if (distanceAttenuation)\n                inputs.directFlags = inputs.directFlags | DirectSimulationFlags.DistanceAttenuation;\n            if (airAbsorption)"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSource.cs",
      "Content": "inputs.directFlags = 0;\n            if (distanceAttenuation)\n                inputs.directFlags = inputs.directFlags | DirectSimulationFlags.DistanceAttenuation;\n            if (airAbsorption)\n                inputs.directFlags = inputs.directFlags | DirectSimulationFlags.AirAbsorption;\n            if (directivity)\n                inputs.directFlags = inputs.directFlags | DirectSimulationFlags.Directivity;\n            if (occlusion)\n                inputs.directFlags = inputs.directFlags | DirectSimulationFlags.Occlusion;\n            if (transmission)\n                inputs.directFlags = inputs.directFlags | DirectSimulationFlags.Transmission;\n\n            mSource.SetInputs(flags, inputs);\n        }\n\n        public SimulationOutputs GetOutputs(SimulationFlags flags)\n        {\n            return mSource.GetOutputs(flags);\n        }\n\n        public Source GetSource()\n        {\n            return mSource;\n        }\n\n        public void UpdateOutputs(SimulationFlags flags)\n        {\n            var outputs = mSource.GetOutputs(flags);\n\n            if (SteamAudioSettings.Singleton.audioEngine == AudioEngineType.Unity &&\n                ((flags & SimulationFlags.Direct) != 0))"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSource.cs",
      "Content": "{\n            var outputs = mSource.GetOutputs(flags);\n\n            if (SteamAudioSettings.Singleton.audioEngine == AudioEngineType.Unity &&\n                ((flags & SimulationFlags.Direct) != 0))\n            {\n                if (distanceAttenuation && distanceAttenuationInput == DistanceAttenuationInput.PhysicsBased)\n                {\n                    distanceAttenuationValue = outputs.direct.distanceAttenuation;\n                }\n\n                if (airAbsorption && airAbsorptionInput == AirAbsorptionInput.SimulationDefined)\n                {\n                    airAbsorptionLow = outputs.direct.airAbsorptionLow;\n                    airAbsorptionMid = outputs.direct.airAbsorptionMid;\n                    airAbsorptionHigh = outputs.direct.airAbsorptionHigh;\n                }\n\n                if (directivity && directivityInput == DirectivityInput.SimulationDefined)\n                {\n                    directivityValue = outputs.direct.directivity;\n                }\n\n                if (occlusion && occlusionInput == OcclusionInput.SimulationDefined)\n                {\n                    occlusionValue = outputs.direct.occlusion;\n                }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSource.cs",
      "Content": "}\n\n                if (occlusion && occlusionInput == OcclusionInput.SimulationDefined)\n                {\n                    occlusionValue = outputs.direct.occlusion;\n                }\n\n                if (transmission && transmissionInput == TransmissionInput.SimulationDefined)\n                {\n                    transmissionLow = outputs.direct.transmissionLow;\n                    transmissionMid = outputs.direct.transmissionMid;\n                    transmissionHigh = outputs.direct.transmissionHigh;\n                }\n            }\n\n            if (pathing && ((flags & SimulationFlags.Pathing) != 0))\n            {\n                outputs.pathing.eqCoeffsLow = Mathf.Max(0.1f, outputs.pathing.eqCoeffsLow);\n                outputs.pathing.eqCoeffsMid = Mathf.Max(0.1f, outputs.pathing.eqCoeffsMid);\n                outputs.pathing.eqCoeffsHigh = Mathf.Max(0.1f, outputs.pathing.eqCoeffsHigh);\n            }\n        }\n\n        void InitializeDeformedSphereMesh(int nPhi, int nTheta)\n        {\n            var dPhi = (2.0f * Mathf.PI) / nPhi;\n            var dTheta = Mathf.PI / nTheta;\n\n            mSphereVertices = new UnityEngine.Vector3[nPhi * nTheta];"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSource.cs",
      "Content": "esh(int nPhi, int nTheta)\n        {\n            var dPhi = (2.0f * Mathf.PI) / nPhi;\n            var dTheta = Mathf.PI / nTheta;\n\n            mSphereVertices = new UnityEngine.Vector3[nPhi * nTheta];\n            var index = 0;\n            for (var i = 0; i < nPhi; ++i)\n            {\n                var phi = i * dPhi;\n                for (var j = 0; j < nTheta; ++j)\n                {\n                    var theta = (j * dTheta) - (0.5f * Mathf.PI);\n\n                    var x = Mathf.Cos(theta) * Mathf.Sin(phi);\n                    var y = Mathf.Sin(theta);\n                    var z = Mathf.Cos(theta) * -Mathf.Cos(phi);\n\n                    var vertex = new UnityEngine.Vector3(x, y, z);\n\n                    mSphereVertices[index++] = vertex;\n                }\n            }\n\n            mDeformedSphereVertices = new UnityEngine.Vector3[nPhi * nTheta];\n            Array.Copy(mSphereVertices, mDeformedSphereVertices, mSphereVertices.Length);\n\n            var indices = new int[6 * nPhi * (nTheta - 1)];\n            index = 0;\n            for (var i = 0; i < nPhi; ++i)\n            {\n                for (var j = 0; j < nTheta - 1; ++j)\n                {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSource.cs",
      "Content": "var indices = new int[6 * nPhi * (nTheta - 1)];\n            index = 0;\n            for (var i = 0; i < nPhi; ++i)\n            {\n                for (var j = 0; j < nTheta - 1; ++j)\n                {\n                    var i0 = i * nTheta + j;\n                    var i1 = i * nTheta + (j + 1);\n                    var i2 = ((i + 1) % nPhi) * nTheta + (j + 1);\n                    var i3 = ((i + 1) % nPhi) * nTheta + j;\n\n                    indices[index++] = i0;\n                    indices[index++] = i1;\n                    indices[index++] = i2;\n                    indices[index++] = i0;\n                    indices[index++] = i2;\n                    indices[index++] = i3;\n                }\n            }\n\n            mDeformedSphereMesh = new Mesh();\n            mDeformedSphereMesh.vertices = mDeformedSphereVertices;\n            mDeformedSphereMesh.triangles = indices;\n            mDeformedSphereMesh.RecalculateNormals();\n        }\n\n        void DeformSphereMesh()\n        {\n            for (var i = 0; i < mSphereVertices.Length; ++i)\n            {\n                mDeformedSphereVertices[i] = DeformedVertex(mSphereVertices[i]);\n            }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSource.cs",
      "Content": "DeformSphereMesh()\n        {\n            for (var i = 0; i < mSphereVertices.Length; ++i)\n            {\n                mDeformedSphereVertices[i] = DeformedVertex(mSphereVertices[i]);\n            }\n\n            mDeformedSphereMesh.vertices = mDeformedSphereVertices;\n        }\n\n        UnityEngine.Vector3 DeformedVertex(UnityEngine.Vector3 vertex)\n        {\n            var cosine = vertex.z;\n            var r = Mathf.Pow(Mathf.Abs((1.0f - dipoleWeight) + dipoleWeight * cosine), dipolePower);\n            var deformedVertex = vertex;\n            deformedVertex.Scale(new UnityEngine.Vector3(r, r, r));\n            return deformedVertex;\n        }\n\n        [MonoPInvokeCallback(typeof(DistanceAttenuationCallback))]\n        public static float EvaluateDistanceCurve(float distance, IntPtr userData)\n        {\n            var target = (SteamAudioSource) GCHandle.FromIntPtr(userData).Target;\n\n            var rMin = target.mAttenuationData.minDistance;\n            var rMax = target.mAttenuationData.maxDistance;\n\n            switch (target.mAttenuationData.rolloffMode)\n            {\n                case AudioRolloffMode.Logarithmic:\n                    if (distance < rMin)"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioSource.cs",
      "Content": "arget.mAttenuationData.maxDistance;\n\n            switch (target.mAttenuationData.rolloffMode)\n            {\n                case AudioRolloffMode.Logarithmic:\n                    if (distance < rMin)\n                        return 1.0f;\n                    else if (distance > rMax)\n                        return 0.0f;\n                    else\n                        return rMin / distance;\n\n                case AudioRolloffMode.Linear:\n                    if (distance < rMin)\n                        return 1.0f;\n                    else if (distance > rMax)\n                        return 0.0f;\n                    else\n                        return (rMax - distance) / (rMax - rMin);\n\n                case AudioRolloffMode.Custom:\n#if UNITY_2018_1_OR_NEWER\n                    return target.mAttenuationData.curve.Evaluate(distance / rMax);\n#else\n                    if (distance < rMin)\n                        return 1.0f;\n                    else if (distance > rMax)\n                        return 0.0f;\n                    else\n                        return rMin / distance;\n#endif\n\n                default:\n                    return 0.0f;\n            }\n        }\n#endif\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioStaticMesh.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing System.Threading.Tasks;\n\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    public class SteamAudioStaticMesh : MonoBehaviour\n    {\n        [Header(\"Export Settings\")]\n        public SerializedData asset = null;\n        public string sceneNameWhenExported = \"\";\n\n#if STEAMAUDIO_ENABLED\n        StaticMesh mStaticMesh = null;\n        Task<StaticMesh> mTask = null;\n\n        void Start()\n        {\n            if (asset == null)\n            {\n                Debug.LogWarningFormat(\"No asset set for Steam Audio Static Mesh in scene {0}. Export the scene before clicking Play.\","
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioStaticMesh.cs",
      "Content": "Start()\n        {\n            if (asset == null)\n            {\n                Debug.LogWarningFormat(\"No asset set for Steam Audio Static Mesh in scene {0}. Export the scene before clicking Play.\",\n                    gameObject.scene.name);\n            }\n        }\n\n        void OnDestroy()\n        {\n            if (mStaticMesh != null)\n            {\n                mStaticMesh.Release();\n            }\n            else if (mTask != null)\n            {\n                mTask.ContinueWith(static e => e.Result.Release());\n            }\n        }\n\n        void OnEnable()\n        {\n            if (mStaticMesh != null)\n            {\n                mStaticMesh.AddToScene(SteamAudioManager.CurrentScene);\n                SteamAudioManager.ScheduleCommitScene();\n            }\n        }\n\n        void OnDisable()\n        {\n            if (mStaticMesh != null && SteamAudioManager.CurrentScene != null)\n            {\n                mStaticMesh.RemoveFromScene(SteamAudioManager.CurrentScene);\n                SteamAudioManager.ScheduleCommitScene();\n            }\n        }\n\n        void Update()\n        {\n            if (mStaticMesh == null && asset != null)\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/SteamAudioStaticMesh.cs",
      "Content": "er.CurrentScene);\n                SteamAudioManager.ScheduleCommitScene();\n            }\n        }\n\n        void Update()\n        {\n            if (mStaticMesh == null && asset != null)\n            {\n                if (mTask == null)\n                {\n                    mTask = Task.Run(() => new StaticMesh(SteamAudioManager.Context, SteamAudioManager.CurrentScene, asset));\n                }\n                else if (mTask.IsCompleted)\n                {\n                    mStaticMesh = mTask.Result;\n                    mTask = null;\n                    if (enabled)\n                    {\n                        mStaticMesh.AddToScene(SteamAudioManager.CurrentScene);\n                        SteamAudioManager.ScheduleCommitScene();\n                    }\n                }\n            }\n        }\n#endif\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/TrueAudioNextDevice.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing System;\n\nnamespace SteamAudio\n{\n    public class TrueAudioNextDevice\n    {\n        IntPtr mTrueAudioNextDevice = IntPtr.Zero;\n\n        public TrueAudioNextDevice(OpenCLDevice openCLDevice, int frameSize, int irSize, int order, int maxSources)\n        {\n            var deviceSettings = new TrueAudioNextDeviceSettings { };\n            deviceSettings.frameSize = frameSize;\n            deviceSettings.irSize = irSize;\n            deviceSettings.order = order;\n            deviceSettings.maxSources = maxSources;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/TrueAudioNextDevice.cs",
      "Content": "tings { };\n            deviceSettings.frameSize = frameSize;\n            deviceSettings.irSize = irSize;\n            deviceSettings.order = order;\n            deviceSettings.maxSources = maxSources;\n\n            var status = API.iplTrueAudioNextDeviceCreate(openCLDevice.Get(), ref deviceSettings, out mTrueAudioNextDevice);\n            if (status != Error.Success)\n                throw new Exception(string.Format(\"Unable to create TrueAudio Next device. [{0}]\", status));\n        }\n\n        public TrueAudioNextDevice(TrueAudioNextDevice device)\n        {\n            mTrueAudioNextDevice = API.iplTrueAudioNextDeviceRetain(device.mTrueAudioNextDevice);\n        }\n\n        ~TrueAudioNextDevice()\n        {\n            Release();\n        }\n\n        public void Release()\n        {\n            API.iplTrueAudioNextDeviceRelease(ref mTrueAudioNextDevice);\n        }\n\n        public IntPtr Get()\n        {\n            return mTrueAudioNextDevice;\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/UnityAudioEngineAmbisonicSource.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing System;\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    public sealed class UnityAudioEngineAmbisonicSource : AudioEngineAmbisonicSource\n    {\n        AudioSource mAudioSource = null;\n\n        public override void Initialize(GameObject gameObject)\n        {\n            mAudioSource = gameObject.GetComponent<AudioSource>();\n        }\n\n        public override void UpdateParameters(SteamAudioAmbisonicSource ambisonicSource)\n        {\n            if (!mAudioSource)\n                return;\n\n            var index = 0;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/UnityAudioEngineAmbisonicSource.cs",
      "Content": "ce>();\n        }\n\n        public override void UpdateParameters(SteamAudioAmbisonicSource ambisonicSource)\n        {\n            if (!mAudioSource)\n                return;\n\n            var index = 0;\n            mAudioSource.SetAmbisonicDecoderFloat(index++, (ambisonicSource.applyHRTF) ? 1.0f : 0.0f);\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/UnityAudioEngineSource.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n#if STEAMAUDIO_ENABLED\n\nusing System;\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    public sealed class UnityAudioEngineSource : AudioEngineSource\n    {\n        AudioSource mAudioSource = null;\n        SteamAudioSource mSteamAudioSource = null;\n        int mHandle = -1;\n\n        public override void Initialize(GameObject gameObject)\n        {\n            mAudioSource = gameObject.GetComponent<AudioSource>();\n\n            mSteamAudioSource = gameObject.GetComponent<SteamAudioSource>();\n            if (mSteamAudioSource)\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/UnityAudioEngineSource.cs",
      "Content": "{\n            mAudioSource = gameObject.GetComponent<AudioSource>();\n\n            mSteamAudioSource = gameObject.GetComponent<SteamAudioSource>();\n            if (mSteamAudioSource)\n            {\n                mHandle = API.iplUnityAddSource(mSteamAudioSource.GetSource().Get());\n            }\n        }\n\n        public override void Destroy()\n        {\n            var index = 28;\n\n            if (mAudioSource != null)\n            {\n                mAudioSource.SetSpatializerFloat(index, -1);\n            }\n\n            if (mSteamAudioSource)\n            {\n                API.iplUnityRemoveSource(mHandle);\n            }\n        }\n\n        public override void UpdateParameters(SteamAudioSource source)\n        {\n            if (!mAudioSource)\n                return;\n\n            var index = 0;\n            mAudioSource.SetSpatializerFloat(index++, (source.distanceAttenuation) ? 1.0f : 0.0f);\n            mAudioSource.SetSpatializerFloat(index++, (source.airAbsorption) ? 1.0f : 0.0f);\n            mAudioSource.SetSpatializerFloat(index++, (source.directivity) ? 1.0f : 0.0f);\n            mAudioSource.SetSpatializerFloat(index++, (source.occlusion) ? 1.0f : 0.0f);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/UnityAudioEngineSource.cs",
      "Content": "on) ? 1.0f : 0.0f);\n            mAudioSource.SetSpatializerFloat(index++, (source.directivity) ? 1.0f : 0.0f);\n            mAudioSource.SetSpatializerFloat(index++, (source.occlusion) ? 1.0f : 0.0f);\n            mAudioSource.SetSpatializerFloat(index++, (source.transmission) ? 1.0f : 0.0f);\n            mAudioSource.SetSpatializerFloat(index++, (source.reflections) ? 1.0f : 0.0f);\n            mAudioSource.SetSpatializerFloat(index++, (source.pathing) ? 1.0f : 0.0f);\n            mAudioSource.SetSpatializerFloat(index++, (float) source.interpolation);\n            mAudioSource.SetSpatializerFloat(index++, source.distanceAttenuationValue);\n            mAudioSource.SetSpatializerFloat(index++, (source.distanceAttenuationInput == DistanceAttenuationInput.CurveDriven) ? 1.0f : 0.0f);\n            mAudioSource.SetSpatializerFloat(index++, source.airAbsorptionLow);\n            mAudioSource.SetSpatializerFloat(index++, source.airAbsorptionMid);\n            mAudioSource.SetSpatializerFloat(index++, source.airAbsorptionHigh);\n            mAudioSource.SetSpatializerFloat(index++, (source.airAbsorptionInput == AirAbsorptionInput.UserDefined) ? 1.0f : 0.0f);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/UnityAudioEngineSource.cs",
      "Content": "AudioSource.SetSpatializerFloat(index++, source.airAbsorptionHigh);\n            mAudioSource.SetSpatializerFloat(index++, (source.airAbsorptionInput == AirAbsorptionInput.UserDefined) ? 1.0f : 0.0f);\n            mAudioSource.SetSpatializerFloat(index++, source.directivityValue);\n            mAudioSource.SetSpatializerFloat(index++, source.dipoleWeight);\n            mAudioSource.SetSpatializerFloat(index++, source.dipolePower);\n            mAudioSource.SetSpatializerFloat(index++, (source.directivityInput == DirectivityInput.UserDefined) ? 1.0f : 0.0f);\n            mAudioSource.SetSpatializerFloat(index++, source.occlusionValue);\n            mAudioSource.SetSpatializerFloat(index++, (float) source.transmissionType);\n            mAudioSource.SetSpatializerFloat(index++, source.transmissionLow);\n            mAudioSource.SetSpatializerFloat(index++, source.transmissionMid);\n            mAudioSource.SetSpatializerFloat(index++, source.transmissionHigh);\n            mAudioSource.SetSpatializerFloat(index++, source.directMixLevel);\n            mAudioSource.SetSpatializerFloat(index++, (source.applyHRTFToReflections) ? 1.0f : 0.0f);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/UnityAudioEngineSource.cs",
      "Content": ".transmissionHigh);\n            mAudioSource.SetSpatializerFloat(index++, source.directMixLevel);\n            mAudioSource.SetSpatializerFloat(index++, (source.applyHRTFToReflections) ? 1.0f : 0.0f);\n            mAudioSource.SetSpatializerFloat(index++, source.reflectionsMixLevel);\n            mAudioSource.SetSpatializerFloat(index++, (source.applyHRTFToPathing) ? 1.0f : 0.0f);\n            mAudioSource.SetSpatializerFloat(index++, source.pathingMixLevel);\n            index++; // Skip 2 deprecated params.\n            index++;\n            mAudioSource.SetSpatializerFloat(index++, (source.directBinaural) ? 1.0f : 0.0f);\n            mAudioSource.SetSpatializerFloat(index++, mHandle);\n            mAudioSource.SetSpatializerFloat(index++, (source.perspectiveCorrection) ? 1.0f : 0.0f);\n            mAudioSource.SetSpatializerFloat(index++, (source.normalizePathingEQ) ? 1.0f : 0.0f);\n        }\n    }\n}\n\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/UnityAudioEngineState.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n#if STEAMAUDIO_ENABLED\n\nusing System;\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    public sealed class UnityAudioEngineState : AudioEngineState\n    {\n        public override void Initialize(IntPtr context, IntPtr defaultHRTF, SimulationSettings simulationSettings, PerspectiveCorrection correction)\n        {\n            API.iplUnityInitialize(context);\n            API.iplUnitySetHRTF(defaultHRTF);\n            API.iplUnitySetSimulationSettings(simulationSettings);\n            API.iplUnitySetPerspectiveCorrection(correction);\n        }\n\n        public override void Destroy()\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/UnityAudioEngineState.cs",
      "Content": "aultHRTF);\n            API.iplUnitySetSimulationSettings(simulationSettings);\n            API.iplUnitySetPerspectiveCorrection(correction);\n        }\n\n        public override void Destroy()\n        {\n            API.iplUnityTerminate();\n        }\n\n        public override void SetHRTF(IntPtr hrtf)\n        {\n            API.iplUnitySetHRTF(hrtf);\n        }\n\n        public override void SetPerspectiveCorrection(PerspectiveCorrection correction)\n        {\n            API.iplUnitySetPerspectiveCorrection(correction);\n        }\n\n        public override void SetReverbSource(Source reverbSource)\n        {\n            API.iplUnitySetReverbSource(reverbSource.Get());\n        }\n\n        public override void SetHRTFDisabled(bool disabled)\n        {\n            base.SetHRTFDisabled(disabled);\n\n            API.iplUnitySetHRTFDisabled(disabled);\n        }\n    }\n\n    public sealed class UnityAudioEngineStateHelpers : AudioEngineStateHelpers\n    {\n        public override Transform GetListenerTransform()\n        {\n#if UNITY_2023_3_OR_NEWER\n            var audioListener = GameObject.FindFirstObjectByType<AudioListener>();\n#else"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Runtime/UnityAudioEngineState.cs",
      "Content": "tateHelpers\n    {\n        public override Transform GetListenerTransform()\n        {\n#if UNITY_2023_3_OR_NEWER\n            var audioListener = GameObject.FindFirstObjectByType<AudioListener>();\n#else\n            var audioListener = GameObject.FindObjectOfType<AudioListener>();\n#endif\n            return (audioListener != null) ? audioListener.transform : null;\n        }\n\n        public override AudioSettings GetAudioSettings()\n        {\n            var audioSettings = new AudioSettings { };\n\n            audioSettings.samplingRate = UnityEngine.AudioSettings.outputSampleRate;\n\n            var numBuffers = 0;\n            UnityEngine.AudioSettings.GetDSPBufferSize(out audioSettings.frameSize, out numBuffers);\n\n            return audioSettings;\n        }\n    }\n}\n\n#endif"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/Build.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing System;\nusing UnityEngine; // deleteme?\nusing UnityEditor;\n#if UNITY_2021_2_OR_NEWER\nusing UnityEditor.Build;\n#endif\nusing UnityEditor.Callbacks;\n#if UNITY_IOS\nusing UnityEditor.iOS.Xcode;\n#endif\n\nnamespace SteamAudio\n{\n    public static class Build\n    {\n        public static void BuildSteamAudio()\n        {\n            var baseAssets = new string[]\n            {\n                \"Assets/Plugins/SteamAudio/SteamAudioUnity.asmdef\",\n                \"Assets/Plugins/SteamAudio/Binaries\",\n                \"Assets/Plugins/SteamAudio/Resources\","
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/Build.cs",
      "Content": "string[]\n            {\n                \"Assets/Plugins/SteamAudio/SteamAudioUnity.asmdef\",\n                \"Assets/Plugins/SteamAudio/Binaries\",\n                \"Assets/Plugins/SteamAudio/Resources\",\n                \"Assets/Plugins/SteamAudio/Scripts/Runtime\",\n                \"Assets/Plugins/SteamAudio/Scripts/Editor\",\n            };\n\n\n            var fmodAssets = new string[]\n            {\n                \"Assets/Plugins/SteamAudio/Scripts/FMODStudio\",\n                \"Assets/Plugins/FMOD/platforms/win/lib/x86/phonon_fmod.dll\",\n                \"Assets/Plugins/FMOD/platforms/win/lib/x86_64/phonon_fmod.dll\",\n                \"Assets/Plugins/FMOD/platforms/linux/lib/x86/libphonon_fmod.so\",\n                \"Assets/Plugins/FMOD/platforms/linux/lib/x86_64/libphonon_fmod.so\",\n                \"Assets/Plugins/FMOD/platforms/mac/lib/phonon_fmod.bundle\",\n                \"Assets/Plugins/FMOD/platforms/android/lib/armeabi-v7a/libphonon_fmod.so\",\n                \"Assets/Plugins/FMOD/platforms/android/lib/arm64-v8a/libphonon_fmod.so\",\n                \"Assets/Plugins/FMOD/platforms/android/lib/x86/libphonon_fmod.so\",\n                \"Assets/Plugins/FMOD/platforms/ios/lib/libphonon_fmod.a\","
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/Build.cs",
      "Content": "/android/lib/arm64-v8a/libphonon_fmod.so\",\n                \"Assets/Plugins/FMOD/platforms/android/lib/x86/libphonon_fmod.so\",\n                \"Assets/Plugins/FMOD/platforms/ios/lib/libphonon_fmod.a\",\n            };\n\n            var wwiseAssets = new string[]\n            {\n                \"Assets/Plugins/SteamAudio/Scripts/Wwise\",\n                \"Assets/Wwise/API/Runtime/Plugins/Windows/x86/DSP/SteamAudioWwise.dll\",\n                \"Assets/Wwise/API/Runtime/Plugins/Windows/x86_64/DSP/SteamAudioWwise.dll\",\n                \"Assets/Wwise/API/Runtime/Plugins/Linux/x86_64/DSP/libSteamAudioWwise.so\",\n                \"Assets/Wwise/API/Runtime/Plugins/Mac/DSP/libSteamAudioWwise.bundle\",\n                \"Assets/Wwise/API/Runtime/Plugins/Android/armeabi-v7a/DSP/libSteamAudioWwise.so\",\n                \"Assets/Wwise/API/Runtime/Plugins/Android/arm64-v8a/DSP/libSteamAudioWwise.so\",\n                \"Assets/Wwise/API/Runtime/Plugins/Android/x86/DSP/libSteamAudioWwise.so\",\n                \"Assets/Wwise/API/Runtime/Plugins/iOS/iphoneos/DSP/SteamAudioWwiseFXFactory.h\",\n                \"Assets/Wwise/API/Runtime/Plugins/iOS/iphoneos/DSP/libSteamAudioWwiseFX.a\","
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/Build.cs",
      "Content": "oWwise.so\",\n                \"Assets/Wwise/API/Runtime/Plugins/iOS/iphoneos/DSP/SteamAudioWwiseFXFactory.h\",\n                \"Assets/Wwise/API/Runtime/Plugins/iOS/iphoneos/DSP/libSteamAudioWwiseFX.a\",\n                \"Assets/Wwise/API/Runtime/Plugins/iOS/iphonesimulator/DSP/SteamAudioWwiseFXFactory.h\",\n                \"Assets/Wwise/API/Runtime/Plugins/iOS/iphonesimulator/DSP/libSteamAudioWwiseFX.a\",\n            };\n\n            BuildPackage(\"SteamAudio\", baseAssets);\n            BuildPackage(\"SteamAudioFMODStudio\", fmodAssets);\n            BuildPackage(\"SteamAudioWwise\", wwiseAssets);\n        }\n\n        private static void BuildPackage(string name, string[] assets)\n        {\n            var args = Environment.GetCommandLineArgs();\n            var lastArg = args[args.Length - 1];\n\n            var fileName = name + \".unitypackage\";\n            if (lastArg != \"SteamAudio.Build.BuildSteamAudio\")\n            {\n                fileName = lastArg + \"/\" + fileName;\n            }\n\n            AssetDatabase.ExportPackage(assets, fileName, ExportPackageOptions.Recurse);\n        }\n    }\n\n    [InitializeOnLoad]\n    public static class Defines\n    {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/Build.cs",
      "Content": "+ \"/\" + fileName;\n            }\n\n            AssetDatabase.ExportPackage(assets, fileName, ExportPackageOptions.Recurse);\n        }\n    }\n\n    [InitializeOnLoad]\n    public static class Defines\n    {\n        // Define the constant STEAMAUDIO_ENABLED for all platforms that are supported by\n        // Steam Audio. User scripts should check if this constant is defined\n        // (using #if STEAMAUDIO_ENABLED) before using any of the Steam Audio C# classes.\n        static Defines()\n        {\n#if UNITY_2021_2_OR_NEWER\n            NamedBuildTarget[] supportedPlatforms = {\n                NamedBuildTarget.Standalone,\n                NamedBuildTarget.Android,\n                NamedBuildTarget.iOS,\n                NamedBuildTarget.WebGL,\n            };\n\n            foreach (var supportedPlatform in supportedPlatforms)\n            {\n                var defines = PlayerSettings.GetScriptingDefineSymbols(supportedPlatform);\n                if (!defines.Contains(\"STEAMAUDIO_ENABLED\"))\n                {\n                    if (defines.Length > 0)\n                    {\n                        defines += \";\";\n                    }\n\n                    defines += \"STEAMAUDIO_ENABLED\";"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/Build.cs",
      "Content": "{\n                    if (defines.Length > 0)\n                    {\n                        defines += \";\";\n                    }\n\n                    defines += \"STEAMAUDIO_ENABLED\";\n\n                    PlayerSettings.SetScriptingDefineSymbols(supportedPlatform, defines);\n                }\n            }\n#endif\n        }\n    }\n\n    public static class BuildProcessor\n    {\n        [PostProcessBuild]\n        public static void OnPostProcessBuild(BuildTarget buildTarget, string buildPath)\n        {\n            if (buildTarget == BuildTarget.iOS)\n            {\n#if UNITY_IOS\n                var projectPath = PBXProject.GetPBXProjectPath(buildPath);\n\n                var project = new PBXProject();\n                project.ReadFromFile(projectPath);\n\n                var file = project.AddFile(\"usr/lib/libz.tbd\", \"Frameworks/libz.tbd\", PBXSourceTree.Sdk);\n                var target = project.TargetGuidByName(\"UnityFramework\");\n                project.AddFileToBuild(target, file);\n\n                project.WriteToFile(projectPath);\n#endif\n            }\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SOFAFileEditor.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEditor;\n\nnamespace SteamAudio\n{\n    /*\n     * Custom editor GUI for SOFAFile assets.\n     */\n    [CustomEditor(typeof(SOFAFile))]\n    public class SOFAFileEditor : Editor\n    {\n        public override void OnInspectorGUI()\n        {\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"sofaName\"));\n            EditorGUILayout.LabelField(\"Size\", Common.HumanReadableDataSize(serializedObject.FindProperty(\"data\").arraySize));\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SOFAFileImporter.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing System.IO;\nusing UnityEngine;\n#if UNITY_2020_2_OR_NEWER\nusing UnityEditor.AssetImporters;\n#else\nusing UnityEditor.Experimental.AssetImporters;\n#endif\n\nnamespace SteamAudio\n{\n    /*\n     * Imports .sofa files as SOFAFile asset objects.\n     */\n    [ScriptedImporter(2, \"sofa\")]\n    public class SOFAFileImporter : ScriptedImporter\n    {\n        [Range(-12.0f, 12.0f)]\n        public float hrtfVolumeGainDB = 0.0f;\n        public HRTFNormType hrtfNormalizationType = HRTFNormType.None;\n\n        public override void OnImportAsset(AssetImportContext ctx)\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SOFAFileImporter.cs",
      "Content": "0f)]\n        public float hrtfVolumeGainDB = 0.0f;\n        public HRTFNormType hrtfNormalizationType = HRTFNormType.None;\n\n        public override void OnImportAsset(AssetImportContext ctx)\n        {\n            var sofaFile = ScriptableObject.CreateInstance<SOFAFile>();\n\n            sofaFile.sofaName = Path.GetFileName(ctx.assetPath);\n            sofaFile.data = File.ReadAllBytes(ctx.assetPath);\n            sofaFile.volume = hrtfVolumeGainDB;\n            sofaFile.normType = hrtfNormalizationType;\n\n            ctx.AddObjectToAsset(\"sofa file\", sofaFile);\n            ctx.SetMainObject(sofaFile);\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SOFAFileImporterEditor.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEditor;\n#if UNITY_2020_2_OR_NEWER\nusing UnityEditor.AssetImporters;\n#else\nusing UnityEditor.Experimental.AssetImporters;\n#endif\n\nnamespace SteamAudio\n{\n    /*\n     * Custom editor GUI for SOFAFile import settings.\n     */\n    [CustomEditor(typeof(SOFAFileImporter))]\n    public class SOFAFileImporterEditor : ScriptedImporterEditor\n    {\n        public override void OnInspectorGUI()\n        {\n            serializedObject.Update();\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"hrtfVolumeGainDB\"), new UnityEngine.GUIContent(\"HRTF Volume Gain (dB)\"));"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SOFAFileImporterEditor.cs",
      "Content": "I()\n        {\n            serializedObject.Update();\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"hrtfVolumeGainDB\"), new UnityEngine.GUIContent(\"HRTF Volume Gain (dB)\"));\n            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"hrtfNormalizationType\"), new UnityEngine.GUIContent(\"HRTF Normalization Type\"));\n            serializedObject.ApplyModifiedProperties();\n            ApplyRevertGUI();\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SerializedDataInspector.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEditor;\n\nnamespace SteamAudio\n{\n    [CustomEditor(typeof(SerializedData))]\n    public class SerializedDataInspector : Editor\n    {\n        SerializedProperty mData;\n\n        private void OnEnable()\n        {\n            mData = serializedObject.FindProperty(\"data\");\n        }\n\n        public override void OnInspectorGUI()\n        {\n            serializedObject.Update();\n\n            var size = mData.arraySize;\n            EditorGUILayout.LabelField(\"Serialized Data\", Common.HumanReadableDataSize(size));\n\n            serializedObject.ApplyModifiedProperties();\n        }\n    }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SerializedDataInspector.cs",
      "Content": "var size = mData.arraySize;\n            EditorGUILayout.LabelField(\"Serialized Data\", Common.HumanReadableDataSize(size));\n\n            serializedObject.ApplyModifiedProperties();\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioAmbisonicSourceInspector.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEditor;\n\nnamespace SteamAudio\n{\n    [CustomEditor(typeof(SteamAudioAmbisonicSource))]\n    [CanEditMultipleObjects]\n    public class SteamAudioAmbisonicSourceInspector : Editor\n    {\n        SerializedProperty mApplyHRTF;\n\n        private void OnEnable()\n        {\n            mApplyHRTF = serializedObject.FindProperty(\"applyHRTF\");\n        }\n\n        public override void OnInspectorGUI()\n        {\n            if (SteamAudioSettings.Singleton.audioEngine != AudioEngineType.Unity)\n            {\n                EditorGUILayout.HelpBox("
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioAmbisonicSourceInspector.cs",
      "Content": "}\n\n        public override void OnInspectorGUI()\n        {\n            if (SteamAudioSettings.Singleton.audioEngine != AudioEngineType.Unity)\n            {\n                EditorGUILayout.HelpBox(\n                    \"This component requires the audio engine to be set to Unity. Click\" +\n                    \"Steam Audio > Settings to change this.\", MessageType.Warning);\n\n                return;\n            }\n\n            serializedObject.Update();\n\n            EditorGUILayout.PropertyField(mApplyHRTF);\n\n            serializedObject.ApplyModifiedProperties();\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioBakedListenerInspector.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEngine;\nusing UnityEditor;\n\nnamespace SteamAudio\n{\n    [CustomEditor(typeof(SteamAudioBakedListener))]\n    public class SteamAudioBakedListenerInspector : Editor\n    {\n#if STEAMAUDIO_ENABLED\n        SerializedProperty mInfluenceRadius;\n        SerializedProperty mUseAllProbeBatches;\n        SerializedProperty mProbeBatches;\n\n        bool mStatsFoldout = false;\n        bool mShouldShowProgressBar = false;\n\n        private void OnEnable()\n        {\n            mInfluenceRadius = serializedObject.FindProperty(\"influenceRadius\");"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioBakedListenerInspector.cs",
      "Content": "bool mStatsFoldout = false;\n        bool mShouldShowProgressBar = false;\n\n        private void OnEnable()\n        {\n            mInfluenceRadius = serializedObject.FindProperty(\"influenceRadius\");\n            mUseAllProbeBatches = serializedObject.FindProperty(\"useAllProbeBatches\");\n            mProbeBatches = serializedObject.FindProperty(\"probeBatches\");\n        }\n\n        public override void OnInspectorGUI()\n        {\n            serializedObject.Update();\n\n            var oldGUIEnabled = GUI.enabled;\n            GUI.enabled = !Baker.IsBakeActive() && !EditorApplication.isPlayingOrWillChangePlaymode;\n\n            var tgt = target as SteamAudioBakedListener;\n\n            EditorGUILayout.PropertyField(mInfluenceRadius);\n            EditorGUILayout.PropertyField(mUseAllProbeBatches);\n            if (!mUseAllProbeBatches.boolValue)\n            {\n                EditorGUILayout.PropertyField(mProbeBatches);\n            }\n\n            EditorGUILayout.Space();\n            if (GUILayout.Button(\"Bake\"))\n            {\n                tgt.BeginBake();\n                mShouldShowProgressBar = true;\n            }\n\n            GUI.enabled = oldGUIEnabled;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioBakedListenerInspector.cs",
      "Content": "ace();\n            if (GUILayout.Button(\"Bake\"))\n            {\n                tgt.BeginBake();\n                mShouldShowProgressBar = true;\n            }\n\n            GUI.enabled = oldGUIEnabled;\n\n            if (mShouldShowProgressBar && !Baker.IsBakeActive())\n            {\n                mShouldShowProgressBar = false;\n            }\n\n            if (mShouldShowProgressBar)\n            {\n                Baker.DrawProgressBar();\n            }\n\n            Repaint();\n\n            EditorGUILayout.Space();\n            mStatsFoldout = EditorGUILayout.Foldout(mStatsFoldout, \"Baked Data Statistics\");\n            if (mStatsFoldout && !Baker.IsBakeActive())\n            {\n                for (var i = 0; i < tgt.GetProbeBatchesUsed().Length; ++i)\n                {\n                    EditorGUILayout.LabelField(tgt.GetProbeBatchesUsed()[i].gameObject.name, Common.HumanReadableDataSize(tgt.GetProbeDataSizes()[i]));\n                }\n                EditorGUILayout.LabelField(\"Total Size\", Common.HumanReadableDataSize(tgt.GetTotalDataSize()));\n            }\n\n            serializedObject.ApplyModifiedProperties();\n        }\n#else\n        public override void OnInspectorGUI()\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioBakedListenerInspector.cs",
      "Content": ", Common.HumanReadableDataSize(tgt.GetTotalDataSize()));\n            }\n\n            serializedObject.ApplyModifiedProperties();\n        }\n#else\n        public override void OnInspectorGUI()\n        {\n            EditorGUILayout.HelpBox(\"Steam Audio is not supported for the target platform or STEAMAUDIO_ENABLED define symbol is missing.\", MessageType.Warning);\n        }\n#endif\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioBakedSourceInspector.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEngine;\nusing UnityEditor;\n\nnamespace SteamAudio\n{\n    [CustomEditor(typeof(SteamAudioBakedSource))]\n    public class SteamAudioBakedSourceInspector : Editor\n    {\n#if STEAMAUDIO_ENABLED\n        SerializedProperty mInfluenceRadius;\n        SerializedProperty mUseAllProbeBatches;\n        SerializedProperty mProbeBatches;\n\n        bool mStatsFoldout = false;\n        bool mShouldShowProgressBar = false;\n\n        private void OnEnable()\n        {\n            mInfluenceRadius = serializedObject.FindProperty(\"influenceRadius\");"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioBakedSourceInspector.cs",
      "Content": "bool mStatsFoldout = false;\n        bool mShouldShowProgressBar = false;\n\n        private void OnEnable()\n        {\n            mInfluenceRadius = serializedObject.FindProperty(\"influenceRadius\");\n            mUseAllProbeBatches = serializedObject.FindProperty(\"useAllProbeBatches\");\n            mProbeBatches = serializedObject.FindProperty(\"probeBatches\");\n        }\n\n        public override void OnInspectorGUI()\n        {\n            serializedObject.Update();\n\n            var oldGUIEnabled = GUI.enabled;\n            GUI.enabled = !Baker.IsBakeActive() && !EditorApplication.isPlayingOrWillChangePlaymode;\n\n            var tgt = target as SteamAudioBakedSource;\n\n            EditorGUILayout.PropertyField(mInfluenceRadius);\n            EditorGUILayout.PropertyField(mUseAllProbeBatches);\n            if (!mUseAllProbeBatches.boolValue)\n            {\n                EditorGUILayout.PropertyField(mProbeBatches);\n            }\n\n            EditorGUILayout.Space();\n            if (GUILayout.Button(\"Bake\"))\n            {\n                tgt.BeginBake();\n                mShouldShowProgressBar = true;\n            }\n\n            GUI.enabled = oldGUIEnabled;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioBakedSourceInspector.cs",
      "Content": "ace();\n            if (GUILayout.Button(\"Bake\"))\n            {\n                tgt.BeginBake();\n                mShouldShowProgressBar = true;\n            }\n\n            GUI.enabled = oldGUIEnabled;\n\n            if (mShouldShowProgressBar && !Baker.IsBakeActive())\n            {\n                mShouldShowProgressBar = false;\n            }\n\n            if (mShouldShowProgressBar)\n            {\n                Baker.DrawProgressBar();\n            }\n\n            Repaint();\n\n            EditorGUILayout.Space();\n            mStatsFoldout = EditorGUILayout.Foldout(mStatsFoldout, \"Baked Data Statistics\");\n            if (mStatsFoldout && !Baker.IsBakeActive())\n            {\n                for (var i = 0; i < tgt.GetProbeBatchesUsed().Length; ++i)\n                {\n                    EditorGUILayout.LabelField(tgt.GetProbeBatchesUsed()[i].gameObject.name, Common.HumanReadableDataSize(tgt.GetProbeDataSizes()[i]));\n                }\n                EditorGUILayout.LabelField(\"Total Size\", Common.HumanReadableDataSize(tgt.GetTotalDataSize()));\n            }\n\n            serializedObject.ApplyModifiedProperties();\n        }\n#else\n        public override void OnInspectorGUI()\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioBakedSourceInspector.cs",
      "Content": ", Common.HumanReadableDataSize(tgt.GetTotalDataSize()));\n            }\n\n            serializedObject.ApplyModifiedProperties();\n        }\n#else\n        public override void OnInspectorGUI()\n        {\n            EditorGUILayout.HelpBox(\"Steam Audio is not supported for the target platform or STEAMAUDIO_ENABLED define symbol is missing.\", MessageType.Warning);\n        }\n#endif\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioDynamicObjectInspector.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEditor;\nusing UnityEditor.SceneManagement;\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n    [CustomEditor(typeof(SteamAudioDynamicObject))]\n    public class SteamAudioDynamicObjectInspector : Editor\n    {\n #if STEAMAUDIO_ENABLED\n        SerializedProperty mAsset;\n\n        private void OnEnable()\n        {\n            mAsset = serializedObject.FindProperty(\"asset\");\n        }\n\n        public override void OnInspectorGUI()\n        {\n            serializedObject.Update();\n\n            EditorGUILayout.PropertyField(mAsset);\n\n            if (mAsset.objectReferenceValue == null)"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioDynamicObjectInspector.cs",
      "Content": "public override void OnInspectorGUI()\n        {\n            serializedObject.Update();\n\n            EditorGUILayout.PropertyField(mAsset);\n\n            if (mAsset.objectReferenceValue == null)\n            {\n                EditorGUILayout.HelpBox(\n                    \"This Dynamic Object has not been exported to an asset yet. Please click Export Dynamic Object \" +\n                    \"to do so.\", MessageType.Warning);\n            }\n\n            EditorGUILayout.Space();\n\n            if (GUILayout.Button(\"Export Dynamic Object\"))\n            {\n                if (mAsset.objectReferenceValue == null)\n                {\n                    var name = (target as SteamAudioDynamicObject).gameObject.scene.name + \"_\" + target.name;\n                    mAsset.objectReferenceValue = SerializedData.PromptForNewAsset(name);\n                    serializedObject.ApplyModifiedProperties();\n                }\n\n                SteamAudioManager.ExportDynamicObject(target as SteamAudioDynamicObject, false);\n            }\n\n            if (GUILayout.Button(\"Export Dynamic Object as OBJ\"))\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioDynamicObjectInspector.cs",
      "Content": "}\n\n                SteamAudioManager.ExportDynamicObject(target as SteamAudioDynamicObject, false);\n            }\n\n            if (GUILayout.Button(\"Export Dynamic Object as OBJ\"))\n            {\n                SteamAudioManager.ExportDynamicObject(target as SteamAudioDynamicObject, true);\n            }\n\n            serializedObject.ApplyModifiedProperties();\n        }\n#else\n        public override void OnInspectorGUI()\n        {\n            EditorGUILayout.HelpBox(\"Steam Audio is not supported for the target platform or STEAMAUDIO_ENABLED define symbol is missing.\", MessageType.Warning);\n        }\n#endif\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioGeometryInspector.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEngine;\nusing UnityEditor;\n\nnamespace SteamAudio\n{\n    [CustomEditor(typeof(SteamAudioGeometry))]\n    [CanEditMultipleObjects]\n    public class SteamAudioGeometryInspector : Editor\n    {\n#if STEAMAUDIO_ENABLED\n        SerializedProperty mMaterial;\n        SerializedProperty mExportAllChildren;\n        SerializedProperty mTerrainSimplificationLevel;\n\n        private void OnEnable()\n        {\n            mMaterial = serializedObject.FindProperty(\"material\");\n            mExportAllChildren = serializedObject.FindProperty(\"exportAllChildren\");"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioGeometryInspector.cs",
      "Content": "vel;\n\n        private void OnEnable()\n        {\n            mMaterial = serializedObject.FindProperty(\"material\");\n            mExportAllChildren = serializedObject.FindProperty(\"exportAllChildren\");\n            mTerrainSimplificationLevel = serializedObject.FindProperty(\"terrainSimplificationLevel\");\n        }\n\n        public override void OnInspectorGUI()\n        {\n            serializedObject.Update();\n\n            var tgt = target as SteamAudioGeometry;\n\n            EditorGUILayout.PropertyField(mMaterial);\n\n            if (tgt.transform.childCount != 0)\n            {\n                EditorGUILayout.PropertyField(mExportAllChildren);\n            }\n\n            if (tgt.gameObject.GetComponent<Terrain>() != null)\n            {\n                EditorGUILayout.PropertyField(mTerrainSimplificationLevel);\n            }\n\n            EditorGUILayout.Space();\n            EditorGUILayout.LabelField(\"Geometry Statistics\", EditorStyles.boldLabel);\n            EditorGUILayout.LabelField(\"Vertices\", tgt.GetNumVertices().ToString());\n            EditorGUILayout.LabelField(\"Triangles\", tgt.GetNumTriangles().ToString());\n\n            serializedObject.ApplyModifiedProperties();\n        }\n#else"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioGeometryInspector.cs",
      "Content": "ces\", tgt.GetNumVertices().ToString());\n            EditorGUILayout.LabelField(\"Triangles\", tgt.GetNumTriangles().ToString());\n\n            serializedObject.ApplyModifiedProperties();\n        }\n#else\n        public override void OnInspectorGUI()\n        {\n            EditorGUILayout.HelpBox(\"Steam Audio is not supported for the target platform or STEAMAUDIO_ENABLED define symbol is missing.\", MessageType.Warning);\n        }\n#endif\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioListenerInspector.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEngine;\nusing UnityEditor;\n\nnamespace SteamAudio\n{\n    [CustomEditor(typeof(SteamAudioListener))]\n    public class SteamAudioListenerInspector : Editor\n    {\n#if STEAMAUDIO_ENABLED\n        SerializedProperty mCurrentBakedListener;\n        SerializedProperty mApplyReverb;\n        SerializedProperty mReverbType;\n        SerializedProperty mUseAllProbeBatches;\n        SerializedProperty mProbeBatches;\n\n        bool mStatsFoldout = false;\n        bool mShouldShowProgressBar = false;\n\n        private void OnEnable()\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioListenerInspector.cs",
      "Content": "zedProperty mUseAllProbeBatches;\n        SerializedProperty mProbeBatches;\n\n        bool mStatsFoldout = false;\n        bool mShouldShowProgressBar = false;\n\n        private void OnEnable()\n        {\n            mCurrentBakedListener = serializedObject.FindProperty(\"currentBakedListener\");\n            mApplyReverb = serializedObject.FindProperty(\"applyReverb\");\n            mReverbType = serializedObject.FindProperty(\"reverbType\");\n            mUseAllProbeBatches = serializedObject.FindProperty(\"useAllProbeBatches\");\n            mProbeBatches = serializedObject.FindProperty(\"probeBatches\");\n        }\n\n        public override void OnInspectorGUI()\n        {\n            serializedObject.Update();\n\n            EditorGUILayout.PropertyField(mCurrentBakedListener);\n\n            EditorGUILayout.PropertyField(mApplyReverb);\n            if (mApplyReverb.boolValue)\n            {\n                EditorGUILayout.PropertyField(mReverbType);\n            }\n\n            var oldGUIEnabled = GUI.enabled;\n            GUI.enabled = !Baker.IsBakeActive() && !EditorApplication.isPlayingOrWillChangePlaymode;\n\n            var tgt = target as SteamAudioListener;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioListenerInspector.cs",
      "Content": "var oldGUIEnabled = GUI.enabled;\n            GUI.enabled = !Baker.IsBakeActive() && !EditorApplication.isPlayingOrWillChangePlaymode;\n\n            var tgt = target as SteamAudioListener;\n\n            EditorGUILayout.PropertyField(mUseAllProbeBatches);\n            if (!mUseAllProbeBatches.boolValue)\n            {\n                EditorGUILayout.PropertyField(mProbeBatches);\n            }\n\n            EditorGUILayout.Space();\n            if (GUILayout.Button(\"Bake\"))\n            {\n                tgt.BeginBake();\n                mShouldShowProgressBar = true;\n            }\n\n            GUI.enabled = oldGUIEnabled;\n\n            if (mShouldShowProgressBar && !Baker.IsBakeActive())\n            {\n                mShouldShowProgressBar = false;\n            }\n\n            if (mShouldShowProgressBar)\n            {\n                Baker.DrawProgressBar();\n            }\n\n            Repaint();\n\n            EditorGUILayout.Space();\n            mStatsFoldout = EditorGUILayout.Foldout(mStatsFoldout, \"Baked Data Statistics\");\n            if (mStatsFoldout && !Baker.IsBakeActive())\n            {\n                for (var i = 0; i < tgt.GetProbeBatchesUsed().Length; ++i)"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioListenerInspector.cs",
      "Content": "ayout.Foldout(mStatsFoldout, \"Baked Data Statistics\");\n            if (mStatsFoldout && !Baker.IsBakeActive())\n            {\n                for (var i = 0; i < tgt.GetProbeBatchesUsed().Length; ++i)\n                {\n                    EditorGUILayout.LabelField(tgt.GetProbeBatchesUsed()[i].gameObject.name, Common.HumanReadableDataSize(tgt.GetProbeDataSizes()[i]));\n                }\n                EditorGUILayout.LabelField(\"Total Size\", Common.HumanReadableDataSize(tgt.GetTotalDataSize()));\n            }\n\n            serializedObject.ApplyModifiedProperties();\n        }\n#else\n        public override void OnInspectorGUI()\n        {\n            EditorGUILayout.HelpBox(\"Steam Audio is not supported for the target platform or STEAMAUDIO_ENABLED define symbol is missing.\", MessageType.Warning);\n        }\n#endif\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioManagerInspector.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEditor;\n\nnamespace SteamAudio\n{\n    [CustomEditor(typeof(SteamAudioManager))]\n    [CanEditMultipleObjects]\n    public class SteamAudioManagerInspector : Editor\n    {\n#if STEAMAUDIO_ENABLED\n        SerializedProperty mCurrentHRTF;\n\n        private void OnEnable()\n        {\n            mCurrentHRTF = serializedObject.FindProperty(\"currentHRTF\");\n        }\n\n        public override void OnInspectorGUI()\n        {\n            serializedObject.Update();\n\n            var tgt = target as SteamAudioManager;\n\n            EditorGUILayout.Space();"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioManagerInspector.cs",
      "Content": "\");\n        }\n\n        public override void OnInspectorGUI()\n        {\n            serializedObject.Update();\n\n            var tgt = target as SteamAudioManager;\n\n            EditorGUILayout.Space();\n            EditorGUILayout.LabelField(\"HRTF Settings\", EditorStyles.boldLabel);\n            mCurrentHRTF.intValue = EditorGUILayout.Popup(\"Current HRTF\", mCurrentHRTF.intValue, tgt.hrtfNames);\n\n            EditorGUILayout.Space();\n            EditorGUILayout.HelpBox(\n                \"This component should not be added manually to any GameObject. It is automatically created and\" +\n                \"destroyed by Steam Audio.\", MessageType.Warning);\n\n            serializedObject.ApplyModifiedProperties();\n        }\n#else\n        public override void OnInspectorGUI()\n        {\n            EditorGUILayout.HelpBox(\"Steam Audio is not supported for the target platform or STEAMAUDIO_ENABLED define symbol is missing.\", MessageType.Warning);\n        }\n#endif\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioMaterialInspector.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEditor;\n\nnamespace SteamAudio\n{\n    [CustomEditor(typeof(SteamAudioMaterial))]\n    [CanEditMultipleObjects]\n    public class SteamAudioMaterialInspector : Editor\n    {\n        SerializedProperty lowFreqAbsorption;\n        SerializedProperty midFreqAbsorption;\n        SerializedProperty highFreqAbsorption;\n        SerializedProperty scattering;\n        SerializedProperty lowFreqTransmission;\n        SerializedProperty midFreqTransmission;\n        SerializedProperty highFreqTransmission;\n\n        private void OnEnable()\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioMaterialInspector.cs",
      "Content": "scattering;\n        SerializedProperty lowFreqTransmission;\n        SerializedProperty midFreqTransmission;\n        SerializedProperty highFreqTransmission;\n\n        private void OnEnable()\n        {\n            lowFreqAbsorption = serializedObject.FindProperty(\"lowFreqAbsorption\");\n            midFreqAbsorption = serializedObject.FindProperty(\"midFreqAbsorption\");\n            highFreqAbsorption = serializedObject.FindProperty(\"highFreqAbsorption\");\n            scattering = serializedObject.FindProperty(\"scattering\");\n            lowFreqTransmission = serializedObject.FindProperty(\"lowFreqTransmission\");\n            midFreqTransmission = serializedObject.FindProperty(\"midFreqTransmission\");\n            highFreqTransmission = serializedObject.FindProperty(\"highFreqTransmission\");\n        }\n\n        public override void OnInspectorGUI()\n        {\n            serializedObject.Update();\n\n            EditorGUILayout.PropertyField(lowFreqAbsorption);\n            EditorGUILayout.PropertyField(midFreqAbsorption);\n            EditorGUILayout.PropertyField(highFreqAbsorption);\n            EditorGUILayout.PropertyField(scattering);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioMaterialInspector.cs",
      "Content": "lowFreqAbsorption);\n            EditorGUILayout.PropertyField(midFreqAbsorption);\n            EditorGUILayout.PropertyField(highFreqAbsorption);\n            EditorGUILayout.PropertyField(scattering);\n            EditorGUILayout.PropertyField(lowFreqTransmission);\n            EditorGUILayout.PropertyField(midFreqTransmission);\n            EditorGUILayout.PropertyField(highFreqTransmission);\n\n            serializedObject.ApplyModifiedProperties();\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioMixerReturnGUI.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEngine;\nusing UnityEditor;\n\nnamespace SteamAudio\n{\n    public class SteamAudioMixerReturnGUI : IAudioEffectPluginGUI\n    {\n        public override string Name\n        {\n            get\n            {\n                return \"Steam Audio Mixer Return\";\n            }\n        }\n\n        public override string Vendor\n        {\n            get\n            {\n                return \"Valve Corporation\";\n            }\n        }\n\n        public override string Description\n        {\n            get\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioMixerReturnGUI.cs",
      "Content": "Vendor\n        {\n            get\n            {\n                return \"Valve Corporation\";\n            }\n        }\n\n        public override string Description\n        {\n            get\n            {\n                return \"Enables accelerated mixing of reflections for sources spatialized using Steam Audio.\";\n            }\n        }\n\n        public override bool OnGUI(IAudioEffectPlugin plugin)\n        {\n            if (SteamAudioSettings.Singleton.audioEngine != AudioEngineType.Unity)\n            {\n                EditorGUILayout.HelpBox(\n                    \"This Audio Mixer effect requires the audio engine to be set to Unity. Click\" +\n                    \"Steam Audio > Settings to change this.\", MessageType.Warning);\n\n                return false;\n            }\n\n            var binauralValue = 0.0f;\n\n            plugin.GetFloatParameter(\"Binaural\", out binauralValue);\n\n            var binaural = (binauralValue == 1.0f);\n\n            binaural = EditorGUILayout.Toggle(\"Apply HRTF\", binaural);\n\n            binauralValue = (binaural) ? 1.0f : 0.0f;\n\n            plugin.SetFloatParameter(\"Binaural\", binauralValue);\n\n            return false;\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioProbeBatchInspector.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEngine;\nusing UnityEngine.SceneManagement;\nusing UnityEditor;\nusing UnityEditor.SceneManagement;\n\nnamespace SteamAudio\n{\n    [CustomEditor(typeof(SteamAudioProbeBatch))]\n    public class SteamAudioProbeBatchInspector : Editor\n    {\n#if STEAMAUDIO_ENABLED\n        SerializedProperty mPlacementStrategy;\n        SerializedProperty mHorizontalSpacing;\n        SerializedProperty mHeightAboveFloor;\n        SerializedProperty mAsset;\n\n        bool mShouldShowProgressBar = false;\n\n        private void OnEnable()\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioProbeBatchInspector.cs",
      "Content": "dProperty mHorizontalSpacing;\n        SerializedProperty mHeightAboveFloor;\n        SerializedProperty mAsset;\n\n        bool mShouldShowProgressBar = false;\n\n        private void OnEnable()\n        {\n            mPlacementStrategy = serializedObject.FindProperty(\"placementStrategy\");\n            mHorizontalSpacing = serializedObject.FindProperty(\"horizontalSpacing\");\n            mHeightAboveFloor = serializedObject.FindProperty(\"heightAboveFloor\");\n            mAsset = serializedObject.FindProperty(\"asset\");\n        }\n\n        public override void OnInspectorGUI()\n        {\n            serializedObject.Update();\n\n            var oldGUIEnabled = GUI.enabled;\n            GUI.enabled = !Baker.IsBakeActive() && !EditorApplication.isPlayingOrWillChangePlaymode;\n\n            var tgt = target as SteamAudioProbeBatch;\n\n            EditorGUILayout.PropertyField(mAsset);\n\n            EditorGUILayout.PropertyField(mPlacementStrategy);\n            if ((ProbeGenerationType) mPlacementStrategy.enumValueIndex == ProbeGenerationType.UniformFloor)\n            {\n                EditorGUILayout.PropertyField(mHorizontalSpacing);\n                EditorGUILayout.PropertyField(mHeightAboveFloor);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioProbeBatchInspector.cs",
      "Content": ".enumValueIndex == ProbeGenerationType.UniformFloor)\n            {\n                EditorGUILayout.PropertyField(mHorizontalSpacing);\n                EditorGUILayout.PropertyField(mHeightAboveFloor);\n            }\n\n            EditorGUILayout.Space();\n            if (GUILayout.Button(\"Generate Probes\"))\n            {\n                tgt.GenerateProbes();\n                EditorSceneManager.MarkSceneDirty(SceneManager.GetActiveScene());\n            }\n\n            if (tgt.GetNumProbes() > 0)\n            {\n                EditorGUILayout.Space();\n                EditorGUILayout.LabelField(\"Baked Pathing Settings\", EditorStyles.boldLabel);\n                if (GUILayout.Button(\"Bake\"))\n                {\n                    tgt.BeginBake();\n                    mShouldShowProgressBar = true;\n                }\n            }\n\n            GUI.enabled = oldGUIEnabled;\n\n            if (mShouldShowProgressBar && !Baker.IsBakeActive())\n            {\n                mShouldShowProgressBar = false;\n            }\n\n            if (mShouldShowProgressBar)\n            {\n                Baker.DrawProgressBar();\n            }\n\n            Repaint();\n\n            if (tgt.GetNumProbes() > 0)\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioProbeBatchInspector.cs",
      "Content": "}\n\n            if (mShouldShowProgressBar)\n            {\n                Baker.DrawProgressBar();\n            }\n\n            Repaint();\n\n            if (tgt.GetNumProbes() > 0)\n            {\n                EditorGUILayout.Space();\n                EditorGUILayout.LabelField(\"Probe Statistics\", EditorStyles.boldLabel);\n                EditorGUILayout.LabelField(\"Probes\", tgt.GetNumProbes().ToString());\n                EditorGUILayout.LabelField(\"Data Size\", Common.HumanReadableDataSize(tgt.probeDataSize));\n\n                if (tgt.GetNumLayers() > 0)\n                {\n                    EditorGUILayout.Space();\n                    EditorGUILayout.LabelField(\"Detailed Statistics\", EditorStyles.boldLabel);\n                    for (var i = 0; i < tgt.GetNumLayers(); ++i)\n                    {\n                        var layerInfo = tgt.GetInfoForLayer(i);\n\n                        var name = \"\";\n                        if (layerInfo.identifier.type == BakedDataType.Pathing)\n                        {\n                            name = \"Pathing\";\n                        }\n                        else if (layerInfo.identifier.variation == BakedDataVariation.Reverb)"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioProbeBatchInspector.cs",
      "Content": "athing)\n                        {\n                            name = \"Pathing\";\n                        }\n                        else if (layerInfo.identifier.variation == BakedDataVariation.Reverb)\n                        {\n                            name = \"Reverb\";\n                        }\n                        else\n                        {\n                            name = layerInfo.gameObject.name;\n                        }\n\n                        EditorGUILayout.BeginHorizontal();\n                        EditorGUILayout.LabelField(name, Common.HumanReadableDataSize(layerInfo.dataSize));\n                        if (GUILayout.Button(\"Clear\"))\n                        {\n                            tgt.DeleteBakedDataForIdentifier(layerInfo.identifier);\n                            EditorSceneManager.MarkSceneDirty(SceneManager.GetActiveScene());\n                        }\n                        EditorGUILayout.EndHorizontal();\n                    }\n                }\n            }\n\n            serializedObject.ApplyModifiedProperties();\n        }\n#else\n        public override void OnInspectorGUI()\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioProbeBatchInspector.cs",
      "Content": "EndHorizontal();\n                    }\n                }\n            }\n\n            serializedObject.ApplyModifiedProperties();\n        }\n#else\n        public override void OnInspectorGUI()\n        {\n            EditorGUILayout.HelpBox(\"Steam Audio is not supported for the target platform or STEAMAUDIO_ENABLED define symbol is missing.\", MessageType.Warning);\n        }\n#endif\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioReverbDataEditor.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing System.Data;\nusing System.Linq;\nusing UnityEditor;\nusing UnityEngine;\n\nnamespace SteamAudio\n{\n\n    [CustomEditor(typeof(SteamAudioReverbData)), CanEditMultipleObjects]\n    public class ReverbDataEditor : Editor\n    {\n        private string mReverbTimeFoldoutKey = \"SteamAudioProbeInspector_ReverbTimeFoldoutState\";\n        private string mEnergyFieldFoldoutKey = \"SteamAudioProbeInspector_EnergyFieldFoldoutState\";\n        private string mImpulseResponseFoldoutKey = \"SteamAudioProbeInspector_ImpulseResponseFoldoutState\";"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioReverbDataEditor.cs",
      "Content": "private string mEnergyFieldFoldoutKey = \"SteamAudioProbeInspector_EnergyFieldFoldoutState\";\n        private string mImpulseResponseFoldoutKey = \"SteamAudioProbeInspector_ImpulseResponseFoldoutState\";\n        public bool mOwnerIsMultiEditing = false; // Typically set by parent.\n\n\n        public override void OnInspectorGUI()\n        {\n            var tgt = target as SteamAudioReverbData;\n            bool bReverbTimesFoldoutExpanded = SessionState.GetBool(mReverbTimeFoldoutKey, false);\n            bReverbTimesFoldoutExpanded = EditorGUILayout.BeginFoldoutHeaderGroup(bReverbTimesFoldoutExpanded, \"Reverb Times\");\n            if (bReverbTimesFoldoutExpanded)\n            {\n                if (serializedObject.isEditingMultipleObjects | mOwnerIsMultiEditing)\n                {\n                    EditorGUILayout.HelpBox(\"Multiple objects selected.\", MessageType.Info);\n                }\n                else if (tgt.reverbTimes == null || tgt.reverbTimes.Length == 0)\n                {\n                    EditorGUILayout.HelpBox(\"No reverb time data to display.\", MessageType.Info);\n                }\n                else\n                {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioReverbDataEditor.cs",
      "Content": "t.reverbTimes.Length == 0)\n                {\n                    EditorGUILayout.HelpBox(\"No reverb time data to display.\", MessageType.Info);\n                }\n                else\n                {\n                    for (int i = 0; i < tgt.reverbTimes.Length; ++i)\n                    {\n                        EditorGUILayout.LabelField(\"Band \" + i + \" (seconds)\", tgt.reverbTimes[i].ToString(\"0.000\"));\n                    }\n                }\n            }\n            EditorGUILayout.EndFoldoutHeaderGroup();\n            SessionState.SetBool(mReverbTimeFoldoutKey, bReverbTimesFoldoutExpanded);\n\n            EditorGUILayout.Space();\n            bool bEnergyFieldFoldoutExpanded = SessionState.GetBool(mEnergyFieldFoldoutKey, false);\n            bEnergyFieldFoldoutExpanded = EditorGUILayout.BeginFoldoutHeaderGroup(bEnergyFieldFoldoutExpanded, \"Reverb Energy Field Stats\");\n            if (bEnergyFieldFoldoutExpanded)\n            {\n                if (serializedObject.isEditingMultipleObjects || mOwnerIsMultiEditing)\n                {\n                    EditorGUILayout.HelpBox(\"Multiple objects selected.\", MessageType.Info);\n                }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioReverbDataEditor.cs",
      "Content": "if (serializedObject.isEditingMultipleObjects || mOwnerIsMultiEditing)\n                {\n                    EditorGUILayout.HelpBox(\"Multiple objects selected.\", MessageType.Info);\n                }\n                else if (tgt.reverbEnergyField == null || tgt.reverbEnergyField.Length == 0)\n                {\n                    EditorGUILayout.HelpBox(\"No energy field data to display.\", MessageType.Info);\n                }\n                else\n                {\n                    string sampleCountString = tgt.reverbEnergyField.Length.ToString();\n                    sampleCountString += \" (\" + tgt.reverbEnergyFieldNumChannels + (tgt.reverbEnergyFieldNumChannels > 1 ? \" channels\" : \" channel\");\n                    sampleCountString += \" x \" + tgt.reverbEnergyFieldNumBands + \" bands\";\n                    sampleCountString += \" x \" + tgt.reverbEnergyFieldNumBins + \" bins)\";\n                    EditorGUILayout.LabelField(\"Sample Count\", sampleCountString);\n                    EditorGUILayout.LabelField(\"Total Size\", Common.HumanReadableDataSize(tgt.GetEnergyFieldSize()));\n\n                    int numChannels = tgt.reverbEnergyFieldNumChannels;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioReverbDataEditor.cs",
      "Content": "String);\n                    EditorGUILayout.LabelField(\"Total Size\", Common.HumanReadableDataSize(tgt.GetEnergyFieldSize()));\n\n                    int numChannels = tgt.reverbEnergyFieldNumChannels;\n                    int numBands = tgt.reverbEnergyFieldNumBands;\n                    int numSamples = tgt.reverbEnergyFieldNumBins;\n                    float[] channelEnergy = new float[numChannels];\n                    for (int i = 0; i < numChannels; ++i)\n                    {\n                        channelEnergy[i] = .0f;\n                        for (int j = 0; j < numBands; ++j)\n                        {\n                            for (int k = 0; k < numSamples; ++k)\n                            {\n                                channelEnergy[i] += tgt.GetEnergyFieldData(i, j, k);\n                            }\n                        }\n                    }\n                    EditorGUILayout.LabelField(\"Per Channel Energy\", string.Join(\", \", channelEnergy.Select(value => value.ToString(\"e2\"))));\n                }\n            }\n            EditorGUILayout.EndFoldoutHeaderGroup();\n            SessionState.SetBool(mEnergyFieldFoldoutKey, bEnergyFieldFoldoutExpanded);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioReverbDataEditor.cs",
      "Content": "> value.ToString(\"e2\"))));\n                }\n            }\n            EditorGUILayout.EndFoldoutHeaderGroup();\n            SessionState.SetBool(mEnergyFieldFoldoutKey, bEnergyFieldFoldoutExpanded);\n\n            EditorGUILayout.Space();\n            bool bImpulseResponseFoldoutExpanded = SessionState.GetBool(mImpulseResponseFoldoutKey, false);\n            bImpulseResponseFoldoutExpanded = EditorGUILayout.BeginFoldoutHeaderGroup(bImpulseResponseFoldoutExpanded, \"Reverb Impulse Response Stats\");\n            if (bImpulseResponseFoldoutExpanded)\n            {\n                if (serializedObject.isEditingMultipleObjects || mOwnerIsMultiEditing)\n                {\n                    EditorGUILayout.HelpBox(\"Multiple objects selected.\", MessageType.Info);\n                }\n                else if (tgt.reverbIR == null || tgt.reverbIR.Length == 0)\n                {\n                    EditorGUILayout.HelpBox(\"No impulse response data to display.\", MessageType.Info);\n                }\n                else\n                {\n                    string sampleCountString = tgt.reverbIR.Length.ToString();"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioReverbDataEditor.cs",
      "Content": "pBox(\"No impulse response data to display.\", MessageType.Info);\n                }\n                else\n                {\n                    string sampleCountString = tgt.reverbIR.Length.ToString();\n                    sampleCountString += \" (\" + tgt.reverbIRNumChannels + (tgt.reverbIRNumChannels > 1 ? \" channels\" : \" channel\");\n                    sampleCountString += \" x \" + tgt.reverbIRNumSamples + \" samples)\";\n                    EditorGUILayout.LabelField(\"Sample Count\", sampleCountString);\n                    EditorGUILayout.LabelField(\"Total Size\", Common.HumanReadableDataSize(tgt.GetImpulseResponseSize()));\n\n                    int numChannels = tgt.reverbIRNumChannels;\n                    int numSamples = tgt.reverbIRNumSamples;\n                    float[] channelMax = new float[numChannels];\n                    float[] channelMin = new float[numChannels];\n                    for (int i = 0; i < numChannels; ++i)\n                    {\n                        channelMax[i] = float.MinValue;\n                        channelMin[i] = float.MaxValue;\n                        for (int k = 0; k < numSamples; ++k)\n                        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioReverbDataEditor.cs",
      "Content": "channelMax[i] = float.MinValue;\n                        channelMin[i] = float.MaxValue;\n                        for (int k = 0; k < numSamples; ++k)\n                        {\n                            channelMax[i] = Mathf.Max(tgt.GetImpulseResponseData(i, k), channelMax[i]);\n                            channelMin[i] = Mathf.Min(tgt.GetImpulseResponseData(i, k), channelMin[i]);\n                        }\n                    }\n\n                    EditorGUILayout.LabelField(\"Per Channel Min\", string.Join(\", \", channelMin.Select(value => value.ToString(\"e2\"))));\n                    EditorGUILayout.LabelField(\"Per Channel Max\", string.Join(\", \", channelMax.Select(value => value.ToString(\"e2\"))));\n                }\n            }\n            EditorGUILayout.EndFoldoutHeaderGroup();\n            SessionState.SetBool(mImpulseResponseFoldoutKey, bImpulseResponseFoldoutExpanded);\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioReverbDataPointInspector.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEngine;\nusing UnityEngine.SceneManagement;\nusing UnityEditor;\nusing UnityEditor.SceneManagement;\nusing System.Linq;\nusing System.Data;\nusing System.Collections.Generic;\n\nnamespace SteamAudio\n{\n    [CustomEditor(typeof(SteamAudioReverbDataPoint)), CanEditMultipleObjects]\n    public class SteamAudioReverbDataPointInspector : Editor\n    {\n#if STEAMAUDIO_ENABLED\n        private int[] alllowedSampleRates = new int[] { 24000, 44100, 48000, 96000 };\n        private string[] displaySampleRates = new string[] { \"24000 Hz\", \"44100 Hz\", \"48000 Hz\", \"96000 Hz\" };"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioReverbDataPointInspector.cs",
      "Content": "ED\n        private int[] alllowedSampleRates = new int[] { 24000, 44100, 48000, 96000 };\n        private string[] displaySampleRates = new string[] { \"24000 Hz\", \"44100 Hz\", \"48000 Hz\", \"96000 Hz\" };\n        public SerializedProperty mSamplingRate;\n\n        public SerializedProperty mAmbisonicOrder;\n        public SerializedProperty mReverbDuration;\n        public SerializedProperty mReverbDataAsset;\n        public SerializedProperty mStoreEnergyField;\n        public SerializedProperty mStoreImpulseResponse;\n        private Editor mReverbDataEditor;\n\n        static bool mShouldShowProgressBar = false;\n\n        private void OnEnable()\n        {\n            mSamplingRate = serializedObject.FindProperty(\"sampleRate\");\n            mAmbisonicOrder = serializedObject.FindProperty(\"ambisonicOrder\");\n            mReverbDuration = serializedObject.FindProperty(\"reverbDuration\");\n            mReverbDataAsset = serializedObject.FindProperty(\"reverbData\");\n            mStoreEnergyField = serializedObject.FindProperty(\"storeEnergyField\");\n            mStoreImpulseResponse = serializedObject.FindProperty(\"storeImpulseResponse\");\n        }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioReverbDataPointInspector.cs",
      "Content": "\"reverbData\");\n            mStoreEnergyField = serializedObject.FindProperty(\"storeEnergyField\");\n            mStoreImpulseResponse = serializedObject.FindProperty(\"storeImpulseResponse\");\n        }\n\n        [MenuItem(\"GameObject/Steam Audio/Steam Audio Reverb Data Point\", false, 10)]\n        static void CreateGameObjectWithProbe(MenuCommand menuCommand)\n        {\n            var gameObject = new GameObject(\"Steam Audio Reverb Data Point\");\n            gameObject.AddComponent<SteamAudioReverbDataPoint>();\n\n            GameObjectUtility.SetParentAndAlign(gameObject, menuCommand.context as GameObject);\n\n            Undo.RegisterCreatedObjectUndo(gameObject, \"Create \" + gameObject.name);\n        }\n\n        [MenuItem(\"Steam Audio/Steam Audio Reverb Data Point/Bake All\", false, 61)]\n        public static void BakeAllProbes()\n        {\n            var allProbes = FindObjectsByType<SteamAudioReverbDataPoint>(FindObjectsSortMode.None);\n\n            if (allProbes.Length == 0)\n            {\n                EditorUtility.DisplayDialog(\"No Steam Audio Reverb Data Points Found\", \"No Steam Audio Reverb Data Point components were found in the currently-open scene.\", \"OK\");"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioReverbDataPointInspector.cs",
      "Content": "= 0)\n            {\n                EditorUtility.DisplayDialog(\"No Steam Audio Reverb Data Points Found\", \"No Steam Audio Reverb Data Point components were found in the currently-open scene.\", \"OK\");\n                return;\n            }\n\n            SteamAudioReverbDataPoint.BeginBake(allProbes);\n            mShouldShowProgressBar = true;\n            EditorSceneManager.MarkSceneDirty(SceneManager.GetActiveScene());\n        }\n\n        [MenuItem(\"Steam Audio/Steam Audio Reverb Data Point/Clear Unreferenced Data\", false, 62)]\n        public static void DeleteUnreferencedAssets()\n        {\n            AssetDatabase.StartAssetEditing();\n\n            // Find all assets in SteamAudioProbe.GetAssetFolderPath() path.\n            string[] reverbDataFolder = new string[] { SteamAudioReverbDataPoint.GetAssetFolderPath() };\n            string assetType = typeof(SteamAudioReverbData).Name;\n\n            // Createa a list of all SteamAudioReverbData Assets which are inside reverbDataFolder folder.\n            string[] reverbDataAssets = AssetDatabase.FindAssets(\"t:\" + assetType, reverbDataFolder);\n\n            if (reverbDataAssets.Length == 0)\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioReverbDataPointInspector.cs",
      "Content": "are inside reverbDataFolder folder.\n            string[] reverbDataAssets = AssetDatabase.FindAssets(\"t:\" + assetType, reverbDataFolder);\n\n            if (reverbDataAssets.Length == 0)\n            {\n                Debug.Log(\"No cleanup needed. No Steam Audio Reverb Data assets found in \" + reverbDataFolder[0] );\n                AssetDatabase.StopAssetEditing();\n                return;\n            }\n\n            // Go through all the assets and make a list of referenced SteamAudioProbe Assets.\n            List<string> referencedReverbDataAssetPaths = new List<string>();\n            var assetPaths = AssetDatabase.GetAllAssetPaths();\n            foreach (var assetPath in assetPaths)\n            {\n                if (!(assetPath.EndsWith(\".unity\") || assetPath.EndsWith(\".prefab\")))\n                    continue;\n\n                var assetDependencies = AssetDatabase.GetDependencies(assetPath, false);\n                foreach (var assetDependency in assetDependencies)\n                {\n                    if (assetDependency.Contains(reverbDataFolder[0]))\n                        referencedReverbDataAssetPaths.Add(assetDependency);\n                }\n            }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioReverbDataPointInspector.cs",
      "Content": "{\n                    if (assetDependency.Contains(reverbDataFolder[0]))\n                        referencedReverbDataAssetPaths.Add(assetDependency);\n                }\n            }\n\n            // Go through all the assets of type SteamAudioReverbData inside reverbDataFolder.\n            // Delete the once which are not found in referenced SteamAudioProbe Assets found above.\n            int numReverbDataAssetsDeleted = 0;\n            foreach (var reverbDataAsset in reverbDataAssets)\n            {\n                var reverbDataAssetPath = AssetDatabase.GUIDToAssetPath(reverbDataAsset);\n                if (string.IsNullOrEmpty(reverbDataAssetPath))\n                    continue;\n\n                bool deleteReverbDataAsset = !referencedReverbDataAssetPaths.Contains(reverbDataAssetPath);\n                if (deleteReverbDataAsset)\n                {\n                    bool deleteSuccessful = AssetDatabase.DeleteAsset(reverbDataAssetPath);\n                    var deleteSuccessfulString = \"Delete Failed:\";\n                    if (deleteSuccessful)\n                    {\n                        ++numReverbDataAssetsDeleted;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioReverbDataPointInspector.cs",
      "Content": "ataAssetPath);\n                    var deleteSuccessfulString = \"Delete Failed:\";\n                    if (deleteSuccessful)\n                    {\n                        ++numReverbDataAssetsDeleted;\n                        deleteSuccessfulString = \"Deleted:\";\n                    }\n\n                    Debug.Log(deleteSuccessfulString + \" \" + reverbDataAssetPath);\n                }\n            }\n\n            Debug.Log(\"Number of SteamAudioReverbData Assets deleted: \" + numReverbDataAssetsDeleted);\n            AssetDatabase.StopAssetEditing();\n        }\n\n        public override void OnInspectorGUI()\n        {\n            serializedObject.Update();\n\n            var oldGUIEnabled = GUI.enabled;\n            GUI.enabled = !Baker.IsBakeActive() && !EditorApplication.isPlayingOrWillChangePlaymode;\n\n            EditorGUILayout.Space();\n            EditorGUILayout.LabelField(\"Reverb Settings\", EditorStyles.boldLabel);\n\n            var tgt = target as SteamAudioReverbDataPoint;\n            int sampleRateIndex = System.Array.IndexOf(alllowedSampleRates, tgt.sampleRate);\n            if (sampleRateIndex < 0)\n            {\n                sampleRateIndex = 0;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioReverbDataPointInspector.cs",
      "Content": "ioReverbDataPoint;\n            int sampleRateIndex = System.Array.IndexOf(alllowedSampleRates, tgt.sampleRate);\n            if (sampleRateIndex < 0)\n            {\n                sampleRateIndex = 0;\n                tgt.sampleRate = alllowedSampleRates[sampleRateIndex];\n            }\n\n            EditorGUI.showMixedValue = mSamplingRate.hasMultipleDifferentValues;\n            EditorGUI.BeginChangeCheck();\n            int newSampleRate = EditorGUILayout.IntPopup(\"Sampling Rate\", tgt.sampleRate, displaySampleRates, alllowedSampleRates);\n            var selectedProbes = targets.Cast<SteamAudioReverbDataPoint>().ToArray();\n\n            if (EditorGUI.EndChangeCheck())\n            {\n                foreach (SteamAudioReverbDataPoint probe in selectedProbes)\n                {\n                    if (newSampleRate != probe.sampleRate)\n                    {\n                        probe.sampleRate = newSampleRate;\n                        EditorUtility.SetDirty(probe);\n                    }\n                }\n            }\n\n            EditorGUILayout.PropertyField(mAmbisonicOrder);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioReverbDataPointInspector.cs",
      "Content": "e.sampleRate = newSampleRate;\n                        EditorUtility.SetDirty(probe);\n                    }\n                }\n            }\n\n            EditorGUILayout.PropertyField(mAmbisonicOrder);\n            EditorGUILayout.PropertyField(mReverbDuration, new UnityEngine.GUIContent(\"Reverb Duration (seconds)\"));\n            EditorGUILayout.PropertyField(mStoreEnergyField);\n            EditorGUILayout.PropertyField(mStoreImpulseResponse);\n\n            GUI.enabled = !Baker.IsBakeActive() && !EditorApplication.isPlayingOrWillChangePlaymode;\n            EditorGUILayout.Space();\n            string bakeButtonString = serializedObject.isEditingMultipleObjects ? \"Bake Selected Probes\" : \"Bake\";\n            if (GUILayout.Button(bakeButtonString))\n            {\n                SteamAudioReverbDataPoint.BeginBake(selectedProbes);\n                mShouldShowProgressBar = true;\n                EditorSceneManager.MarkSceneDirty(SceneManager.GetActiveScene());\n            }\n\n            GUI.enabled = oldGUIEnabled;\n\n            if (mShouldShowProgressBar && !Baker.IsBakeActive())\n            {\n                mShouldShowProgressBar = false;\n            }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioReverbDataPointInspector.cs",
      "Content": "}\n\n            GUI.enabled = oldGUIEnabled;\n\n            if (mShouldShowProgressBar && !Baker.IsBakeActive())\n            {\n                mShouldShowProgressBar = false;\n            }\n\n            if (mShouldShowProgressBar)\n            {\n                Baker.DrawProgressBar();\n                Repaint();\n            }\n\n            // Display Stats\n            EditorGUILayout.PropertyField(mReverbDataAsset);\n            EditorGUILayout.Space();\n            if (mReverbDataAsset.objectReferenceValue != null)\n            {\n                Editor.CreateCachedEditor(mReverbDataAsset.objectReferenceValue, null, ref mReverbDataEditor);\n\n                // Pass the flag down for multi editing.\n                if (mReverbDataEditor is ReverbDataEditor reverbDataEditor)\n                    reverbDataEditor.mOwnerIsMultiEditing = serializedObject.isEditingMultipleObjects;\n\n                mReverbDataEditor.OnInspectorGUI();\n            }\n\n            GUI.enabled = oldGUIEnabled;\n            serializedObject.ApplyModifiedProperties();\n        }\n\n#else\n        public override void OnInspectorGUI()\n        {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioReverbDataPointInspector.cs",
      "Content": "nspectorGUI();\n            }\n\n            GUI.enabled = oldGUIEnabled;\n            serializedObject.ApplyModifiedProperties();\n        }\n\n#else\n        public override void OnInspectorGUI()\n        {\n            EditorGUILayout.HelpBox(\"Steam Audio is not supported for the target platform or STEAMAUDIO_ENABLED define symbol is missing.\", MessageType.Warning);\n        }\n#endif\n\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioReverbGUI.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEngine;\nusing UnityEditor;\n\nnamespace SteamAudio\n{\n    public class SteamAudioReverbGUI : IAudioEffectPluginGUI\n    {\n        public override string Name\n        {\n            get\n            {\n                return \"Steam Audio Reverb\";\n            }\n        }\n\n        public override string Vendor\n        {\n            get\n            {\n                return \"Valve Corporation\";\n            }\n        }\n\n        public override string Description\n        {\n            get\n            {\n                return \"Listener-centric reverb using Steam Audio.\";\n            }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioReverbGUI.cs",
      "Content": "ration\";\n            }\n        }\n\n        public override string Description\n        {\n            get\n            {\n                return \"Listener-centric reverb using Steam Audio.\";\n            }\n        }\n\n        public override bool OnGUI(IAudioEffectPlugin plugin)\n        {\n            if (SteamAudioSettings.Singleton.audioEngine != AudioEngineType.Unity)\n            {\n                EditorGUILayout.HelpBox(\n                    \"This Audio Mixer effect requires the audio engine to be set to Unity. Click\" +\n                    \"Steam Audio > Settings to change this.\", MessageType.Warning);\n\n                return false;\n            }\n\n            var binauralValue = 0.0f;\n\n            plugin.GetFloatParameter(\"Binaural\", out binauralValue);\n\n            var binaural = (binauralValue == 1.0f);\n\n            binaural = EditorGUILayout.Toggle(\"Apply HRTF\", binaural);\n\n            binauralValue = (binaural) ? 1.0f : 0.0f;\n\n            plugin.SetFloatParameter(\"Binaural\", binauralValue);\n\n            return false;\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSettingsInspector.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEditor;\n\nnamespace SteamAudio\n{\n    [CustomEditor(typeof(SteamAudioSettings))]\n    [CanEditMultipleObjects]\n    public class SteamAudioSettingsInspector : Editor\n    {\n        SerializedProperty mAudioEngine;\n        SerializedProperty mHRTFDisabled;\n        SerializedProperty mPerspectiveCorrection;\n        SerializedProperty mPerspectiveCorrectionFactor;\n        SerializedProperty mHRTFVolumeNormalizationType;\n        SerializedProperty mHRTFVolumeGainDB;\n        SerializedProperty mSOFAFiles;\n        SerializedProperty mDefaultMaterial;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSettingsInspector.cs",
      "Content": "ctionFactor;\n        SerializedProperty mHRTFVolumeNormalizationType;\n        SerializedProperty mHRTFVolumeGainDB;\n        SerializedProperty mSOFAFiles;\n        SerializedProperty mDefaultMaterial;\n        SerializedProperty mSceneType;\n        SerializedProperty mLayerMask;\n        SerializedProperty mMaxOcclusionSamples;\n        SerializedProperty mRealTimeRays;\n        SerializedProperty mRealTimeBounces;\n        SerializedProperty mRealTimeDuration;\n        SerializedProperty mRealTimeAmbisonicOrder;\n        SerializedProperty mRealTimeMaxSources;\n        SerializedProperty mRealTimeCPUCoresPercentage;\n        SerializedProperty mRealTimeIrradianceMinDistance;\n        SerializedProperty mBakeConvolution;\n        SerializedProperty mBakeParametric;\n        SerializedProperty mBakingRays;\n        SerializedProperty mBakingBounces;\n        SerializedProperty mBakingDuration;\n        SerializedProperty mBakingAmbisonicOrder;\n        SerializedProperty mBakingCPUCoresPercentage;\n        SerializedProperty mBakingIrradianceMinDistance;\n        SerializedProperty mBakingVisibilitySamples;\n        SerializedProperty mBakingVisibilityRadius;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSettingsInspector.cs",
      "Content": "edProperty mBakingCPUCoresPercentage;\n        SerializedProperty mBakingIrradianceMinDistance;\n        SerializedProperty mBakingVisibilitySamples;\n        SerializedProperty mBakingVisibilityRadius;\n        SerializedProperty mBakingVisibilityThreshold;\n        SerializedProperty mBakingVisibilityRange;\n        SerializedProperty mBakingPathRange;\n        SerializedProperty mBakedPathingCPUCoresPercentage;\n        SerializedProperty mSimulationUpdateInterval;\n        SerializedProperty mReflectionEffectType;\n        SerializedProperty mHybridReverbTransitionTime;\n        SerializedProperty mHybridReverbOverlapPercent;\n        SerializedProperty mDeviceType;\n        SerializedProperty mMaxReservedCUs;\n        SerializedProperty mFractionCUsForIRUpdate;\n        SerializedProperty mBakingBatchSize;\n        SerializedProperty mTANDuration;\n        SerializedProperty mTANAmbisonicOrder;\n        SerializedProperty mTANMaxSources;\n        SerializedProperty mEnableValidation;\n\n#if !UNITY_2019_2_OR_NEWER\n        static string[] sSceneTypes = new string[] { \"Phonon\", \"Embree\", \"Radeon Rays\", \"Unity\" };\n#endif\n\n#if !UNITY_2019_2_OR_NEWER"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSettingsInspector.cs",
      "Content": "SerializedProperty mEnableValidation;\n\n#if !UNITY_2019_2_OR_NEWER\n        static string[] sSceneTypes = new string[] { \"Phonon\", \"Embree\", \"Radeon Rays\", \"Unity\" };\n#endif\n\n#if !UNITY_2019_2_OR_NEWER\n        static string[] sReflectionEffectTypes = new string[] { \"Convolution\", \"Parametric\", \"Hybrid\", \"TrueAudio Next\" };\n#endif\n\n        private void OnEnable()\n        {\n            mAudioEngine = serializedObject.FindProperty(\"audioEngine\");\n            mHRTFDisabled = serializedObject.FindProperty(\"hrtfDisabled\");\n            mPerspectiveCorrection = serializedObject.FindProperty(\"perspectiveCorrection\");\n            mPerspectiveCorrectionFactor = serializedObject.FindProperty(\"perspectiveCorrectionFactor\");\n            mHRTFVolumeGainDB = serializedObject.FindProperty(\"hrtfVolumeGainDB\");\n            mHRTFVolumeNormalizationType = serializedObject.FindProperty(\"hrtfNormalizationType\");\n            mSOFAFiles = serializedObject.FindProperty(\"SOFAFiles\");\n            mDefaultMaterial = serializedObject.FindProperty(\"defaultMaterial\");\n            mSceneType = serializedObject.FindProperty(\"sceneType\");\n            mLayerMask = serializedObject.FindProperty(\"layerMask\");"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSettingsInspector.cs",
      "Content": "tMaterial = serializedObject.FindProperty(\"defaultMaterial\");\n            mSceneType = serializedObject.FindProperty(\"sceneType\");\n            mLayerMask = serializedObject.FindProperty(\"layerMask\");\n            mMaxOcclusionSamples = serializedObject.FindProperty(\"maxOcclusionSamples\");\n            mRealTimeRays = serializedObject.FindProperty(\"realTimeRays\");\n            mRealTimeBounces = serializedObject.FindProperty(\"realTimeBounces\");\n            mRealTimeDuration = serializedObject.FindProperty(\"realTimeDuration\");\n            mRealTimeAmbisonicOrder = serializedObject.FindProperty(\"realTimeAmbisonicOrder\");\n            mRealTimeMaxSources = serializedObject.FindProperty(\"realTimeMaxSources\");\n            mRealTimeCPUCoresPercentage = serializedObject.FindProperty(\"realTimeCPUCoresPercentage\");\n            mRealTimeIrradianceMinDistance = serializedObject.FindProperty(\"realTimeIrradianceMinDistance\");\n            mBakeConvolution = serializedObject.FindProperty(\"bakeConvolution\");\n            mBakeParametric = serializedObject.FindProperty(\"bakeParametric\");\n            mBakingRays = serializedObject.FindProperty(\"bakingRays\");"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSettingsInspector.cs",
      "Content": "serializedObject.FindProperty(\"bakeConvolution\");\n            mBakeParametric = serializedObject.FindProperty(\"bakeParametric\");\n            mBakingRays = serializedObject.FindProperty(\"bakingRays\");\n            mBakingBounces = serializedObject.FindProperty(\"bakingBounces\");\n            mBakingDuration = serializedObject.FindProperty(\"bakingDuration\");\n            mBakingAmbisonicOrder = serializedObject.FindProperty(\"bakingAmbisonicOrder\");\n            mBakingCPUCoresPercentage = serializedObject.FindProperty(\"bakingCPUCoresPercentage\");\n            mBakingIrradianceMinDistance = serializedObject.FindProperty(\"bakingIrradianceMinDistance\");\n            mBakingVisibilitySamples = serializedObject.FindProperty(\"bakingVisibilitySamples\");\n            mBakingVisibilityRadius = serializedObject.FindProperty(\"bakingVisibilityRadius\");\n            mBakingVisibilityThreshold = serializedObject.FindProperty(\"bakingVisibilityThreshold\");\n            mBakingVisibilityRange = serializedObject.FindProperty(\"bakingVisibilityRange\");\n            mBakingPathRange = serializedObject.FindProperty(\"bakingPathRange\");"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSettingsInspector.cs",
      "Content": "ingVisibilityThreshold\");\n            mBakingVisibilityRange = serializedObject.FindProperty(\"bakingVisibilityRange\");\n            mBakingPathRange = serializedObject.FindProperty(\"bakingPathRange\");\n            mBakedPathingCPUCoresPercentage = serializedObject.FindProperty(\"bakedPathingCPUCoresPercentage\");\n            mSimulationUpdateInterval = serializedObject.FindProperty(\"simulationUpdateInterval\");\n            mReflectionEffectType = serializedObject.FindProperty(\"reflectionEffectType\");\n            mHybridReverbTransitionTime = serializedObject.FindProperty(\"hybridReverbTransitionTime\");\n            mHybridReverbOverlapPercent = serializedObject.FindProperty(\"hybridReverbOverlapPercent\");\n            mDeviceType = serializedObject.FindProperty(\"deviceType\");\n            mMaxReservedCUs = serializedObject.FindProperty(\"maxReservedComputeUnits\");\n            mFractionCUsForIRUpdate = serializedObject.FindProperty(\"fractionComputeUnitsForIRUpdate\");\n            mBakingBatchSize = serializedObject.FindProperty(\"bakingBatchSize\");\n            mTANDuration = serializedObject.FindProperty(\"TANDuration\");"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSettingsInspector.cs",
      "Content": "dProperty(\"fractionComputeUnitsForIRUpdate\");\n            mBakingBatchSize = serializedObject.FindProperty(\"bakingBatchSize\");\n            mTANDuration = serializedObject.FindProperty(\"TANDuration\");\n            mTANAmbisonicOrder = serializedObject.FindProperty(\"TANAmbisonicOrder\");\n            mTANMaxSources = serializedObject.FindProperty(\"TANMaxSources\");\n            mEnableValidation = serializedObject.FindProperty(\"EnableValidation\");\n        }\n\n        public override void OnInspectorGUI()\n        {\n            serializedObject.Update();\n\n            EditorGUILayout.PropertyField(mAudioEngine);\n            EditorGUILayout.PropertyField(mHRTFDisabled, new UnityEngine.GUIContent(\"Disable HRTF Globally\", \"Disable HRTF rendering for all events/sources. Useful when the end user is using speakers instead of headphones.\"));\n            EditorGUILayout.PropertyField(mPerspectiveCorrection, new UnityEngine.GUIContent(\"Enable Perspective Correction\"));\n\n            if (mPerspectiveCorrection.boolValue)\n                EditorGUILayout.PropertyField(mPerspectiveCorrectionFactor);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSettingsInspector.cs",
      "Content": "rection, new UnityEngine.GUIContent(\"Enable Perspective Correction\"));\n\n            if (mPerspectiveCorrection.boolValue)\n                EditorGUILayout.PropertyField(mPerspectiveCorrectionFactor);\n\n            EditorGUILayout.PropertyField(mHRTFVolumeGainDB, new UnityEngine.GUIContent(\"HRTF Volume Gain (dB)\"));\n            EditorGUILayout.PropertyField(mHRTFVolumeNormalizationType, new UnityEngine.GUIContent(\"HRTF Normalization Type\"));\n\n            EditorGUILayout.PropertyField(mSOFAFiles, true);\n            EditorGUILayout.PropertyField(mDefaultMaterial);\n#if UNITY_2019_2_OR_NEWER\n            EditorGUILayout.PropertyField(mSceneType);\n#else\n            SceneTypeField();\n#endif\n\n            if (((SceneType) mSceneType.enumValueIndex) == SceneType.Custom)\n            {\n                EditorGUILayout.PropertyField(mLayerMask);\n            }\n\n            EditorGUILayout.PropertyField(mMaxOcclusionSamples);\n\n            EditorGUILayout.PropertyField(mRealTimeRays);\n            EditorGUILayout.PropertyField(mRealTimeBounces);\n            EditorGUILayout.PropertyField(mRealTimeDuration);\n            EditorGUILayout.PropertyField(mRealTimeAmbisonicOrder);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSettingsInspector.cs",
      "Content": "meRays);\n            EditorGUILayout.PropertyField(mRealTimeBounces);\n            EditorGUILayout.PropertyField(mRealTimeDuration);\n            EditorGUILayout.PropertyField(mRealTimeAmbisonicOrder);\n            EditorGUILayout.PropertyField(mRealTimeMaxSources);\n            EditorGUILayout.PropertyField(mRealTimeCPUCoresPercentage);\n            EditorGUILayout.PropertyField(mRealTimeIrradianceMinDistance);\n\n            EditorGUILayout.PropertyField(mBakeConvolution);\n            EditorGUILayout.PropertyField(mBakeParametric);\n            EditorGUILayout.PropertyField(mBakingRays);\n            EditorGUILayout.PropertyField(mBakingBounces);\n            EditorGUILayout.PropertyField(mBakingDuration);\n            EditorGUILayout.PropertyField(mBakingAmbisonicOrder);\n            EditorGUILayout.PropertyField(mBakingCPUCoresPercentage);\n            EditorGUILayout.PropertyField(mBakingIrradianceMinDistance);\n\n            EditorGUILayout.PropertyField(mBakingVisibilitySamples);\n            EditorGUILayout.PropertyField(mBakingVisibilityRadius);\n            EditorGUILayout.PropertyField(mBakingVisibilityThreshold);\n            EditorGUILayout.PropertyField(mBakingVisibilityRange);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSettingsInspector.cs",
      "Content": "EditorGUILayout.PropertyField(mBakingVisibilityRadius);\n            EditorGUILayout.PropertyField(mBakingVisibilityThreshold);\n            EditorGUILayout.PropertyField(mBakingVisibilityRange);\n            EditorGUILayout.PropertyField(mBakingPathRange);\n            EditorGUILayout.PropertyField(mBakedPathingCPUCoresPercentage);\n\n            EditorGUILayout.PropertyField(mSimulationUpdateInterval);\n\n#if UNITY_2019_2_OR_NEWER\n            EditorGUILayout.PropertyField(mReflectionEffectType);\n#else\n            ReflectionEffectTypeField();\n#endif\n\n            if (((ReflectionEffectType) mReflectionEffectType.enumValueIndex) == ReflectionEffectType.Hybrid)\n            {\n                EditorGUILayout.PropertyField(mHybridReverbTransitionTime);\n                EditorGUILayout.PropertyField(mHybridReverbOverlapPercent);\n            }\n\n            if (((SceneType) mSceneType.enumValueIndex) == SceneType.RadeonRays ||\n                ((ReflectionEffectType) mReflectionEffectType.enumValueIndex) == ReflectionEffectType.TrueAudioNext)\n            {\n                EditorGUILayout.PropertyField(mDeviceType);\n                EditorGUILayout.PropertyField(mMaxReservedCUs);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSettingsInspector.cs",
      "Content": "ctType.enumValueIndex) == ReflectionEffectType.TrueAudioNext)\n            {\n                EditorGUILayout.PropertyField(mDeviceType);\n                EditorGUILayout.PropertyField(mMaxReservedCUs);\n                EditorGUILayout.PropertyField(mFractionCUsForIRUpdate);\n\n                if (((SceneType) mSceneType.enumValueIndex) == SceneType.RadeonRays)\n                {\n                    EditorGUILayout.PropertyField(mBakingBatchSize);\n                }\n\n                if (((ReflectionEffectType) mReflectionEffectType.enumValueIndex) == ReflectionEffectType.TrueAudioNext)\n                {\n                    EditorGUILayout.PropertyField(mTANDuration);\n                    EditorGUILayout.PropertyField(mTANAmbisonicOrder);\n                    EditorGUILayout.PropertyField(mTANMaxSources);\n                }\n            }\n\n            EditorGUILayout.PropertyField(mEnableValidation);\n\n            serializedObject.ApplyModifiedProperties();\n        }\n\n#if !UNITY_2019_2_OR_NEWER\n        void SceneTypeField()\n        {\n            EditorGUILayout.Space();\n            EditorGUILayout.LabelField(\"Ray Tracer Settings\", EditorStyles.boldLabel);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSettingsInspector.cs",
      "Content": "}\n\n#if !UNITY_2019_2_OR_NEWER\n        void SceneTypeField()\n        {\n            EditorGUILayout.Space();\n            EditorGUILayout.LabelField(\"Ray Tracer Settings\", EditorStyles.boldLabel);\n            mSceneType.enumValueIndex = EditorGUILayout.Popup(mSceneType.displayName, mSceneType.enumValueIndex, sSceneTypes);\n        }\n#endif\n\n#if !UNITY_2019_2_OR_NEWER\n        void ReflectionEffectTypeField()\n        {\n            EditorGUILayout.Space();\n            EditorGUILayout.LabelField(\"Reflection Effect Settings\", EditorStyles.boldLabel);\n            mReflectionEffectType.enumValueIndex = EditorGUILayout.Popup(mReflectionEffectType.displayName, mReflectionEffectType.enumValueIndex, sReflectionEffectTypes);\n        }\n#endif\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSourceInspector.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEngine;\nusing UnityEditor;\n\nnamespace SteamAudio\n{\n    [CustomEditor(typeof(SteamAudioSource))]\n    public class SteamAudioSourceInspector : Editor\n    {\n        SerializedProperty mDirectBinaural;\n        SerializedProperty mInterpolation;\n        SerializedProperty mPerspectiveCorrection;\n        SerializedProperty mDistanceAttenuation;\n        SerializedProperty mDistanceAttenuationInput;\n        SerializedProperty mAirAbsorption;\n        SerializedProperty mAirAbsorptionInput;\n        SerializedProperty mAirAbsorptionLow;\n        SerializedProperty mAirAbsorptionMid;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSourceInspector.cs",
      "Content": "ttenuationInput;\n        SerializedProperty mAirAbsorption;\n        SerializedProperty mAirAbsorptionInput;\n        SerializedProperty mAirAbsorptionLow;\n        SerializedProperty mAirAbsorptionMid;\n        SerializedProperty mAirAbsorptionHigh;\n        SerializedProperty mDirectivity;\n        SerializedProperty mDirectivityInput;\n        SerializedProperty mDipoleWeight;\n        SerializedProperty mDipolePower;\n        SerializedProperty mDirectivityValue;\n        SerializedProperty mOcclusion;\n        SerializedProperty mOcclusionInput;\n        SerializedProperty mOcclusionType;\n        SerializedProperty mOcclusionRadius;\n        SerializedProperty mOcclusionSamples;\n        SerializedProperty mOcclusionValue;\n        SerializedProperty mTransmission;\n        SerializedProperty mTransmissionType;\n        SerializedProperty mTransmissionInput;\n        SerializedProperty mTransmissionLow;\n        SerializedProperty mTransmissionMid;\n        SerializedProperty mTransmissionHigh;\n        SerializedProperty mTransmissionRays;\n        SerializedProperty mDirectMixLevel;\n        SerializedProperty mReflections;\n        SerializedProperty mReflectionsType;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSourceInspector.cs",
      "Content": "erty mTransmissionHigh;\n        SerializedProperty mTransmissionRays;\n        SerializedProperty mDirectMixLevel;\n        SerializedProperty mReflections;\n        SerializedProperty mReflectionsType;\n        SerializedProperty mUseDistanceCurveForReflections;\n        SerializedProperty mCurrentBakedSource;\n        SerializedProperty mApplyHRTFToReflections;\n        SerializedProperty mReflectionsMixLevel;\n        SerializedProperty mPathing;\n        SerializedProperty mPathingProbeBatch;\n        SerializedProperty mPathValidation;\n        SerializedProperty mFindAlternatePaths;\n        SerializedProperty mApplyHRTFToPathing;\n        SerializedProperty mPathingMixLevel;\n        SerializedProperty mNormalizePathingEQ;\n\n        Texture2D mDirectivityPreview = null;\n        float[] mDirectivitySamples = null;\n        Vector2[] mDirectivityPositions = null;\n\n        private void OnEnable()\n        {\n            mDirectBinaural = serializedObject.FindProperty(\"directBinaural\");\n            mInterpolation = serializedObject.FindProperty(\"interpolation\");\n            mPerspectiveCorrection = serializedObject.FindProperty(\"perspectiveCorrection\");"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSourceInspector.cs",
      "Content": "ndProperty(\"directBinaural\");\n            mInterpolation = serializedObject.FindProperty(\"interpolation\");\n            mPerspectiveCorrection = serializedObject.FindProperty(\"perspectiveCorrection\");\n            mDistanceAttenuation = serializedObject.FindProperty(\"distanceAttenuation\");\n            mDistanceAttenuationInput = serializedObject.FindProperty(\"distanceAttenuationInput\");\n            mAirAbsorption = serializedObject.FindProperty(\"airAbsorption\");\n            mAirAbsorptionInput = serializedObject.FindProperty(\"airAbsorptionInput\");\n            mAirAbsorptionLow = serializedObject.FindProperty(\"airAbsorptionLow\");\n            mAirAbsorptionMid = serializedObject.FindProperty(\"airAbsorptionMid\");\n            mAirAbsorptionHigh = serializedObject.FindProperty(\"airAbsorptionHigh\");\n            mDirectivity = serializedObject.FindProperty(\"directivity\");\n            mDirectivityInput = serializedObject.FindProperty(\"directivityInput\");\n            mDipoleWeight = serializedObject.FindProperty(\"dipoleWeight\");\n            mDipolePower = serializedObject.FindProperty(\"dipolePower\");\n            mDirectivityValue = serializedObject.FindProperty(\"directivityValue\");"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSourceInspector.cs",
      "Content": "ializedObject.FindProperty(\"dipoleWeight\");\n            mDipolePower = serializedObject.FindProperty(\"dipolePower\");\n            mDirectivityValue = serializedObject.FindProperty(\"directivityValue\");\n            mOcclusion = serializedObject.FindProperty(\"occlusion\");\n            mOcclusionInput = serializedObject.FindProperty(\"occlusionInput\");\n            mOcclusionType = serializedObject.FindProperty(\"occlusionType\");\n            mOcclusionRadius = serializedObject.FindProperty(\"occlusionRadius\");\n            mOcclusionSamples = serializedObject.FindProperty(\"occlusionSamples\");\n            mOcclusionValue = serializedObject.FindProperty(\"occlusionValue\");\n            mTransmission = serializedObject.FindProperty(\"transmission\");\n            mTransmissionType = serializedObject.FindProperty(\"transmissionType\");\n            mTransmissionInput = serializedObject.FindProperty(\"transmissionInput\");\n            mTransmissionLow = serializedObject.FindProperty(\"transmissionLow\");\n            mTransmissionMid = serializedObject.FindProperty(\"transmissionMid\");\n            mTransmissionHigh = serializedObject.FindProperty(\"transmissionHigh\");"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSourceInspector.cs",
      "Content": "ct.FindProperty(\"transmissionLow\");\n            mTransmissionMid = serializedObject.FindProperty(\"transmissionMid\");\n            mTransmissionHigh = serializedObject.FindProperty(\"transmissionHigh\");\n            mTransmissionRays = serializedObject.FindProperty(\"maxTransmissionSurfaces\");\n            mDirectMixLevel = serializedObject.FindProperty(\"directMixLevel\");\n            mReflections = serializedObject.FindProperty(\"reflections\");\n            mReflectionsType = serializedObject.FindProperty(\"reflectionsType\");\n            mUseDistanceCurveForReflections = serializedObject.FindProperty(\"useDistanceCurveForReflections\");\n            mCurrentBakedSource = serializedObject.FindProperty(\"currentBakedSource\");\n            mApplyHRTFToReflections = serializedObject.FindProperty(\"applyHRTFToReflections\");\n            mReflectionsMixLevel = serializedObject.FindProperty(\"reflectionsMixLevel\");\n            mPathing = serializedObject.FindProperty(\"pathing\");\n            mPathingProbeBatch = serializedObject.FindProperty(\"pathingProbeBatch\");\n            mPathValidation = serializedObject.FindProperty(\"pathValidation\");"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSourceInspector.cs",
      "Content": "izedObject.FindProperty(\"pathing\");\n            mPathingProbeBatch = serializedObject.FindProperty(\"pathingProbeBatch\");\n            mPathValidation = serializedObject.FindProperty(\"pathValidation\");\n            mFindAlternatePaths = serializedObject.FindProperty(\"findAlternatePaths\");\n            mApplyHRTFToPathing = serializedObject.FindProperty(\"applyHRTFToPathing\");\n            mPathingMixLevel = serializedObject.FindProperty(\"pathingMixLevel\");\n            mNormalizePathingEQ = serializedObject.FindProperty(\"normalizePathingEQ\");\n        }\n\n        public override void OnInspectorGUI()\n        {\n            var audioEngineIsUnity = (SteamAudioSettings.Singleton.audioEngine == AudioEngineType.Unity);\n\n            serializedObject.Update();\n\n            if (audioEngineIsUnity)\n            {\n                EditorGUILayout.PropertyField(mDirectBinaural);\n                EditorGUILayout.PropertyField(mInterpolation);\n            }\n\n            if (audioEngineIsUnity && SteamAudioSettings.Singleton.perspectiveCorrection)\n            {\n                EditorGUILayout.PropertyField(mPerspectiveCorrection);\n            }\n\n            if (audioEngineIsUnity)\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSourceInspector.cs",
      "Content": "eamAudioSettings.Singleton.perspectiveCorrection)\n            {\n                EditorGUILayout.PropertyField(mPerspectiveCorrection);\n            }\n\n            if (audioEngineIsUnity)\n            {\n                EditorGUILayout.PropertyField(mDistanceAttenuation);\n                if (mDistanceAttenuation.boolValue)\n                {\n                    EditorGUILayout.PropertyField(mDistanceAttenuationInput);\n                }\n            }\n\n            if (audioEngineIsUnity)\n            {\n                EditorGUILayout.PropertyField(mAirAbsorption);\n                if (mAirAbsorption.boolValue)\n                {\n                    EditorGUILayout.PropertyField(mAirAbsorptionInput);\n                    if ((AirAbsorptionInput)mAirAbsorptionInput.enumValueIndex == AirAbsorptionInput.UserDefined)\n                    {\n                        EditorGUILayout.PropertyField(mAirAbsorptionLow);\n                        EditorGUILayout.PropertyField(mAirAbsorptionMid);\n                        EditorGUILayout.PropertyField(mAirAbsorptionHigh);\n                    }\n                }\n            }\n\n            if (audioEngineIsUnity)\n            {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSourceInspector.cs",
      "Content": "mAirAbsorptionMid);\n                        EditorGUILayout.PropertyField(mAirAbsorptionHigh);\n                    }\n                }\n            }\n\n            if (audioEngineIsUnity)\n            {\n                EditorGUILayout.PropertyField(mDirectivity);\n                if (mDirectivity.boolValue)\n                {\n                    EditorGUILayout.PropertyField(mDirectivityInput);\n\n                    if ((DirectivityInput) mDirectivityInput.enumValueIndex == DirectivityInput.SimulationDefined)\n                    {\n                        EditorGUILayout.PropertyField(mDipoleWeight);\n                        EditorGUILayout.PropertyField(mDipolePower);\n                        DrawDirectivity(mDipoleWeight.floatValue, mDipolePower.floatValue);\n                    }\n                    else if ((DirectivityInput) mDirectivityInput.enumValueIndex == DirectivityInput.UserDefined)\n                    {\n                        EditorGUILayout.PropertyField(mDirectivityValue);\n                    }\n                }\n            }\n\n            EditorGUILayout.PropertyField(mOcclusion);\n            if (mOcclusion.boolValue)\n            {\n                if (audioEngineIsUnity)"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSourceInspector.cs",
      "Content": "}\n                }\n            }\n\n            EditorGUILayout.PropertyField(mOcclusion);\n            if (mOcclusion.boolValue)\n            {\n                if (audioEngineIsUnity)\n                {\n                    EditorGUILayout.PropertyField(mOcclusionInput);\n                }\n\n                if (!audioEngineIsUnity ||\n                    (OcclusionInput) mOcclusionInput.enumValueIndex == OcclusionInput.SimulationDefined)\n                {\n                    EditorGUILayout.PropertyField(mOcclusionType);\n                    if ((OcclusionType) mOcclusionType.enumValueIndex == OcclusionType.Volumetric)\n                    {\n                        EditorGUILayout.PropertyField(mOcclusionRadius);\n                        EditorGUILayout.PropertyField(mOcclusionSamples);\n                    }\n                }\n                else if ((OcclusionInput) mOcclusionInput.enumValueIndex == OcclusionInput.UserDefined)\n                {\n                    EditorGUILayout.PropertyField(mOcclusionValue);\n                }\n\n                EditorGUILayout.PropertyField(mTransmission);\n                if (audioEngineIsUnity)\n                {"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSourceInspector.cs",
      "Content": "EditorGUILayout.PropertyField(mOcclusionValue);\n                }\n\n                EditorGUILayout.PropertyField(mTransmission);\n                if (audioEngineIsUnity)\n                {\n                    if (mTransmission.boolValue)\n                    {\n                        EditorGUILayout.PropertyField(mTransmissionType);\n                        EditorGUILayout.PropertyField(mTransmissionInput);\n                        if ((TransmissionInput)mTransmissionInput.enumValueIndex == TransmissionInput.UserDefined)\n                        {\n                            if (mTransmissionType.enumValueIndex == (int)TransmissionType.FrequencyDependent)\n                            {\n                                EditorGUILayout.PropertyField(mTransmissionLow);\n                                EditorGUILayout.PropertyField(mTransmissionMid);\n                                EditorGUILayout.PropertyField(mTransmissionHigh);\n                            }\n                            else\n                            {\n                                EditorGUILayout.PropertyField(mTransmissionMid);\n                            }\n                        }\n                    }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSourceInspector.cs",
      "Content": "else\n                            {\n                                EditorGUILayout.PropertyField(mTransmissionMid);\n                            }\n                        }\n                    }\n                }\n\n                if (!audioEngineIsUnity ||\n                    (TransmissionInput) mTransmissionInput.enumValueIndex == TransmissionInput.SimulationDefined)\n                {\n                    EditorGUILayout.PropertyField(mTransmissionRays);\n                }\n            }\n\n            if (audioEngineIsUnity)\n            {\n                EditorGUILayout.PropertyField(mDirectMixLevel);\n            }\n\n            EditorGUILayout.PropertyField(mReflections);\n            if (mReflections.boolValue)\n            {\n                EditorGUILayout.PropertyField(mReflectionsType);\n\n                if (audioEngineIsUnity &&\n                    mDistanceAttenuation.boolValue &&\n                    (DistanceAttenuationInput) mDistanceAttenuationInput.enumValueIndex == DistanceAttenuationInput.CurveDriven)\n                {\n                    EditorGUILayout.PropertyField(mUseDistanceCurveForReflections);\n                }"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSourceInspector.cs",
      "Content": "stanceAttenuationInput.enumValueIndex == DistanceAttenuationInput.CurveDriven)\n                {\n                    EditorGUILayout.PropertyField(mUseDistanceCurveForReflections);\n                }\n\n                if ((ReflectionsType) mReflectionsType.enumValueIndex == ReflectionsType.BakedStaticSource)\n                {\n                    EditorGUILayout.PropertyField(mCurrentBakedSource);\n                }\n\n                if (audioEngineIsUnity)\n                {\n                    EditorGUILayout.PropertyField(mApplyHRTFToReflections);\n                    EditorGUILayout.PropertyField(mReflectionsMixLevel);\n                }\n            }\n\n            EditorGUILayout.PropertyField(mPathing);\n            if (mPathing.boolValue)\n            {\n                EditorGUILayout.PropertyField(mPathingProbeBatch);\n                EditorGUILayout.PropertyField(mPathValidation);\n                EditorGUILayout.PropertyField(mFindAlternatePaths);\n\n                if (audioEngineIsUnity)\n                {\n                    EditorGUILayout.PropertyField(mApplyHRTFToPathing);\n                    EditorGUILayout.PropertyField(mPathingMixLevel);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSourceInspector.cs",
      "Content": "if (audioEngineIsUnity)\n                {\n                    EditorGUILayout.PropertyField(mApplyHRTFToPathing);\n                    EditorGUILayout.PropertyField(mPathingMixLevel);\n                    EditorGUILayout.PropertyField(mNormalizePathingEQ);\n                }\n            }\n\n            serializedObject.ApplyModifiedProperties();\n        }\n\n        void DrawDirectivity(float dipoleWeight, float dipolePower)\n        {\n            if (mDirectivityPreview == null)\n            {\n                mDirectivityPreview = new Texture2D(65, 65);\n            }\n\n            if (mDirectivitySamples == null)\n            {\n                mDirectivitySamples = new float[360];\n                mDirectivityPositions = new Vector2[360];\n            }\n\n            for (var i = 0; i < mDirectivitySamples.Length; ++i)\n            {\n                var theta = (i / 360.0f) * (2.0f * Mathf.PI);\n                mDirectivitySamples[i] = Mathf.Pow(Mathf.Abs((1.0f - dipoleWeight) + dipoleWeight * Mathf.Cos(theta)), dipolePower);\n\n                var r = 31 * Mathf.Abs(mDirectivitySamples[i]);\n                var x = r * Mathf.Cos(theta) + 32;"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSourceInspector.cs",
      "Content": "w(Mathf.Abs((1.0f - dipoleWeight) + dipoleWeight * Mathf.Cos(theta)), dipolePower);\n\n                var r = 31 * Mathf.Abs(mDirectivitySamples[i]);\n                var x = r * Mathf.Cos(theta) + 32;\n                var y = r * Mathf.Sin(theta) + 32;\n                mDirectivityPositions[i] = new Vector2(-y, x);\n            }\n\n            for (var v = 0; v < mDirectivityPreview.height; ++v)\n            {\n                for (var u = 0; u < mDirectivityPreview.width; ++u)\n                {\n                    mDirectivityPreview.SetPixel(u, v, Color.gray);\n                }\n            }\n\n            for (var u = 0; u < mDirectivityPreview.width; ++u)\n            {\n                mDirectivityPreview.SetPixel(u, 32, Color.black);\n            }\n\n            for (var v = 0; v < mDirectivityPreview.height; ++v)\n            {\n                mDirectivityPreview.SetPixel(32, v, Color.black);\n            }\n\n            for (var i = 0; i < mDirectivitySamples.Length; ++i)\n            {\n                var color = (mDirectivitySamples[i] > 0.0f) ? Color.red : Color.blue;\n                mDirectivityPreview.SetPixel((int) mDirectivityPositions[i].x, (int) mDirectivityPositions[i].y, color);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioSourceInspector.cs",
      "Content": "var color = (mDirectivitySamples[i] > 0.0f) ? Color.red : Color.blue;\n                mDirectivityPreview.SetPixel((int) mDirectivityPositions[i].x, (int) mDirectivityPositions[i].y, color);\n            }\n\n            mDirectivityPreview.Apply();\n\n            EditorGUILayout.PrefixLabel(\"Preview\");\n            EditorGUILayout.Space();\n            var rect = EditorGUI.IndentedRect(EditorGUILayout.GetControlRect());\n            var center = rect.center;\n            center.x += 4;\n            rect.center = center;\n            rect.width = 65;\n            rect.height = 65;\n\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n            EditorGUILayout.Space();\n\n            EditorGUI.DrawPreviewTexture(rect, mDirectivityPreview);\n        }\n    }\n}"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioStaticMeshInspector.cs",
      "Content": "//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nusing UnityEngine;\nusing UnityEditor;\n\nnamespace SteamAudio\n{\n    [CustomEditor(typeof(SteamAudioStaticMesh))]\n    public class SteamAudioStaticMeshInspector : Editor\n    {\n#if STEAMAUDIO_ENABLED\n        SerializedProperty mAsset;\n        SerializedProperty mSceneNameWhenExported;\n\n        void OnEnable()\n        {\n            mAsset = serializedObject.FindProperty(\"asset\");\n            mSceneNameWhenExported = serializedObject.FindProperty(\"sceneNameWhenExported\");\n        }\n\n        public override void OnInspectorGUI()\n        {\n            serializedObject.Update();"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioStaticMeshInspector.cs",
      "Content": "mSceneNameWhenExported = serializedObject.FindProperty(\"sceneNameWhenExported\");\n        }\n\n        public override void OnInspectorGUI()\n        {\n            serializedObject.Update();\n\n            EditorGUILayout.PropertyField(mAsset);\n\n            var scene = (target as SteamAudioStaticMesh).gameObject.scene;\n\n            if (mAsset.objectReferenceValue == null)\n            {\n                EditorGUILayout.HelpBox(\n                    \"This scene has not been exported. Click Steam Audio > Export Active Scene to export.\",\n                    MessageType.Warning);\n            }\n            else if (mSceneNameWhenExported.stringValue != scene.name)\n            {\n                EditorGUILayout.HelpBox(\n                    string.Format(\"This geometry was last exported for the scene {0}. If this is not what you \" +\n                        \"intended, click Export As New Asset below.\", mSceneNameWhenExported.stringValue),\n                    MessageType.Warning);\n\n                if (GUILayout.Button(\"Export As New Asset\"))\n                {\n                    mAsset.objectReferenceValue = SerializedData.PromptForNewAsset(scene.name);"
    },
    {
      "Source": "Assets/Plugins/SteamAudio/Scripts/Editor/SteamAudioStaticMeshInspector.cs",
      "Content": "MessageType.Warning);\n\n                if (GUILayout.Button(\"Export As New Asset\"))\n                {\n                    mAsset.objectReferenceValue = SerializedData.PromptForNewAsset(scene.name);\n                    mSceneNameWhenExported.stringValue = scene.name;\n                    serializedObject.ApplyModifiedProperties();\n\n                    SteamAudioManager.ExportScene(scene, false);\n                }\n            }\n\n            serializedObject.ApplyModifiedProperties();\n        }\n#else\n        public override void OnInspectorGUI()\n        {\n            EditorGUILayout.HelpBox(\"Steam Audio is not supported for the target platform or STEAMAUDIO_ENABLED define symbol is missing.\", MessageType.Warning);\n        }\n#endif\n    }\n}"
    },
    {
      "Source": "Assets/Generated/generated_20250918_005658_satie.txt",
      "Content": "loop \"ambience/forest\":\n    volume = 0.35\nloop \"music/beat\":\n    volume = 0.18\n3 * oneshot \"bird/1to7\" every 2to5:\n    volume = 0.12to0.25\n    move = fly, -25to25, 3to12, -25to25, 0.5to1.2\n    visual = trail\n2 * oneshot \"footsteps/1to36\" every 8to14:\n    volume = 0.2to0.35\n    move = walk, -20to20, -20to20, 0.6to1.1\n    visual = sphere"
    },
    {
      "Source": "Assets/Examples/ambient.sat",
      "Content": "group forest:\nvolume = 0.2\nduration = 80\nfade_out = 15\n    loop \"ambience/forest\":\n        volume = 0.2\n        fade_in = 10\n    loop \"ambience/water\":\n        volume = 0.8\n        fade_in = 10\n        move = walk, -10to10, -10to10, 0.01\n\ngroup animals:\nduration = 60\n    loop \"conversation/people\":\n        volume = 0.2\n        fade_in = 10\n        move = walk, -10to10, -10to10, 0.001\n    loop \"animals/duck\":\n        volume = 0.5\n        starts_at = 5to10\n        fade_in = 10\n        move = walk, -10to10, -10to10, 0.01\n\ngroup birds:\npitch = 0.5\nduration = 40\nfade_out = 15\n    oneshot \"bird/1to4\" every 4to7:\n        volume = 0.2to0.3\n        pitch = 0.6to1\n        fade_in = 10to15\n        move = fly, -10to10, 0to15, -10to10, 0.06\n        visual = trail\n    oneshot \"bird/1to4\" every 4to7:\n        volume = 0.2to0.3\n        pitch = 0.6to1\n        fade_in = 10to15\n        move = fly, -10to10, 0to15, -10to10, 0.06\n        visual = trail\n\ngroup music:\nduration = 60\npitch = 0.5\n    loop \"music/drone\":\n        volume = 0.07\n        starts_at = 20\n        fade_in = 35\n    loop \"music/drone\":\n        volume = 0.02\n        pitch = 2\n        starts_at = 20\n        fade_in = 30to40"
    },
    {
      "Source": "Assets/Examples/ambient.sat",
      "Content": "loop \"music/drone\":\n        volume = 0.07\n        starts_at = 20\n        fade_in = 35\n    loop \"music/drone\":\n        volume = 0.02\n        pitch = 2\n        starts_at = 20\n        fade_in = 30to40\n    oneshot \"music/1to3\" every 20to40:\n        volume = 0.5\n        move = pos, -10to10, 0to10, -10to10\n    loop \"sacred/1\":\n        volume = 0.3\n        move = walk, -10to10, -10to10, 0.01\n        visual = trail\n        fade_in = 50"
    },
    {
      "Source": "Assets/Examples/beat.sat",
      "Content": "group beat:\npitch = 2\nvolume = 1\n    loop \"music/beat\":\n        volume = 0.5\n        pitch = -2\n        starts_at = 1to10\n        fade_in = 5to30\n        move = walk, -10to10, -10to10, 0.05to0.2\n        visual = trail\n        overlap = true\n    loop \"music/beat\":\n        volume = 0.5\n        pitch = 2\n        starts_at = 1to10\n        fade_in = 5to30\n        move = walk, -10to10, -10to10, 0.05to0.2\n        visual = trail\n        overlap = true\n    loop \"music/beat\":\n        volume = 0.5\n        pitch = 1\n        starts_at = 1to10\n        fade_in = 5to30\n        overlap = true\n        move = walk, -10to10, -10to10, 0.05to0.2\n        visual = trail\n    loop \"music/beat\":\n        volume = 0.5\n        pitch = 1\n        starts_at = 1to10\n        fade_in = 5to30\n        overlap = true\n        move = walk, -10to10, -10to10, 0.05to0.2\n        visual = trail\n\ngroup drone:\n    loop \"music/drone\":\n            volume = 0.5\n            pitch = 1\n            fade_in = 20to40\n            move = walk, -10to10, -10to10, 0.01to0.02\n            visual = trail\n    loop \"music/drone\":\n            volume = 0.25\n            pitch = 2\n            fade_in = 40"
    },
    {
      "Source": "Assets/Examples/beat.sat",
      "Content": "fade_in = 20to40\n            move = walk, -10to10, -10to10, 0.01to0.02\n            visual = trail\n    loop \"music/drone\":\n            volume = 0.25\n            pitch = 2\n            fade_in = 40\n            move = walk, -10to10, -10to10, 0.01to0.02\n            visual = trail"
    },
    {
      "Source": "Assets/Examples/birds.sat",
      "Content": "# birds.sat\n\nloop \"ambience/forest\":\n    volume   = 0.08\n    fade_in  = 1\n    \ngroup birds:\n    oneshot \"bird/1to3\" every 1to5:\n        volume = 0.8to1\n        fade_in = 1to5\n        move = fly, -10to10, 0to15, -10to10, 0.1to0.3\n        visual = trail\n        \n    oneshot \"bird/1to3\" every 1to5:\n        volume = 0.8to1\n        fade_in = 1to5\n        move = fly, -10to10, 0to15, -10to10, 0.1to0.3\n        visual = trail\nvolume = 1\npitch = 0.5"
    },
    {
      "Source": "Assets/Examples/monks.sat",
      "Content": "loop \"music/drone\":\n    volume = 0.5\n    pitch = 0.1to0.5\n    move = walk, -10to10, -5to8, 1\n    visual = trail and cube\n    fade_out = 5\n\noneshot \"bird/1to4\" every 1to5:\n    volume = 0.1\n    fade_in = 0.5to2\n    move = fly, -10to10, 2to15, -10to10, 0.1to0.3\n    visual = trail\n\noneshot \"bird/1to4\" every 1to5:\n    volume = 0.1\n    fade_in = 0.5to2\n    move = fly, -10to10, 2to15, -10to10, 0.1to0.3\n    visual = trail\n\noneshot \"bird/1to4\" every 1to5:\n    volume = 0.1\n    fade_in = 0.5to2\n    move = fly, -10to10, 2to15, -10to10, 0.1to0.3\n    visual = trail\n\noneshot \"bird/1to4\" every 1to5:\n    volume = 0.1\n    fade_in = 0.5to2\n    move = fly, -10to10, 2to15, -10to10, 0.1to0.3\n    visual = trail\n\noneshot \"bird/1to4\" every 1to5:\n    volume = 0.1\n    fade_in = 0.5to2\n    move = fly, -10to10, 2to15, -10to10, 0.1to0.3\n    visual = trail\n\noneshot \"bird/1to4\" every 2to6:\n    volume = 0.1\n    fade_in = 0.5to2\n    move = fly, -12to12, 1to18, -12to12, 0.1to0.4\n    visual = trail\n\noneshot \"bird/1to4\" every 2to6:\n    volume = 0.1\n    fade_in = 0.5to2\n    move = fly, -12to12, 1to18, -12to12, 0.1to0.4\n    visual = trail\n\noneshot \"bird/1to4\" every 2to6:\n    volume = 0.1\n    fade_in = 0.5to2"
    },
    {
      "Source": "Assets/Examples/monks.sat",
      "Content": "ird/1to4\" every 2to6:\n    volume = 0.1\n    fade_in = 0.5to2\n    move = fly, -12to12, 1to18, -12to12, 0.1to0.4\n    visual = trail\n\noneshot \"bird/1to4\" every 2to6:\n    volume = 0.1\n    fade_in = 0.5to2\n    move = fly, -12to12, 1to18, -12to12, 0.1to0.4\n    visual = trail\n\noneshot \"bird/1to4\" every 2to6:\n    volume = 0.1\n    fade_in = 0.5to2\n    move = fly, -12to12, 1to18, -12to12, 0.1to0.4\n    visual = trail\n\noneshot \"bird/1to4\" every 2to6:\n    volume = 0.1\n    fade_in = 0.5to2\n    move = fly, -12to12, 1to18, -12to12, 0.1to0.4\n    visual = trail"
    },
    {
      "Source": "Assets/Examples/parth-afternoon.sat",
      "Content": "group farm:\nvolume = 2\n\n    oneshot \"animals/cow1\" every 5to20:\n        volume = 0.1to0.2\n        pitch = 0.5to1.2\n        fade_in = 5to10\n        move = fly, -40to20, 0to10, -35to10, 0.01\n        visual = trail\n\n    3 * oneshot \"animals/cicada\" every 5to10:\n        volume = 0.03to0.08\n        pitch = 0.5to1.2\n        fade_in = 5to10\n        visual = trail\n\n\n    loop \"ambience/forest\":\n        volume = 0.002\n\n    loop \"tractor\":\n        volume = 0.05\n        move = walk, -10to9, -10to20, 0.005\n        visual = trail"
    },
    {
      "Source": "Assets/Examples/parth-dawn.sat",
      "Content": "3 * oneshot \"animals/cow2\" every 5to10:\n    volume = 0.1to0.2\n    pitch = 0.5to1.2\n    fade_in = 5to10\n    move = fly, -20to20, 0to10, -15to10, 0.01\n    visual = trail\n\noneshot \"animals/cicada\" every 5to10:\n    volume = 0.1to0.2\n    pitch = 0.5to1.2\n    fade_in = 5to10\n    visual = trail\n\n\n\noneshot \"bird/1to3\" every 4to10:\n    pitch = 0.6to1\n    volume = 0.01to0.1\n    move = fly, -20to20, 0to10, -15to10, 0.01"
    },
    {
      "Source": "Assets/Examples/test.sat",
      "Content": "loop \"ambience/forest\":\n    volume = 0.05\n4 * oneshot \"bird/1to7\" every 3to7:\n    volume = 0.06to0.15\n    move = fly, -10to20, 4to12, -10to10, 1\n    visual = trail and sphere\n2 * oneshot \"bird/1to7\" every 8to14:\n    volume = 0.04to0.10\n    move = fly, -35to35, 8to18, -35to35, 0.3to0.7\n    visual = trail"
    },
    {
      "Source": "Assets/Examples/voice.sat",
      "Content": "group onshots:\nvolume = 0.6\n    oneshot \"voice/1to40\" every 1to3:\n        volume = 0.2to0.5\n        move = walk, -10to10, -10to10, 0.05to0.06\n    oneshot \"voice/1to40\" every 1to3:\n        volume = 0.2to0.5\n        move = walk, -10to10, -10to10, 0.05to0.06\n    oneshot \"voice/1to40\" every 1to5:\n        volume = 0.2to0.5\n        move = walk, -10to10, -10to10, 0.05to0.06\n    oneshot \"voice/1to40\" every 1to3:\n        volume = 0.2to0.5\n        move = walk, -10to10, -10to10, 0.05to0.06\n    oneshot \"voice/1to40\" every 1to3:\n        volume = 0.2to0.5\n        move = walk, -10to10, -10to10, 0.05to0.06\n\ngroup loops:\n    loop \"voice/1to40\":\n        volume = 0.2to0.3\n        move = walk, -10to10, -10to10, 0.05to0.06\n        starts_at = 5to10\n        fade_in = 10to20\n        visual = trail\n    loop \"voice/1to40\":\n        volume = 0.2to0.3\n        move = walk, -20to20, -20to20, 0.05to0.06\n        starts_at = 5to10\n        fade_in = 10to20\n        visual = trail\n    loop \"voice/1to40\":\n        volume = 0.2to0.3\n        move = walk, -30to30, -30to30, 0.05to0.06\n        starts_at = 5to10\n        fade_in = 10to20\n        visual = trail"
    },
    {
      "Source": "ARCHITECTURE_OVERVIEW.md",
      "Content": "# SatieLang Modular Architecture\n\n## Overview\n\nSatieLang now uses a modular component-based architecture that separates concerns for better maintainability and extensibility.\n\n## Core Components\n\n### 1. SatieRuntime\n**Purpose**: Runtime execution of .sp scripts with spatial audio support\n\n**Responsibilities**:\n- Parse and execute .sp script files\n- Manage audio sources and spatial positioning\n- Handle real-time audio playback and effects\n- Steam Audio integration for HRTF\n- Visual effects (trails, primitives, prefabs)\n\n**Location**: `Assets/Scripts/SatieRuntime.cs`\n\n### 2. SatieAICodeGen\n**Purpose**: AI-powered code generation for .sp scripts\n\n**Responsibilities**:\n- OpenAI API integration for code generation\n- Resource-aware prompting (scans available audio files)\n- Conversation context management for follow-up edits\n- RLHF (Reinforcement Learning from Human Feedback)\n- Caching and performance optimization\n\n**Location**: `Assets/Scripts/SatieAICodeGen.cs`\n\n### 3. SatieAudioGen\n**Purpose**: Multi-provider audio generation\n\n**Responsibilities**:\n- AudioLDM2 integration (local AI audio generation)\n- Eleven Labs integration (cloud sound effects)\n- Test mode (sine wave generation)"
    },
    {
      "Source": "ARCHITECTURE_OVERVIEW.md",
      "Content": "urpose**: Multi-provider audio generation\n\n**Responsibilities**:\n- AudioLDM2 integration (local AI audio generation)\n- Eleven Labs integration (cloud sound effects)\n- Test mode (sine wave generation)\n- Audio format conversion and caching\n- Provider-specific parameter management\n\n**Location**: `Assets/Scripts/SatieAudioGen.cs`\n\n## Editor Architecture\n\n### Modular Inspector System\n\nEach component has its own dedicated editor with specialized functionality:\n\n#### SatieRuntimeEditor\n- Script file assignment and preview\n- Spatial audio configuration\n- Runtime controls (reload, reset)\n- Component dependency management\n- Play mode shortcuts\n\n#### SatieAICodeGenEditor\n- AI model configuration\n- Prompt interface with edit mode\n- Conversation history tracking\n- RLHF feedback collection\n- Generated code management\n\n#### SatieAudioGenEditor\n- Provider selection (AudioLDM2/ElevenLabs/Test)\n- Provider-specific settings (duration, prompt influence, inference steps)\n- Audio generation and preview\n- Multi-option generation with selection\n- Generated audio file management\n\n### Component Dependency System\n\nThe `SatieRuntimeEditor` includes a component setup section that:"
    },
    {
      "Source": "ARCHITECTURE_OVERVIEW.md",
      "Content": "o generation and preview\n- Multi-option generation with selection\n- Generated audio file management\n\n### Component Dependency System\n\nThe `SatieRuntimeEditor` includes a component setup section that:\n- Checks for presence of all required components\n- Provides one-click setup to add missing components\n- Shows status indicators for each component\n- Guides users through proper configuration\n\n## Usage Workflow\n\n### Initial Setup\n1. Create a GameObject with `SatieRuntime` component\n2. Unity Inspector will show \"Component Setup\" section\n3. Click \"Add All Missing Components\" to add AI and Audio generation\n4. Each component now has its own inspector section\n\n### AI Code Generation\n1. Use `SatieAICodeGen` inspector section\n2. Configure API key and model settings\n3. Enter natural language prompt\n4. Toggle edit mode for follow-up modifications\n5. Apply generated code to runtime\n\n### Audio Generation\n1. Use `SatieAudioGen` inspector section\n2. Choose provider (AudioLDM2 for experimental, ElevenLabs for professional)\n3. Configure provider-specific settings via sliders\n4. Generate multiple options and preview\n5. Save selected audio to Resources folder\n\n### Runtime Execution"
    },
    {
      "Source": "ARCHITECTURE_OVERVIEW.md",
      "Content": "perimental, ElevenLabs for professional)\n3. Configure provider-specific settings via sliders\n4. Generate multiple options and preview\n5. Save selected audio to Resources folder\n\n### Runtime Execution\n1. Assign .sp script to `SatieRuntime`\n2. Configure spatial audio settings\n3. Use runtime controls for testing\n4. Real-time reload with R/Shift+R shortcuts\n\n## Benefits of Modular Architecture\n\n### Separation of Concerns\n- Runtime execution isolated from generation logic\n- AI and audio generation are independent\n- Each component can be developed/tested separately\n\n### Extensibility\n- Easy to add new audio providers\n- AI models can be swapped without affecting other systems\n- New generation methods can be added as separate components\n\n### Maintainability\n- Clear ownership of functionality\n- Reduced coupling between systems\n- Easier debugging and testing\n\n### User Experience\n- Specialized interfaces for different tasks\n- Progressive disclosure of complexity\n- Clear visual organization in Inspector\n\n## Configuration Files\n\n### audio_config.json\n```json\n{\n  \"default_provider\": \"audioldm2\",\n  \"elevenlabs\": {\n    \"api_key\": \"your_key_here\",\n    \"duration_seconds\": 10.0,"
    },
    {
      "Source": "ARCHITECTURE_OVERVIEW.md",
      "Content": "l organization in Inspector\n\n## Configuration Files\n\n### audio_config.json\n```json\n{\n  \"default_provider\": \"audioldm2\",\n  \"elevenlabs\": {\n    \"api_key\": \"your_key_here\",\n    \"duration_seconds\": 10.0,\n    \"prompt_influence\": 0.3\n  },\n  \"audioldm2\": {\n    \"model_id\": \"cvssp/audioldm2\",\n    \"use_float16\": true,\n    \"num_inference_steps\": 200,\n    \"audio_length_in_s\": 10.0\n  }\n}\n```\n\n### api_key.txt\nContains OpenAI API key for AI code generation\n\n## Development Guidelines\n\n### Adding New Features\n1. Determine which component the feature belongs to\n2. Add functionality to the component class\n3. Update the corresponding editor if UI changes are needed\n4. Maintain separation of concerns\n\n### Component Communication\n- Components communicate through Unity's standard patterns\n- Use events/callbacks for loose coupling\n- Avoid direct references between generation components\n\n### Testing Strategy\n- Each component can be tested independently\n- Use dependency injection for external services\n- Mock external APIs for unit testing\n\n## Migration from Legacy Architecture\n\nThe old monolithic `SatieRuntimeEditor` has been replaced with the modular system. Key changes:"
    },
    {
      "Source": "ARCHITECTURE_OVERVIEW.md",
      "Content": "on for external services\n- Mock external APIs for unit testing\n\n## Migration from Legacy Architecture\n\nThe old monolithic `SatieRuntimeEditor` has been replaced with the modular system. Key changes:\n\n- **Before**: Single large editor with all functionality mixed together\n- **After**: Three focused editors, each handling specific concerns\n- **Migration**: Existing GameObjects will automatically detect missing components and offer to add them\n\nThis modular approach provides a solid foundation for future enhancements while maintaining clean separation of concerns and excellent user experience."
    },
    {
      "Source": "AUDIO_GENERATION_README.md",
      "Content": "# Audio Generation Setup for SatieLang\n\nThis system supports multiple audio generation providers: AudioLDM2 (local AI model) and Eleven Labs (cloud-based sound effects).\n\n## Features\n\n- **AudioLDM2**: Open-source text-to-audio generation (runs locally)\n- **Eleven Labs**: High-quality sound effects generation (requires API key)\n- **Test Mode**: Simple sine wave generation for testing\n- **Unity Integration**: Full control through Inspector settings\n\n## Setup Instructions\n\n### 1. Install Python Dependencies\n\n```bash\n# Create virtual environment (recommended)\npython3 -m venv audioldm2_venv\nsource audioldm2_venv/bin/activate  # On Windows: audioldm2_venv\\Scripts\\activate\n\n# Install requirements\npip install -r requirements.txt\n```\n\n### 2. Configure Providers\n\nCreate or edit `audio_config.json`:\n\n```json\n{\n  \"default_provider\": \"audioldm2\",\n  \"elevenlabs\": {\n    \"api_key\": \"YOUR_ELEVENLABS_API_KEY_HERE\",\n    \"duration_seconds\": 10.0,\n    \"prompt_influence\": 0.3\n  },\n  \"audioldm2\": {\n    \"model_id\": \"cvssp/audioldm2\",\n    \"use_float16\": true,\n    \"num_inference_steps\": 200,\n    \"audio_length_in_s\": 10.0\n  }\n}\n```\n\n#### Getting an Eleven Labs API Key:\n1. Sign up at https://elevenlabs.io"
    },
    {
      "Source": "AUDIO_GENERATION_README.md",
      "Content": "odel_id\": \"cvssp/audioldm2\",\n    \"use_float16\": true,\n    \"num_inference_steps\": 200,\n    \"audio_length_in_s\": 10.0\n  }\n}\n```\n\n#### Getting an Eleven Labs API Key:\n1. Sign up at https://elevenlabs.io\n2. Go to Profile Settings \u2192 API Keys\n3. Generate and copy your API key\n4. Paste it in `audio_config.json`\n\n### 3. Start the Server\n\n```bash\n# Activate virtual environment first if not already active\nsource audioldm2_venv/bin/activate\n\n# Run the server\npython audio_generation_server.py\n```\n\nThe server will start on `http://localhost:5001`\n\n### 4. Unity Configuration\n\nIn Unity, the SatieAudioGen component provides these Inspector settings:\n\n#### Server Configuration\n- **API URL**: Server endpoint (default: `http://localhost:5001/generate`)\n- **Sample Rate**: Audio sample rate (default: 44100)\n- **Num Options**: Number of variations to generate\n- **Default Provider**: Choose between AudioLDM2, ElevenLabs, or Test\n\n#### Eleven Labs Settings (visible in Inspector)\n- **Duration**: Sound effect duration (1-30 seconds)\n- **Prompt Influence**: How closely to follow the prompt (0-1, where 0.3 is balanced)\n\n#### AudioLDM2 Settings (visible in Inspector)"
    },
    {
      "Source": "AUDIO_GENERATION_README.md",
      "Content": "n Inspector)\n- **Duration**: Sound effect duration (1-30 seconds)\n- **Prompt Influence**: How closely to follow the prompt (0-1, where 0.3 is balanced)\n\n#### AudioLDM2 Settings (visible in Inspector)\n- **Inference Steps**: Quality/speed tradeoff (50-500, higher = better quality but slower)\n- **Duration**: Audio duration (1-30 seconds)\n\n## Usage Examples\n\n### From Unity Code\n\n```csharp\n// Using default provider\nvar result = await SatieAudioGen.Instance.GenerateAudioOptions(\n    \"ocean waves crashing on beach\",\n    numOptions: 3\n);\n\n// Using specific provider\nvar result = await SatieAudioGen.Instance.GenerateAudioOptions(\n    \"thunder and rain\",\n    numOptions: 2,\n    provider: AudioProvider.ElevenLabs\n);\n\n// Convert to AudioClip\nAudioClip clip = SatieAudioGen.Instance.ConvertBytesToAudioClip(\n    result.audioData[0],\n    \"generated_audio\"\n);\n```\n\n### Server API Endpoints\n\n#### Generate Single Audio\n```\nPOST http://localhost:5001/generate\n{\n    \"prompt\": \"waterfall in a cave\",\n    \"provider\": \"elevenlabs\",\n    \"duration_seconds\": 5,\n    \"prompt_influence\": 0.4\n}\n```\n\n#### Generate Multiple Variations\n```\nPOST http://localhost:5001/generate_multiple\n{"
    },
    {
      "Source": "AUDIO_GENERATION_README.md",
      "Content": "\"waterfall in a cave\",\n    \"provider\": \"elevenlabs\",\n    \"duration_seconds\": 5,\n    \"prompt_influence\": 0.4\n}\n```\n\n#### Generate Multiple Variations\n```\nPOST http://localhost:5001/generate_multiple\n{\n    \"prompt\": \"wind through trees\",\n    \"provider\": \"audioldm2\",\n    \"num_options\": 3\n}\n```\n\n#### Health Check\n```\nGET http://localhost:5001/health\n```\n\n## Provider Comparison\n\n| Feature | AudioLDM2 | Eleven Labs | Test Mode |\n|---------|-----------|-------------|-----------|\n| **Speed** | Slow (10-30s) | Fast (1-3s) | Instant |\n| **Quality** | Good | Excellent | Basic |\n| **Cost** | Free (local) | API credits | Free |\n| **GPU Required** | Recommended | No | No |\n| **Internet** | No (after download) | Yes | No |\n| **Best For** | Experimental sounds | Professional SFX | Testing |\n\n## Troubleshooting\n\n### Server won't start\n- Ensure all dependencies are installed: `pip install -r requirements.txt`\n- Check Python version (3.8+ required)\n- For AudioLDM2, first run will download the model (~2GB)\n\n### Eleven Labs errors\n- Verify API key in `audio_config.json`\n- Check API credits at https://elevenlabs.io\n- Ensure internet connection\n\n### Unity connection errors"
    },
    {
      "Source": "AUDIO_GENERATION_README.md",
      "Content": "n will download the model (~2GB)\n\n### Eleven Labs errors\n- Verify API key in `audio_config.json`\n- Check API credits at https://elevenlabs.io\n- Ensure internet connection\n\n### Unity connection errors\n- Check server is running: `python audio_generation_server.py`\n- Verify URL in Unity Inspector (default: `http://localhost:5001/generate`)\n- Check firewall settings\n\n### Performance issues\n- AudioLDM2: Use GPU if available (CUDA or MPS)\n- Reduce inference steps for faster generation (at cost of quality)\n- Use Test mode for rapid prototyping\n\n## Tips\n\n1. **Prompt Writing**: Be specific - \"heavy rain on metal roof\" works better than just \"rain\"\n2. **Variations**: Generate multiple options to choose the best one\n3. **Caching**: Generated audio is cached per prompt+provider combination\n4. **Testing**: Use Test mode for quick iterations, then switch to real providers"
    },
    {
      "Source": "README.md",
      "Content": "# SatieLang\n\nSatieLang is a Domain Specific Language (DSL) designed for generative and event-based audio scripting within the Unity game engine. It allows you to define complex audio behaviors with a simple, declarative syntax, managing audio playback, spatialization, and parameter randomization with ease.\n\n## Getting Started\n\n### Prerequisites\n\nYou need **Unity 2022.3.13f1**. You can download it from the Unity Hub or the Unity Download Archive:\n* [Unity Download Archive](https://unity.com/releases/editor/archive) (Search for 2022.3.13)\n\n### Quick Start: \"Hello World\" Demo Scene\n\nThe repository includes a demo scene to help you get started quickly:\n1.  Open the SatieLang project in Unity.\n2.  Navigate to the `Assets > Tutorial` folder in the Project window.\n3.  Open the scene named **\"Hello World\"**.\n4.  Press Play to experience SatieLang in action. Examine the Satie Script (`.sat` file) and the `SatieRuntime` component in the scene to see how it's configured.\n\n### Setting Up a New Scene\n\nTo use SatieLang in your own Unity scene:\n\n1.  Create a new scene (File > New Scene)."
    },
    {
      "Source": "README.md",
      "Content": "sat` file) and the `SatieRuntime` component in the scene to see how it's configured.\n\n### Setting Up a New Scene\n\nTo use SatieLang in your own Unity scene:\n\n1.  Create a new scene (File > New Scene).\n2.  Create an empty GameObject (GameObject > Create Empty). You might want to name it something like \"SatieAudioSystem\".\n3.  With the new GameObject selected, click \"Add Component\" in the Inspector window.\n4.  Search for and add the **`SatieRuntime`** component.\n5.  You will need a Satie Script to drive the audio. Create one as described below and assign it to the `Script File` field in the `SatieRuntime` component.\n\n### Creating a Satie Script\n\nSatieLang scripts are plain text files with a `.sat` extension. You can create them easily within Unity:\n\n1.  In the Project window, navigate to the folder where you want to create your script (e.g., `Assets/AudioScripts`).\n2.  Right-click in the folder.\n3.  Select **Create > Satie Script (.sat)**.\n4.  Unity will create a new Satie script file (e.g., `NewSatieScript.sat`) with some default content. Rename it as desired.\n\nThe default content will be:\n```satie\n# Satie Script - Hello World\nloop \"hello\":\n    volume = 0.8\n    pitch = 0.8..1.2\n```"
    },
    {
      "Source": "README.md",
      "Content": "g., `NewSatieScript.sat`) with some default content. Rename it as desired.\n\nThe default content will be:\n```satie\n# Satie Script - Hello World\nloop \"hello\":\n    volume = 0.8\n    pitch = 0.8..1.2\n```\n\nYou can also spawn multiple copies of a loop or oneshot by prefixing the\nstatement with a number and `*`. For example, the following plays four\nindependent loops of the same clip:\n\n```satie\n4 * loop \"hello\":\n    volume = 0.8\n    pitch = 0.8..1.2\n```\n\n### Full Tutorial\nFor a complete walkthrough of SatieLang syntax, usage, and examples, see the [SatieLang Tutorial](https://github.com/mateolarreaferro/SatieLang/blob/main/Assets/Tutorial.md)."
    },
    {
      "Source": "SteamAudio_Setup.md",
      "Content": "# Steam Audio HRTF Setup for SatieLang\n\n## Installation\n\n### 1. Download and Install Steam Audio\n\n**Manual Download Method:**\n1. Go to: https://valvesoftware.github.io/steam-audio/downloads.html\n2. Download the latest Unity plugin (e.g., `steamaudio_unity_4.5.3.zip`)\n3. Extract the zip file\n4. In Unity: Assets > Import Package > Custom Package\n5. Navigate to the extracted folder and select `SteamAudioUnity.unitypackage`\n6. Import all files\n\n**Alternative: Unity Asset Store**\n1. Open Unity Asset Store in browser\n2. Search for \"Steam Audio\"\n3. Add to My Assets\n4. In Unity: Window > Package Manager\n5. Switch dropdown to \"My Assets\"\n6. Download and Import Steam Audio\n\n### 2. Enable Steam Audio in Project\n\n1. **Add Scripting Define Symbol:**\n   - Edit > Project Settings > Player\n   - Scroll to \"Other Settings\" > \"Scripting Define Symbols\"\n   - Add: `STEAMAUDIO_ENABLED`\n   - Click Apply\n\n2. **Configure Audio Settings:**\n   - Edit > Project Settings > Audio\n   - Set \"Spatializer Plugin\" to: `Steam Audio Spatializer`\n   - Set \"Ambisonic Decoder Plugin\" to: `Steam Audio Ambisonics`\n\n### 3. Setup Your Scene\n\n1. **Add Steam Audio Manager:**"
    },
    {
      "Source": "SteamAudio_Setup.md",
      "Content": "Settings > Audio\n   - Set \"Spatializer Plugin\" to: `Steam Audio Spatializer`\n   - Set \"Ambisonic Decoder Plugin\" to: `Steam Audio Ambisonics`\n\n### 3. Setup Your Scene\n\n1. **Add Steam Audio Manager:**\n   - GameObject > 3D Object > Steam Audio > Steam Audio Manager\n   - Or manually add the component to an empty GameObject\n\n2. **Configure Main Camera:**\n   - Select your Main Camera\n   - Ensure it has Unity's Audio Listener component (required)\n   - Add Component > Steam Audio > Steam Audio Listener\n   - The Steam Audio Listener works alongside Unity's Audio Listener (do NOT remove/disable it)\n\n3. **Optional: Add Room/Environment:**\n   - For reverb and occlusion effects\n   - GameObject > 3D Object > Steam Audio > Steam Audio Probe Batch\n   - Configure room size and material properties\n\n## Using with SatieLang\n\nThe integration is automatic! When Steam Audio is installed:\n\n1. All spatialized sounds (with `move` parameter) will use HRTF\n2. The `useHRTF` checkbox appears in SatieRuntime inspector\n3. Enable/disable HRTF per scene as needed\n\n### How it Works:\n- **AudioSource.spatialize = true** enables the spatializer plugin"
    },
    {
      "Source": "SteamAudio_Setup.md",
      "Content": "l use HRTF\n2. The `useHRTF` checkbox appears in SatieRuntime inspector\n3. Enable/disable HRTF per scene as needed\n\n### How it Works:\n- **AudioSource.spatialize = true** enables the spatializer plugin\n- If Steam Audio Spatializer is selected in Project Settings, it provides HRTF\n- If not configured, Unity's default spatializer is used (basic 3D panning)\n- The SteamAudioSource component adds optional features (occlusion, reflections)\n\n### Example .sat file:\n```satie\n# HRTF will be applied to these moving sources\noneshot \"bird/1to4\" every 2to5:\n    volume = 0.8\n    move = fly, -10to10, 0to10, -10to10, 0.5\n    visual = sphere\n\n# Static sounds also benefit from HRTF\nloop \"ambience/forest\":\n    volume = 0.3\n    move = pos, 5, 2, -3\n```\n\n## Steam Audio Settings (in SatieRuntime)\n\nThe following settings are configured automatically:\n- **Directivity**: 0.0 (omnidirectional)\n- **Occlusion**: Enabled (raycast-based)\n- **Transmission**: Enabled (frequency-dependent)\n- **Reflections**: Enabled (real-time)\n\n## Testing Your Setup\n\n1. **Wear Headphones** (HRTF only works with headphones)\n\n2. **Create a test scene:**\n   - Add SatieRuntime to an empty GameObject"
    },
    {
      "Source": "SteamAudio_Setup.md",
      "Content": "dent)\n- **Reflections**: Enabled (real-time)\n\n## Testing Your Setup\n\n1. **Wear Headphones** (HRTF only works with headphones)\n\n2. **Create a test scene:**\n   - Add SatieRuntime to an empty GameObject\n   - Create a simple .sat file with moving sounds\n   - Enable \"Use HRTF\" in the inspector\n\n3. **What to listen for:**\n   - Clear front/back differentiation\n   - Vertical positioning (up/down)\n   - Smooth movement without clicks\n   - Natural distance attenuation\n\n## Performance Optimization\n\n- **Max Sources**: Keep under 32-64 HRTF sources\n- **Distance Culling**: Sounds beyond 50m can use simpler spatialization\n- **LOD System**: Consider disabling HRTF for background/ambient sounds\n\n## Troubleshooting\n\n**\"There are no audio listeners in the scene\" error:**\n- Ensure Unity's AudioListener component is present and enabled on Main Camera\n- Steam Audio Listener requires Unity's AudioListener to be active\n- Do NOT disable or remove Unity's AudioListener component\n\n**No HRTF effect:**\n- Check headphones are connected\n- Verify Steam Audio Spatializer is selected in Audio settings\n- Ensure STEAMAUDIO_ENABLED is in define symbols\n- Check useHRTF is enabled in SatieRuntime"
    },
    {
      "Source": "SteamAudio_Setup.md",
      "Content": "effect:**\n- Check headphones are connected\n- Verify Steam Audio Spatializer is selected in Audio settings\n- Ensure STEAMAUDIO_ENABLED is in define symbols\n- Check useHRTF is enabled in SatieRuntime\n\n**Performance issues:**\n- Reduce reflection quality in Steam Audio Manager\n- Decrease occlusion rays from 16 to 8\n- Disable transmission for non-critical sounds\n\n**Build errors:**\n- If Steam Audio components are missing, check the package is imported\n- Ensure all platforms have Steam Audio native libraries\n\n## Platform Support\n\n| Platform | Status | Notes |\n|----------|--------|-------|\n| Windows  | \u2705 Fully Supported | Best performance |\n| macOS    | \u2705 Fully Supported | Intel & Apple Silicon |\n| Linux    | \u2705 Fully Supported | Ubuntu 18.04+ tested |\n| Android  | \u2705 Supported | May need optimization |\n| iOS      | \u2705 Supported | Requires iOS 10+ |\n| WebGL    | \u274c Not Supported | Use Resonance Audio instead |\n\n## Advanced Features\n\n### Custom HRTF Profiles\nSteam Audio supports custom HRTF datasets:\n1. Place .sofa files in StreamingAssets/SteamAudio/\n2. Select in Steam Audio Manager > HRTF settings\n\n### Acoustic Materials\nDefine surface properties for realistic reflections:"
    },
    {
      "Source": "SteamAudio_Setup.md",
      "Content": "custom HRTF datasets:\n1. Place .sofa files in StreamingAssets/SteamAudio/\n2. Select in Steam Audio Manager > HRTF settings\n\n### Acoustic Materials\nDefine surface properties for realistic reflections:\n- Steam Audio > Create > Acoustic Material\n- Assign to meshes with Steam Audio Geometry component\n\n### Performance Profiling\n- Window > Analysis > Profiler\n- Check Audio DSP usage\n- Target < 25% for smooth playback"
    },
    {
      "Source": "requirements.txt",
      "Content": "flask==3.0.0\nflask-cors==4.0.0\ntorch>=2.0.0\ndiffusers>=0.25.0\ntransformers>=4.30.0\naccelerate>=0.20.0\nsoundfile==0.12.1\nlibrosa==0.10.1\nnumpy>=1.24.0\nscipy>=1.10.0\nrequests>=2.31.0\npydub>=0.25.1\nelevenlabs>=0.2.27"
    }
  ]
}